1
00:00:00,470 --> 00:00:01,940
안녕하세요 오늘 실시간 의료

2
00:00:01,940 --> 00:00:03,830
인공지능 데이터 처리를 위한 잔고

3
00:00:03,830 --> 00:00:07,010
커리 옵티마이제이션 발표를 하게 된 윤상입니다

4
00:00:07,010 --> 00:00:08,920
저에 대해 간단히 소개해 드리자면

5
00:00:08,920 --> 00:00:10,970
저는 현재 카이스트 4학년이고

6
00:00:10,970 --> 00:00:12,390
올해 1월부터 휴가라고

7
00:00:12,390 --> 00:00:15,550
앨리스라는 의료인공지능 스타트업에서 소프트웨어 엔지니어

8
00:00:15,550 --> 00:00:16,640
인천 했고

9
00:00:16,640 --> 00:00:19,260
그 때 배웠던 점들을 공유해 드리고자 합니다

10
00:00:19,260 --> 00:00:21,590
시작하기에 앞서 제가 달을 내용이 조금 많아서

11
00:00:21,590 --> 00:00:25,150
조금 빠르게 말씀드리는 점 양해 부탁드립니다

12
00:00:25,150 --> 00:00:28,770
제가 발표할 내용은 다음과 같습니다

13
00:00:28,770 --> 00:00:32,190
먼저 회사에서 개발중인 잔고를 영화 서비스를

14
00:00:32,190 --> 00:00:36,800
성능의 문제점을 중심으로 설명 드리려고 합니다

15
00:00:36,800 --> 00:00:40,160
그 다음 문제점을 개선하기 위해 커리를 분석해 하겠죠

16
00:00:40,160 --> 00:00:43,290
그럼 약간의 5월에는 관련된 지식과 프로파일링

17
00:00:43,290 --> 00:00:45,130
7에 대한 소개가 필요하기 때문에

18
00:00:45,130 --> 00:00:46,930
그 부분에 대해서 설명해 드리고

19
00:00:46,930 --> 00:00:49,940
마지막으로 실제 사례를 보면 속도를 어떻게

20
00:00:49,940 --> 00:00:54,590
그리고 얼마나 계산 시켜 들었는지를 설명해드리려고 함

21
00:00:54,590 --> 00:00:56,860
회사에서 개발중인 잔고 를 이용한

22
00:00:56,860 --> 00:00:59,500
서비스에 대해서 보겠습니다

23
00:00:59,500 --> 00:01:02,920
저희는 병원에 입원한 환자들이 급성 질환에 걸릴 확률

24
00:01:02,920 --> 00:01:05,520
예측해서 보여주는 서비스를 하고 있습니다

25
00:01:05,520 --> 00:01:07,490
병원에서 환자 정보를 보내 주면

26
00:01:07,490 --> 00:01:11,680
저희 서비스는 그 정보를 저장하여 머신러닝 모델 보낸 후

27
00:01:11,680 --> 00:01:15,400
환자가 향우회 측정 질병에 걸릴 확률 예측 해 줍니다

28
00:01:15,400 --> 00:01:17,820
병원에 입원 환자들은 급성질환

29
00:01:17,820 --> 00:01:21,340
예를 들면 10증 걸릴 확률이 매우 높다고 합니다

30
00:01:21,340 --> 00:01:22,760
헤어지는 죽음에 이르기까지

31
00:01:22,760 --> 00:01:24,790
매우 짧은 시간이 걸리기 때문에

32
00:01:24,790 --> 00:01:27,260
조기 치료가 생존율에 있어서 매우 중요합니다

33
00:01:27,260 --> 00:01:30,490
그래서 저희는 빠르게 환자의 건강 상태를 업데이트하여

34
00:01:30,490 --> 00:01:31,920
최대한 조기에 질병에

35
00:01:31,920 --> 00:01:36,570
대응할 수 있는 서비스를 내고 있습니다

36
00:01:36,570 --> 00:01:38,640
병원 가 저희 서비스는 실시간으로

37
00:01:38,640 --> 00:01:40,700
정보를 업데이트 해 주는 것이 필수적입니다

38
00:01:40,700 --> 00:01:43,440
앞서 말씀드렸듯이 환자의 상태가 이상하여

39
00:01:43,440 --> 00:01:44,850
알람이 발생하였을 때

40
00:01:44,850 --> 00:01:47,570
신속하게 알려 바른 처치가 이거 하는 것이

41
00:01:47,570 --> 00:01:53,280
환자의 사망률을 낮추는 데 있어서 정말 중요하기 때문에

42
00:01:53,280 --> 00:01:55,790
먼저 병원에서 들어온 데이터를 처리해 주기 위해

43
00:01:55,790 --> 00:01:58,630
데이터를 저장하는 부분을 자세히 보겠습니다

44
00:01:58,630 --> 00:02:01,220
병원에서는 매분마다 수백 명의 환자

45
00:02:01,220 --> 00:02:04,920
정보가 새로 갱신되어 리스트로 들어오게 됩니다

46
00:02:04,920 --> 00:02:07,910
그럼 저희는 그렇게 api 로 들어온 정보를 잔고

47
00:02:07,910 --> 00:02:10,280
알림 을 이용해서 회사 내 뒤에 빠르게

48
00:02:10,280 --> 00:02:13,680
저장 또는 업데이트를 합니다

49
00:02:13,680 --> 00:02:15,680
바로 여기서 성능상 문제가 있습니다

50
00:02:15,680 --> 00:02:17,250
내 분마다 3명의 환자

51
00:02:17,250 --> 00:02:20,430
정보가 한꺼번에 들어오는데 이 데이터를 저장하는데

52
00:02:20,430 --> 00:02:22,590
상당히 많은 시간이 소요되고 있습니다

53
00:02:22,590 --> 00:02:25,760
말씀드렸다시피 저희 서비스는 1초라도 빠르게

54
00:02:25,760 --> 00:02:29,080
데이터를 동기화 하는 것이 중요하기 때문에 이 부분에 sql

55
00:02:29,080 --> 00:02:32,290
튜닝 계속 가는 삐졌습니다

56
00:02:32,290 --> 00:02:33,700
그 다음으로 DB 에

57
00:02:33,700 --> 00:02:35,040
저장된 데이터를 빠르게

58
00:02:35,040 --> 00:02:38,880
머신러닝 모델에 전송해주는 방법에 대해 보겠습니다

59
00:02:38,880 --> 00:02:42,380
현재 저희의 급성질환 예측 솔루션은 데이터베이스에

60
00:02:42,380 --> 00:02:44,860
저장 되어 있는 정보를 1시간 간격으로

61
00:02:44,860 --> 00:02:48,210
앱을 실행해서 머신러닝모델 서버에 보내주고

62
00:02:48,210 --> 00:02:51,150
머슬런닝 서버는 그 정보를 가지고

63
00:02:51,150 --> 00:02:54,400
환자가 측정 병에 걸릴 확률은 저에게 보내 주시고

64
00:02:54,400 --> 00:02:58,480
저희 솔루션은 그 값을 받아서 저장합니다

65
00:02:58,480 --> 00:03:02,000
메인서버에 저는 각 환자에 대해 특정 시간 간격 사이에 환자

66
00:03:02,000 --> 00:03:05,860
생체정보 와서 머신러닝 모델 서버의 보내기

67
00:03:05,860 --> 00:03:09,340
예를 들면 지금부터 하루 전 똥 안에 뭐 맥박수

68
00:03:09,340 --> 00:03:13,280
심박수 등의 정보를 취합해서 보내게 됩니다

69
00:03:13,280 --> 00:03:17,050
그럼 머신러닝 모델 서버는 그 정보를 ML 모델의 넣고

70
00:03:17,050 --> 00:03:20,940
결과로 환자에 대한 예측값을 보여주게 됩니다

71
00:03:20,940 --> 00:03:25,160
이걸 매분마다 환자의 데이터를 3층에서 머신러닝 서버에 보내지

72
00:03:25,160 --> 00:03:27,490
예측값을 받아서 저장해 합니다

73
00:03:27,490 --> 00:03:28,940
따라서 빠르게 세팅하고

74
00:03:28,940 --> 00:03:32,000
결과값을 빠르게 저장해 두기 위해서 커리 옵티마이제이션

75
00:03:32,000 --> 00:03:34,590
이수행 되어야 할 것입니다

76
00:03:34,590 --> 00:03:37,380
정리를 하자면 저희는 병원데이터 와 연동하여

77
00:03:37,380 --> 00:03:40,700
환자가 급성 질환에 걸릴 확률 예측 해 주고 있고

78
00:03:40,700 --> 00:03:43,460
그를 위해 실시간 환자 데이터를 빠르게 동기화하고

79
00:03:43,460 --> 00:03:46,400
시간대별로 빠르게 설치하는 것이 중요한 서비스입니다

80
00:03:46,400 --> 00:03:49,970
그리고 지금 이 2분이 2분이 느리게 진행되고 있어서

81
00:03:49,970 --> 00:03:52,010
앞으로 이 부분에 대한 성능 개선

82
00:03:52,010 --> 00:03:55,390
에 대해서 말씀 드릴 예정입니다

83
00:03:55,390 --> 00:03:59,300
좋아요 그럼 지금 서비스의 성능상 문제점을 소개 소개 드렸으니

84
00:03:59,300 --> 00:04:02,690
먼저 현재서비스 서비스의 성령을 정량적으로 측정하고

85
00:04:02,690 --> 00:04:04,620
스노우 커리를 뭐야 겠죠

86
00:04:04,620 --> 00:04:05,870
그 전에 잠깐 잔고

87
00:04:05,870 --> 00:04:09,770
1M2 무엇인지에 대해서 설명 해 보도록 하겠습니다

88
00:04:09,770 --> 00:04:13,470
잔고 아름이랑 5부작 시뮬레이션으로 맵핑 이라는 뜻으로

89
00:04:13,470 --> 00:04:17,300
객체지향적인 방법으로 데이터 달 수 있게 해 줍니다

90
00:04:17,300 --> 00:04:18,770
로컬을 쓰지 않아도

91
00:04:18,770 --> 00:04:21,060
그 것과 동일한 연산을 수행할 수 있도록

92
00:04:21,060 --> 00:04:24,420
모델 매니저가 도와준다는 뜻입니다

93
00:04:24,420 --> 00:04:26,970
저희 서비스는 잔고 원룸을 이용하고 있는데요

94
00:04:26,970 --> 00:04:28,400
실제로 사용하는 말하지만

95
00:04:28,400 --> 00:04:30,700
수업 몇 가지만 소개시켜 드리려고 합니다

96
00:04:30,700 --> 00:04:34,030
먼저 계승 셀렉트를 예를 들어서 환자

97
00:04:34,030 --> 00:04:35,290
테이블에이 아이디가 1

98
00:04:35,290 --> 00:04:37,690
0 1 0 1 한자를 가지고 싶다면

99
00:04:37,690 --> 00:04:40,310
페이션트 단어 200개 YD 는 1

100
00:04:40,310 --> 00:04:43,450
0 1 0 2 라고 쓰고 있는 교회에서

101
00:04:43,450 --> 00:04:47,670
펌웨어를 들을 생각이 됩니다

102
00:04:47,670 --> 00:04:50,870
세븐은 오브젝트를 생성하거나 업데이트합니다

103
00:04:50,870 --> 00:04:52,080
저희 서비스중에 의사

104
00:04:52,080 --> 00:04:54,650
선생님께서 자유롭게 작성할 수 있는 네모

105
00:04:54,650 --> 00:04:55,820
기능이 있는데

106
00:04:55,820 --> 00:04:59,840
메모장 세이브를 부르게 되면 의미있는 메모는 업데이트 부르고

107
00:04:59,840 --> 00:05:04,470
신규 메모는 인설트 개돌

108
00:05:04,470 --> 00:05:06,260
크리슨 먼저 셀렉트를 통해

109
00:05:06,260 --> 00:05:09,660
해당 조건을 만족하는 오브젝트가 있는지를 찾습니다

110
00:05:09,660 --> 00:05:11,810
그리고 있다면 다시 셀렉트를 수행해

111
00:05:11,810 --> 00:05:16,050
그 오브젝트를 리턴합니다

112
00:05:16,050 --> 00:05:19,000
만약 해당 조건을 만족하는 셀렉트 가 없다면

113
00:05:19,000 --> 00:05:21,440
개 골프 레슨 insert into

114
00:05:21,440 --> 00:05:23,570
A single 오브젝트를 만들고 반환합니다

115
00:05:23,570 --> 00:05:29,950
총 2개의 거리를 생각하게 되는 것이고

116
00:05:29,950 --> 00:05:31,780
벌크 잊은 커리 한 번으로

117
00:05:31,780 --> 00:05:33,860
여러 개의 오브젝트를 한 번에 생성합니다

118
00:05:33,860 --> 00:05:35,660
다만 벌크 있을 때

119
00:05:35,660 --> 00:05:36,950
주의하실 점은 이

120
00:05:36,950 --> 00:05:39,490
친구는 세이브를 부르지 않는다는 점입니다

121
00:05:39,490 --> 00:05:42,940
즉 잔고 내부에서 보내주는 시그널이 되지 않습니다

122
00:05:42,940 --> 00:05:45,850
나중에 생성된 이후에 어떤 작업을 하기 위해 잔고

123
00:05:45,850 --> 00:05:47,720
시그널을 사용했다면 이 부분은

124
00:05:47,720 --> 00:05:51,380
염두해 주시면 좋을 것 같습니다

125
00:05:51,380 --> 00:05:54,450
그 다음 장 9월의 특징에 대해서 얘기해 보겠습니다

126
00:05:54,450 --> 00:05:57,500
잔고 5월에는 레이지모닝 뭐 하면서

127
00:05:57,500 --> 00:05:59,840
레이저 크게 두 가지가 있는데요

128
00:05:59,840 --> 00:06:01,530
첫 번째는 커리 세 마리

129
00:06:01,530 --> 00:06:04,520
코드와 같이 필터 같은 체인을 막 달다가

130
00:06:04,520 --> 00:06:06,610
그게 데이터에 접근하는 시점에

131
00:06:06,610 --> 00:06:10,200
실제 커리가 일어나는 의미 노인입니다

132
00:06:10,200 --> 00:06:12,890
쿼리를 쓴다고 해서 바로 실행이 되는 것이 아니라

133
00:06:12,890 --> 00:06:16,110
특정한 부분에서만 예를 들어서 트와이스 팬 미팅

134
00:06:16,110 --> 00:06:21,660
모든 중에서만 실제로 거리가 이별 회전되는 특징임

135
00:06:21,660 --> 00:06:24,860
두 번째는 릴레이 티드 오브젝트 실제로 접근할 때

136
00:06:24,860 --> 00:06:26,400
그제서야 릴레이 티드 오브젝트를

137
00:06:26,400 --> 00:06:28,420
캐치온은 레이지 2 입니다

138
00:06:28,420 --> 00:06:31,320
예를 들어 독소와 어쩔 수가 없어

139
00:06:31,320 --> 00:06:34,080
라잇 이러는 맵핑이 되어있다

140
00:06:34,080 --> 00:06:37,750
제목 이북 AN html 가져 오라고 할 때

141
00:06:37,750 --> 00:06:40,040
먼저 책에 대한 팬층이 먼저 일어나고

142
00:06:40,040 --> 00:06:44,030
그다음 두 개에 대해 가져온 없을 아이디를 가진 것들

143
00:06:44,030 --> 00:06:47,230
오브젝트를 베팅에 4인 가족에 장

144
00:06:47,230 --> 00:06:49,050
9월에는 이 두 가지의 레이지

145
00:06:49,050 --> 00:06:52,100
로딩 방법을 모두 채택하고 있습니다

146
00:06:52,100 --> 00:06:54,620
그런데 이레이징펜 친구 때문에 잔고

147
00:06:54,620 --> 00:06:57,220
걸음 에서는 앤플러스원 prov 발생합니다

148
00:06:57,220 --> 00:07:00,890
앤플러스원 province 필리핀 되어 있는 TV

149
00:07:00,890 --> 00:07:03,910
테이블간의 관련된 값을 가져오고 싶을 때

150
00:07:03,910 --> 00:07:06,050
필요한 쿼리를 더 수행하는 문제입니다

151
00:07:06,050 --> 00:07:07,660
예를 들어서 책과

152
00:07:07,660 --> 00:07:10,000
작가가 어떤 아이디로 연결되어 있을 때

153
00:07:10,000 --> 00:07:13,920
각 책에 어떤 내용을 모두 뽑아 오고 싶다고

154
00:07:13,920 --> 00:07:17,700
그를 위해 위와 같은 코드를 실행하였을때

155
00:07:17,700 --> 00:07:19,770
실제 sql 커리는 총책

156
00:07:19,770 --> 00:07:23,260
S 플러스 한 개가 발생하게 됩니다

157
00:07:23,260 --> 00:07:26,180
이것은 먼저 셋팅을 해주는 블레이즈

158
00:07:26,180 --> 00:07:30,900
블레이즈 될 수 없어서 해결할 수 있습니다 이 두 개의 대해서는

159
00:07:30,900 --> 00:07:35,990
나중에 발표에서 설명을 할 예정입니다

160
00:07:35,990 --> 00:07:38,290
그래서 잔고 하람이 대해서 정리를 하자면

161
00:07:38,290 --> 00:07:41,970
객체지향적인 방법으로 커리에 접근할 수 있는 방법이고

162
00:07:41,970 --> 00:07:44,060
레이즈빌딩 때문에 mps1

163
00:07:44,060 --> 00:07:45,890
proven 거 같은 문제가 있습니다

164
00:07:45,890 --> 00:07:52,400
그리고 저희 회사 코드에서의 내년까지 오월의 함수들도 살펴봤습니다

165
00:07:52,400 --> 00:07:53,960
좋아요 이제서 현재 서비스를

166
00:07:53,960 --> 00:07:56,150
어떻게 정량적으로 체크할 수 있는지

167
00:07:56,150 --> 00:08:00,370
프로파일링 술에 대해서 소개시켜 드리려고 합니다

168
00:08:00,370 --> 00:08:04,280
먼저 간단하게 세상에서 5월에 모루 실행한 실제 SQL

169
00:08:04,280 --> 00:08:08,100
문을 보고 싶다 할 때 쓸 수 있는 방법에 대해서 알려 드리겠습니다

170
00:08:08,100 --> 00:08:10,120
방값이 있을 경우

171
00:08:10,120 --> 00:08:11,220
5월의 내장된 커리

172
00:08:11,220 --> 00:08:14,090
너는 housing complex 보면

173
00:08:14,090 --> 00:08:18,590
전원된 콜미 스윙을 볼 수 있습니다

174
00:08:18,590 --> 00:08:23,120
또는 커넥션 모드 를 사용해서 커넥션 점 kris 가자

175
00:08:23,120 --> 00:08:25,290
마지막인덱스 를 호출 하게 된다면

176
00:08:25,290 --> 00:08:30,730
가장 마지막으로 실행된 쿼리스트링 를 볼 수 있습니다

177
00:08:30,730 --> 00:08:35,150
그래도 걸리는 시간을 보여준다는 차이점이 참고로

178
00:08:35,150 --> 00:08:36,110
치마 인데

179
00:08:36,110 --> 00:08:37,630
쉘에서 보여준 쿼리스트링

180
00:08:37,630 --> 00:08:40,770
실제로 실행되는 밸리댄스 큐를 아닙니다

181
00:08:40,770 --> 00:08:42,440
잔고 하려면 데이터베이스

182
00:08:42,440 --> 00:08:45,880
어댑터 에게 커리어 파라미터를 갔다 보내는 것이고

183
00:08:45,880 --> 00:08:50,910
실제 작업은 데이터베이스 어답터가 한답니다

184
00:08:50,910 --> 00:08:53,620
그래 다음에 좀 더 구체적으로 쿼리문을 비교하고

185
00:08:53,620 --> 00:08:55,190
성능을 측정하고 싶을 때

186
00:08:55,190 --> 00:08:58,380
쓸 수 있는 프로파일링 툴들을 소개해 드리겠습니다

187
00:08:58,380 --> 00:09:02,380
먼저 장고집 출발부터 보겠습니다

188
00:09:02,380 --> 00:09:04,060
설치 방법은 다음과 같습니다

189
00:09:04,060 --> 00:09:07,550
인터렉스 추가를 해주고 미들웨어에 추가해주고

190
00:09:07,550 --> 00:09:09,910
interp3 설정을 해 준 다음에

191
00:09:09,910 --> 00:09:13,430
URL 패스를 추가하시면 됩니다

192
00:09:13,430 --> 00:09:15,130
그러면 로컬호스트로 실행했을때

193
00:09:15,130 --> 00:09:17,130
djdd 메뉴가 생기는데요

194
00:09:17,130 --> 00:09:20,510
웹페이지 오른쪽에 디젤 누르면 타임

195
00:09:20,510 --> 00:09:22,190
sql 시간 등등 과 같은

196
00:09:22,190 --> 00:09:24,230
많은 것들을 모두 보여 줍니다

197
00:09:24,230 --> 00:09:27,910
그래서 개발자 다 집어 기념으로 유용한 유명한 프로파일링

198
00:09:27,910 --> 00:09:28,620
수리점

199
00:09:28,620 --> 00:09:32,190
하지만 지진은 로컬에서만 돌아가는 디버깅용 틀입니다

200
00:09:32,190 --> 00:09:34,360
실제로 라이브로 해남

201
00:09:34,360 --> 00:09:36,970
6월에 레포트로 들어오는 데이터에 대해서는

202
00:09:36,970 --> 00:09:41,140
프로파일링을 할 수 없다는 단점이 있습니다

203
00:09:41,140 --> 00:09:44,770
그렇기 때문에 저는 실크 라는 프로폴리스를 사용했습니다

204
00:09:44,770 --> 00:09:49,680
싱크는 장고프레임워크 overlapping djd 와 달리

205
00:09:49,680 --> 00:09:53,000
해당 url 의 living 가능한 틀리고

206
00:09:53,000 --> 00:09:56,270
과거 이력도 뒤에 저장하여 한 번에 보여 줘 한눈에 보고

207
00:09:56,270 --> 00:09:58,850
비교하기가 용이합니다

208
00:09:58,850 --> 00:10:00,570
설치 방법은 다음과 같습니다

209
00:10:00,570 --> 00:10:03,980
채팅 뉴스 Y 설정은 비슷하지만

210
00:10:03,980 --> 00:10:06,430
셀카는 DB 의 값을 저장해놓기 때문에

211
00:10:06,430 --> 00:10:07,460
DB 를 사용합니다

212
00:10:07,460 --> 00:10:11,480
그래서 마이그레이션 도 해 줘야 합니다

213
00:10:11,480 --> 00:10:14,360
그리고 마지막으로 프로파일링을 원하는 곳에

214
00:10:14,360 --> 00:10:18,160
데이터를 붙여 주고

215
00:10:18,160 --> 00:10:19,880
실크 페이지로 가 보게 되면 돼

216
00:10:19,880 --> 00:10:21,880
크레이터를 붙인 6월에 대해서

217
00:10:21,880 --> 00:10:25,420
리스폰스가 오기까지 걸리는 시간과 커리의 총 개수

218
00:10:25,420 --> 00:10:29,350
그리고 커리 걸리는 시간을 한눈에 보여줍니다

219
00:10:29,350 --> 00:10:31,920
각 이벤트들에 대한 상세 페이지로 들어가 보면

220
00:10:31,920 --> 00:10:36,430
싫기는 실제로 실행된 커리 문까지 모두 보여 줍니다

221
00:10:36,430 --> 00:10:42,070
또각 파리를 발생하게 한 함수의 트윈스 백도 보여 주고

222
00:10:42,070 --> 00:10:43,040
first 보여 줘

223
00:10:43,040 --> 00:10:46,820
스노우 core 분석을 더욱 용이하게 합니다

224
00:10:46,820 --> 00:10:48,870
섹스에 대해서 정리를 하자면

225
00:10:48,870 --> 00:10:50,120
djdd 와 달리

226
00:10:50,120 --> 00:10:53,250
라이브 환경에서 사용 가능한 프로파일링 트리고

227
00:10:53,250 --> 00:10:55,430
예전 히스토리를 저장해 놓을 수 있어서

228
00:10:55,430 --> 00:10:57,050
여러 인스턴트 이벤트들을 모아서

229
00:10:57,050 --> 00:10:59,550
한 번에 볼 수 있는 장점이 있습니다

230
00:10:59,550 --> 00:11:02,500
앞으로 protractor 지원하죠

231
00:11:02,500 --> 00:11:05,430
하지만 실제로 사이클을 붙여 보면

232
00:11:05,430 --> 00:11:08,320
데이터를 부친 6월에 대한 응답이 드렸습니다

233
00:11:08,320 --> 00:11:10,640
또 cfa 자체도 상당히

234
00:11:10,640 --> 00:11:13,120
그리고 orm 을 사용하지 않은 커리

235
00:11:13,120 --> 00:11:15,120
에 대해서는 브로콜리에 대해서 보여

236
00:11:15,120 --> 00:11:18,500
주지 않는다는 단점이 있습니다

237
00:11:18,500 --> 00:11:21,890
그래서 하는 법에 대해서 정리를 해보자면

238
00:11:21,890 --> 00:11:25,450
쿼리스트링 을 보는 방법으로는 5월에 맥쿼리 유튜브에서 나

239
00:11:25,450 --> 00:11:27,440
아니면 커넥션 쩜 컴 수가 있고

240
00:11:27,440 --> 00:11:31,260
프로파일링 prodigy 각각의 차이와 함께 소개

241
00:11:31,260 --> 00:11:32,770
시켜 드렸습니다

242
00:11:32,770 --> 00:11:34,000
그래서 여기까지 해서

243
00:11:34,000 --> 00:11:36,690
월매 대한 기본적인 지식과 프로파일링

244
00:11:36,690 --> 00:11:40,370
7에 대해서 살펴 보았습니다

245
00:11:40,370 --> 00:11:42,920
이제 드디어 profile 하는법도 알았고

246
00:11:42,920 --> 00:11:44,340
이름이 뭔지도 알았으니

247
00:11:44,340 --> 00:11:46,380
실제 서비스의 속도를 계산사례

248
00:11:46,380 --> 00:11:47,840
대해서 말해 보려고 합니다

249
00:11:47,840 --> 00:11:50,780
아까 말씀드렸던 두 가지 병목지점 중

250
00:11:50,780 --> 00:11:54,100
먼저 api 들어오는 대용량의 데이터를 빠르게 티비 로

251
00:11:54,100 --> 00:12:00,200
저장 할 때에 허리 옵티마이제이션 에 대해서 설명해 드리겠습니다

252
00:12:00,200 --> 00:12:03,770
처음에 보셨듯이 병원에서 받은 데이터를 저장하는 속도가

253
00:12:03,770 --> 00:12:07,100
너무 느린 문제가 있었습니다 이 부분을 분석해보기 위해

254
00:12:07,100 --> 00:12:08,970
데이터를 어떻게 받고

255
00:12:08,970 --> 00:12:13,440
처리했는지 좀 더 자세히 보겠습니다

256
00:12:13,440 --> 00:12:15,510
먼저 병원에서 매븐

257
00:12:15,510 --> 00:12:17,800
수백 개의 페이션트 오브젝트가 리스트로

258
00:12:17,800 --> 00:12:19,200
한 번에 들어옵니다

259
00:12:19,200 --> 00:12:20,810
여기서 이완이란 환자

260
00:12:20,810 --> 00:12:26,310
개개인의 식별할 수 있는 환자마다 가지는 고유한 아이디입니다

261
00:12:26,310 --> 00:12:29,870
현재 들어온 데이터를 8층에서 저장하는 코드입니다

262
00:12:29,870 --> 00:12:33,260
환자 하나하나에 대해서 펄스 페이션트 가 돌게 되는데

263
00:12:33,260 --> 00:12:37,970
해상유 아이디를 가진 페이션트 를 먼저 개굴 퀴즈 한 다음

264
00:12:37,970 --> 00:12:40,430
그래 값을 업데이트 해 준 다음에

265
00:12:40,430 --> 00:12:45,540
테이블을 호출해서 저장하는 방식입니다

266
00:12:45,540 --> 00:12:46,990
코드를 생각해 봤을 때

267
00:12:46,990 --> 00:12:48,670
일단 가장 큰 문제는 환자

268
00:12:48,670 --> 00:12:51,790
하나씩 저장해서 느리다는 결론에도 다했습니다

269
00:12:51,790 --> 00:12:53,410
즉 환자가 몇 명이 들어오든

270
00:12:53,410 --> 00:12:55,310
상관없이 한 번에 저장한다면

271
00:12:55,310 --> 00:13:00,220
저장하는 속도가 훨씬 것이라고 생각했습니다

272
00:13:00,220 --> 00:13:03,390
아 그러면 환자 한 명씩 저장하지 말고

273
00:13:03,390 --> 00:13:05,580
마지막에 한 번에 저장하면 되겠다 라고

274
00:13:05,580 --> 00:13:07,020
생각하게 되었고

275
00:13:07,020 --> 00:13:12,570
그래서 첫 번째 방법으로 발크리시나 하는 것을 시도했습니다

276
00:13:12,570 --> 00:13:14,390
어 기존의 네이버 라이브

277
00:13:14,390 --> 00:13:17,140
한우명가 바꾸면 의 차이점을 설명 드리겠습니다

278
00:13:17,140 --> 00:13:19,320
한 오브젝트씨 처리하는 방법 에서

279
00:13:19,320 --> 00:13:20,720
여러 오브젝트를 한 번에 처리

280
00:13:20,720 --> 00:13:22,700
하는 방식으로 변경하였고

281
00:13:22,700 --> 00:13:26,750
기존의 개돌 그대로 하되 하나씩 세이브 하는 것이 아니라

282
00:13:26,750 --> 00:13:32,890
업데이트된 모든 페이션트 를 한번 해 봐 타도록 표현했습니다

283
00:13:32,890 --> 00:13:34,460
하지만 입구에 있습니다

284
00:13:34,460 --> 00:13:37,210
왜냐하면 이미 계속해서 통해 생성되거나

285
00:13:37,210 --> 00:13:40,220
가져온 이미 존재하는 로고를 벌크

286
00:13:40,220 --> 00:13:44,110
예제를 통해서 다시 생성을 수 없었기 때문입니다

287
00:13:44,110 --> 00:13:45,720
그래서 두 번째로 시도한 방법은

288
00:13:45,720 --> 00:13:48,500
바로 질리지 않고 있습니다

289
00:13:48,500 --> 00:13:49,430
jeus 했기 때문에

290
00:13:49,430 --> 00:13:51,810
이미 존재하고 를 발급 부인할 수 없다

291
00:13:51,810 --> 00:13:54,050
문제가 발생 했으니

292
00:13:54,050 --> 00:13:57,300
개도 안 써도 되도록 기존 값이 다 지워 버리고

293
00:13:57,300 --> 00:14:02,770
벌금 둘리 Torque 3 변했습니다

294
00:14:02,770 --> 00:14:04,540
기존에 있던 값을 지우는 것은

295
00:14:04,540 --> 00:14:06,800
두 가지 방법으로 구현할 수 있는데요

296
00:14:06,800 --> 00:14:08,990
첫 번째는 로 알람 을 이용해 아이디로

297
00:14:08,990 --> 00:14:11,040
필터에서 지우는 방법이 고

298
00:14:11,040 --> 00:14:16,110
두 번째는 로컬이 를 이용해 직접 방법이었습니다

299
00:14:16,110 --> 00:14:19,540
외모 커리는 성능을 극대화할 수 있다는 장점이 있지만

300
00:14:19,540 --> 00:14:23,160
보안 이슈 취약하고 오하린 보다 편리하지 않기 때문에

301
00:14:23,160 --> 00:14:25,130
해남 기능을 해주는 사람이 있다면

302
00:14:25,130 --> 00:14:28,480
그리고 그리고 커리와 성능차이가 그렇게 나지 않는다면

303
00:14:28,480 --> 00:14:31,360
저는 하렘을 쓰는 것을 추천해드리고 싶습니다

304
00:14:31,360 --> 00:14:35,600
여기서는 와룡과 로컬이란 차이가 얼마나 하지 않았기 때문에

305
00:14:35,600 --> 00:14:39,780
그리고 있었기 때문에 사용했습니다

306
00:14:39,780 --> 00:14:42,240
실제 코드를 잠깐 보시면 예전 8

307
00:14:42,240 --> 00:14:46,600
스테이션 참 수 있었던 갯돌 퀴즈 와 페이스 함수가 사가지고

308
00:14:46,600 --> 00:14:50,530
대신 퀴즈가 들어가는 것을 볼 수 있습니다

309
00:14:50,530 --> 00:14:53,060
그럼 진리 친구 에서는 뭘 하냐

310
00:14:53,060 --> 00:14:55,980
먼저 해당 UI 뒤에 환자들을 모두 지우고

311
00:14:55,980 --> 00:15:00,130
한 번에 벌크 있을 하게 됩니다

312
00:15:00,130 --> 00:15:02,420
자 이젠 잘 되지 않을까 라고 생각을 했었어

313
00:15:02,420 --> 00:15:04,330
나 역시 문제가 있었습니다

314
00:15:04,330 --> 00:15:08,020
예를 들어 병원에서 소형 윤 에 대한 환자정보를 6월 11일

315
00:15:08,020 --> 00:15:11,250
처음 보내 준 뒤 한 달 뒤에 환자가 사망했어요

316
00:15:11,250 --> 00:15:14,620
그래서 정보가 업데이트되어서 다시 들어왔습니다

317
00:15:14,620 --> 00:15:18,020
오른쪽과 같이 정보가 모두 들어오게 된다면

318
00:15:18,020 --> 00:15:21,160
우리가 원하는 것과 같이 dbst

319
00:15:21,160 --> 00:15:24,800
만 잘 업데이트 돼서 들어가게 됩니다

320
00:15:24,800 --> 00:15:27,620
그런데 병원에서 업데이트한 정보를 보낼 때마다

321
00:15:27,620 --> 00:15:32,020
모든 정보를 보내지는 않습니다 이 경우에는 사망시간을 업데이트

322
00:15:32,020 --> 00:15:33,230
하고 싶은 거니까 사망

323
00:15:33,230 --> 00:15:37,400
시각과 이것만 있는지를 내려줍니다 이 경우에 진리치

324
00:15:37,400 --> 00:15:39,460
아니 페이스 하게 되면 어떻게 될까요

325
00:15:39,460 --> 00:15:41,050
기종 정보가 다 삭제되고

326
00:15:41,050 --> 00:15:43,360
마지막에 들어온 정보만 저장되어 으로

327
00:15:43,360 --> 00:15:45,140
데드 ttyd 를 제외한

328
00:15:45,140 --> 00:15:49,700
나머지 값들은 단어를 재벌에게 됩니다

329
00:15:49,700 --> 00:15:53,040
그래서 들리진 크레이지 한 개를 정리하자면

330
00:15:53,040 --> 00:15:55,700
업데이트를 해야 할 오브젝트가 왔을 때

331
00:15:55,700 --> 00:15:57,780
업데이트되는 필드 를 제외하고

332
00:15:57,780 --> 00:16:01,030
나머지 기존에 저장되어 있던 값들이 널로 덮어씌워진

333
00:16:01,030 --> 00:16:02,590
문자

334
00:16:02,590 --> 00:16:06,030
뽀롱 킬레이션 관계도 모두 다 날아가 버립니다

335
00:16:06,030 --> 00:16:08,540
또 틀리지 않고 이제 저는 젤리틀 하고

336
00:16:08,540 --> 00:16:10,190
벌크 퀴즈 하는 것이

337
00:16:10,190 --> 00:16:14,160
각각 개별 쿼리를 수행하는 개별동작 이기 때문에 트랜스액션

338
00:16:14,160 --> 00:16:15,500
토미카 지 않습니다

339
00:16:15,500 --> 00:16:16,870
그래서 데이트를 하고

340
00:16:16,870 --> 00:16:18,250
벌크 에서 하는 동안에

341
00:16:18,250 --> 00:16:23,490
어떤 일이 발생할지 예측할 수 없습니다

342
00:16:23,490 --> 00:16:25,590
그럼 이걸 어떻게 극복할 수 있을까요

343
00:16:25,590 --> 00:16:28,590
방법은 여러 오브젝트에 대해 없는 데이터는

344
00:16:28,590 --> 00:16:30,440
인서트 하고 있는 데이터는

345
00:16:30,440 --> 00:16:33,880
업데이트 싫어서 없을지를 해주는 것입니다

346
00:16:33,880 --> 00:16:38,940
하지만 장 9월 모르는 벌크업 설치를 실행할 수 없었습니다

347
00:16:38,940 --> 00:16:40,490
내장 9월에 없다고요

348
00:16:40,490 --> 00:16:41,960
잘 안 찾아 보신 거 아니에요

349
00:16:41,960 --> 00:16:44,280
그럴 리가 라고 생각하실 수 있습니다

350
00:16:44,280 --> 00:16:45,790
하지만 실제로 그렇습니다

351
00:16:45,790 --> 00:16:49,270
하나의 오브젝트에 대한 업데이트 워크 있었지만

352
00:16:49,270 --> 00:16:50,580
우리가 필요한 것은

353
00:16:50,580 --> 00:16:56,960
여러 오브젝트를 한 번에 업데이트 골프 하는 것이었습니다

354
00:16:56,960 --> 00:16:59,060
또 벌크 업데이트는 있지만

355
00:16:59,060 --> 00:17:00,540
저희는 업데이트할 필드를

356
00:17:00,540 --> 00:17:03,130
선택적 으로 정할 수 있게 해 줘야 하고

357
00:17:03,130 --> 00:17:04,950
특정필드를 모두 다른값으로

358
00:17:04,950 --> 00:17:07,220
세팅 할 수 있는 기능이 필요한데

359
00:17:07,220 --> 00:17:15,210
여기에서 제공된 벌크업 데치는 굉장히 제한된 업데이트만 가능했습니다

360
00:17:15,210 --> 00:17:16,240
다시 정리를 하자면

361
00:17:16,240 --> 00:17:18,820
제가 필요한 기능은 벌크업 셀트 이고

362
00:17:18,820 --> 00:17:20,690
이것은 마이에스큐엘 에서는 온 지

363
00:17:20,690 --> 00:17:25,600
플레이키 업데이트 라고 부릅니다

364
00:17:25,600 --> 00:17:27,730
그래서 여기서 5월에 한계를 느끼고

365
00:17:27,730 --> 00:17:29,410
결국 시도했던 마지막 방법은

366
00:17:29,410 --> 00:17:32,100
로컬을 만드는 것이 었습니다

367
00:17:32,100 --> 00:17:35,150
지금까지 모든 예슬이 환자정보 저장으로 만들었지만

368
00:17:35,150 --> 00:17:38,520
실제 서비스에서는 환자정보 저장 하는 게 아니라

369
00:17:38,520 --> 00:17:39,580
입퇴실 정보

370
00:17:39,580 --> 00:17:42,430
복약정보 등등 다양한 데이터를 찾아갑니다

371
00:17:42,430 --> 00:17:44,990
따라서 이 모든 곳에 사용될 수 있도록 제너럴

372
00:17:44,990 --> 00:17:50,520
하남 승인 XQ 없을 펑션을 만들었고 이 함수는 결국 SK

373
00:17:50,520 --> 00:17:55,730
KT 업데이트 를 실행시켜 줘 84

374
00:17:55,730 --> 00:17:57,480
타이에서 XQ 없을 때

375
00:17:57,480 --> 00:17:59,650
고추가 실제로 이것의 sql 문가

376
00:17:59,650 --> 00:18:02,460
어떻게 맵핑이 되는지를 간단히 보겠습니다

377
00:18:02,460 --> 00:18:05,340
먼저 첫 번째로 들어간 모델클래스 로

378
00:18:05,340 --> 00:18:07,520
테이블 테이블 가져오고

379
00:18:07,520 --> 00:18:09,260
두 번째 인사해 딕셔너리

380
00:18:09,260 --> 00:18:13,310
키 값으로 insert 해야하는 필드 를 가져 온 뒤

381
00:18:13,310 --> 00:18:16,580
두 번째 인사에 밸류에 넣어 준 남자 펑션으로 가고

382
00:18:16,580 --> 00:18:21,380
오브젝트에서 이 필드와 대응되는 뽑아서 넣어 주고

383
00:18:21,380 --> 00:18:23,720
마지막 인자에 업데이트 킷으로

384
00:18:23,720 --> 00:18:28,540
업데이트할 필드를 선택적으로 정할 수 있게 해줍니다

385
00:18:28,540 --> 00:18:31,480
자 그럼 이제 저희가 신청으로 겪으며

386
00:18:31,480 --> 00:18:33,150
구현했던 함수들이 각각 얼마나

387
00:18:33,150 --> 00:18:35,780
퍼포먼스 계산은 이번에는 지를 프로파일링

388
00:18:35,780 --> 00:18:44,220
프린세스를 이용해서 보겠습니다

389
00:18:44,220 --> 00:18:45,690
먼저 개돌 퀴즈 하고

390
00:18:45,690 --> 00:18:51,040
세이브를 했던 기존 구현으로 84 파일을 돌렸을 때

391
00:18:51,040 --> 00:18:54,520
총 1838 밀리세컨드 가 걸린다고 나오네요

392
00:18:54,520 --> 00:18:57,810
오버라고 타임 각 함수에 대한 프로파일링을 테스트하기 위해

393
00:18:57,810 --> 00:18:59,660
100개의 페이션트 오브젝트에 대해

394
00:18:59,660 --> 00:19:02,940
라이브로 폰트 요청을 보내서 나온 결과입니다

395
00:19:02,940 --> 00:19:04,270
앞으로 나올 젤리츄

396
00:19:04,270 --> 00:19:06,020
MK2 벌크 없을지도

397
00:19:06,020 --> 00:19:07,520
동일한 100개 페이션트

398
00:19:07,520 --> 00:19:13,360
ozzfest 요청을 보내서 결과를 냈습니다

399
00:19:13,360 --> 00:19:15,120
좀 더 자세히 살펴 보았습니다

400
00:19:15,120 --> 00:19:18,830
100개 페이션트 에 대해 300개 정도의 거리가 나왔으니

401
00:19:18,830 --> 00:19:20,000
페이션트 에 대해서

402
00:19:20,000 --> 00:19:23,210
약 세 개 커리가 발생했다는 것을 알 수 있습니다

403
00:19:23,210 --> 00:19:26,600
처음 두 개는 갯돌 불리는 셀렉터 셀렉트

404
00:19:26,600 --> 00:19:29,030
혹은 셀렉트 인설트문 였고

405
00:19:29,030 --> 00:19:34,740
마지막은 세이프 웨이 에서 불린 업데이트 문 열었습니다

406
00:19:34,740 --> 00:19:38,180
그 다음으로 블리츠랭크 1% 파이팅 해 봤습니다

407
00:19:38,180 --> 00:19:39,550
코니가 300개 해서

408
00:19:39,550 --> 00:19:41,390
세 개로 주는 것을 볼 수 있었고

409
00:19:41,390 --> 00:19:46,140
overtime 7 대 정도 줄어들었습니다

410
00:19:46,140 --> 00:19:49,640
실행된 크리스를 보면 3시 전이랑 UL 관련 커리

411
00:19:49,640 --> 00:19:52,460
왜는 커리 하나로 모든 동작이 수행

412
00:19:52,460 --> 00:19:56,760
되었다는 것을 볼 수 있습니다

413
00:19:56,760 --> 00:19:58,930
제가 샘플로 좀 잘게 데이터중

414
00:19:58,930 --> 00:20:00,750
이미 존재했던 데이터 없이 때문에

415
00:20:00,750 --> 00:20:02,090
질문을 불리지 않았고

416
00:20:02,090 --> 00:20:06,180
벌크 쿠웨이트 만들려 썼네요

417
00:20:06,180 --> 00:20:07,720
여기서 개돌 quotes

418
00:20:07,720 --> 00:20:10,220
about 블리츠크랭크 비교했을 때

419
00:20:10,220 --> 00:20:12,250
어떤 점이 다르길래 실행 시간이 더 빨라

420
00:20:12,250 --> 00:20:14,880
지는 것인지에 대해서 한번 찍고 넘어가겠습니다

421
00:20:14,880 --> 00:20:16,720
기존의 나 이번 공연은 insert

422
00:20:16,720 --> 00:20:18,870
into 오늘 환자 수만큼 합니다

423
00:20:18,870 --> 00:20:19,800
그애비에 진리

424
00:20:19,800 --> 00:20:24,410
템플릿은 통해서 같은 거를 한 번에 수행합니다

425
00:20:24,410 --> 00:20:26,500
따라서 I5 시간이 단축되었습니다

426
00:20:26,500 --> 00:20:32,190
시간이 짧아서 마지막으로 구현한 덜컥

427
00:20:32,190 --> 00:20:35,180
설치에 대한 프로파일링 입니다 커리 수가 하나이고

428
00:20:35,180 --> 00:20:36,740
overtime 1072

429
00:20:36,740 --> 00:20:40,110
미리 자기한테만 걸렸다고 하네요

430
00:20:40,110 --> 00:20:41,740
그런데 이파리는 셀렉트 만들고

431
00:20:41,740 --> 00:20:43,740
저희가 목걸이 로 구현한 뭔지

432
00:20:43,740 --> 00:20:48,450
플레이키 업데이트 아닌 것을 볼 수 있습니다

433
00:20:48,450 --> 00:20:52,810
그래서 찾아보니까 실제로 실크 해서 커리는 보여 주지 않는다는

434
00:20:52,810 --> 00:20:55,200
2016년에 오픈된 이슈가 있었음

435
00:20:55,200 --> 00:20:56,850
그래서 허리가 잘 들어갔나

436
00:20:56,850 --> 00:20:59,030
만 확인해 보기 위해서 다른 프로파일링

437
00:20:59,030 --> 00:21:02,060
trindade 를 이용해 보았습니다

438
00:21:02,060 --> 00:21:03,280
DJ 들어 봤을 때

439
00:21:03,280 --> 00:21:05,500
intention-TO-treat 업데이트가

440
00:21:05,500 --> 00:21:11,760
잘 들어간 것을 확인할 수 있어 지금까지 긴 여정을 정리해보자면

441
00:21:11,760 --> 00:21:14,830
기존 부연이 너무 느려서 처음에 벌금 시도했으나

442
00:21:14,830 --> 00:21:18,600
실패 하고 질리지 않고 표현했으나 문제가 있었고

443
00:21:18,600 --> 00:21:21,590
구현하려고 시도했으나 원하는 기능이 없어

444
00:21:21,590 --> 00:21:27,160
로컬로 결국 거리를 최적화는 작업을 결론적으로

445
00:21:27,160 --> 00:21:29,710
나이브한 구현에 비해서 엑스큐터 없을지는

446
00:21:29,710 --> 00:21:32,480
25배 이상의 퍼포먼스 계산해 보았습니다

447
00:21:32,480 --> 00:21:33,860
환자의 수가 백 명이 아니라

448
00:21:33,860 --> 00:21:36,860
더 많아지면 퍼포먼스 에게서는 더욱더 되겠죠

449
00:21:36,860 --> 00:21:39,200
결론적으로 맵핑이 지워진다고

450
00:21:39,200 --> 00:21:40,810
나는 기능상의 문제도 없고

451
00:21:40,810 --> 00:21:43,590
속도도 최적화한 우리가 원하는 동작을 해주는

452
00:21:43,590 --> 00:21:45,800
XQ 없을 줄 아는 함수를 만드는데

453
00:21:45,800 --> 00:21:51,070
성공했다는 결론은 결론을 지울 수 있었습니다

454
00:21:51,070 --> 00:21:52,390
자 이제 마지막 주제로

455
00:21:52,390 --> 00:21:54,820
집이 연애 데이터를 머신러닝이 모델로 넣었을 때

456
00:21:54,820 --> 00:22:00,210
시도했던 옵티마이제이션 방법들에 대해서 보겠습니다

457
00:22:00,210 --> 00:22:02,020
집이야 내 데이터를 빠르게 검색해서

458
00:22:02,020 --> 00:22:03,440
ML 모델로 보내는 것과

459
00:22:03,440 --> 00:22:06,470
결과값을 저장 하는 것은 일부분이고

460
00:22:06,470 --> 00:22:07,900
아까 보셨던 것과 같이

461
00:22:07,900 --> 00:22:11,850
저희 서비스에서는 환장 정보를 시간별로 검색해서 가져오고

462
00:22:11,850 --> 00:22:17,010
받은 예측값을 빠르게 저장하는 것이 필수적입니다

463
00:22:17,010 --> 00:22:20,140
빠르게 데이터를 가져올 수 있는 방법으로는 프린터친구

464
00:22:20,140 --> 00:22:21,460
인덱싱 있고

465
00:22:21,460 --> 00:22:24,270
빠른 받은 데이터를 빠르게 저장하는 방법으로는

466
00:22:24,270 --> 00:22:26,820
매칭이 있습니다

467
00:22:26,820 --> 00:22:29,520
먼저 3년째 릴레이 티드 와플팬 리처드는 1

468
00:22:29,520 --> 00:22:33,700
에코리즈 가져올 때 릴레이 티드 오브젝트 때까지 모두 불러왔습니다

469
00:22:33,700 --> 00:22:34,620
따라서 앞서 잔고

470
00:22:34,620 --> 00:22:38,710
5월의 점에 대해 말씀드렸던 레이지 3층에 의한 앤플러스원

471
00:22:38,710 --> 00:22:41,640
problem 해결해 줘

472
00:22:41,640 --> 00:22:43,820
셀렉트 블레이즈는 sql

473
00:22:43,820 --> 00:22:46,430
조인 을 사용 해서 거리 한 번만 해

474
00:22:46,430 --> 00:22:48,000
릴레이 티드 오브젝트를 100층

475
00:22:48,000 --> 00:22:49,620
해 놓는 게 가능합니다

476
00:22:49,620 --> 00:22:54,940
대신 릴레이션십 에서만 사용이 가능합니다

477
00:22:54,940 --> 00:22:56,760
prestolite 듣는

478
00:22:56,760 --> 00:22:59,190
모든 릴레이션십 에서 사용 가능하지만

479
00:22:59,190 --> 00:23:00,970
콜이 2번이 필요합니다

480
00:23:00,970 --> 00:23:04,670
환자와 로케이션이 연관되어 있다고 할 때

481
00:23:04,670 --> 00:23:06,330
프리패스를 데이트를 하게 되면

482
00:23:06,330 --> 00:23:09,420
첫 번째 판사 테이블을 셀렉트 하고

483
00:23:09,420 --> 00:23:13,110
두 번째 거 과정은 환자들과 연관이 있는 로케이션

484
00:23:13,110 --> 00:23:17,160
테이블을 베팅 합니다

485
00:23:17,160 --> 00:23:20,130
실제 저희 서비스에서 사용 한살이를 보겠습니다

486
00:23:20,130 --> 00:23:22,950
저희는 evaporation 를 통해서

487
00:23:22,950 --> 00:23:25,190
환자의 데이터를 1시간 간격으로 에브리

488
00:23:25,190 --> 00:23:28,190
씽 한 다음 모델 서버에 값을 보냅니다

489
00:23:28,190 --> 00:23:31,610
페이션트 와 옥션에서는 서로 릴레이 티드 오브젝트로

490
00:23:31,610 --> 00:23:33,210
연관이 되어 있습니다

491
00:23:33,210 --> 00:23:34,650
1시간 간격 앱솔루션

492
00:23:34,650 --> 00:23:35,710
스 를 가져오기 위해

493
00:23:35,710 --> 00:23:39,460
먼저 여기 위에 있는 페이션트 operation 필터

494
00:23:39,460 --> 00:23:43,800
해당 쿼리를 가져오게 됩니다

495
00:23:43,800 --> 00:23:45,930
하지만 이 위에 해당 타임 왜인지

496
00:23:45,930 --> 00:23:48,100
observational fifa

497
00:23:48,100 --> 00:23:51,550
듣는 코드를 추가해 주면 어떻게 될까요

498
00:23:51,550 --> 00:23:54,130
이것을 추가한다면 전에 페이션트 love

499
00:23:54,130 --> 00:23:58,690
IS 로 가져왔던 코드는 삭제할 수 있었습니다

500
00:23:58,690 --> 00:24:01,760
대신 대답을 좀 전에 파라미터로 저도 없어요

501
00:24:01,760 --> 00:24:05,980
비전을 가져오기 위해 flat 듯이 사용한 TO put

502
00:24:05,980 --> 00:24:06,390
이름

503
00:24:06,390 --> 00:24:10,400
즉 페이션트 렌즈를 사용하시면 됩니다

504
00:24:10,400 --> 00:24:12,020
이렇게 함으로써 우리는

505
00:24:12,020 --> 00:24:16,290
집이 접근을 최소화 할 수 있습니다

506
00:24:16,290 --> 00:24:19,100
그다음 방법으로는 인덱싱 있습니다

507
00:24:19,100 --> 00:24:22,320
해당 컬럼에 인덱싱을 하면 해당컬럼 갈까

508
00:24:22,320 --> 00:24:26,060
인덱스가 맵핑을 파일로 따로 저장해 2개 되는데요

509
00:24:26,060 --> 00:24:28,440
이후 해당컬럼 검색했을 때

510
00:24:28,440 --> 00:24:31,760
해당 테이블에 코드를 스캔하면 것이 아니라

511
00:24:31,760 --> 00:24:33,420
그 인덱스 파일로 검색하여

512
00:24:33,420 --> 00:24:37,310
검색 속도를 빠르게 하게 됩니다

513
00:24:37,310 --> 00:24:38,690
예를 들어 이번 일이

514
00:24:38,690 --> 00:24:40,890
이번 일에 대해서 인덱싱을 해놓았고

515
00:24:40,890 --> 00:24:45,470
이번일에 2018년 7월 26일 인화 나를 찾을 때

516
00:24:45,470 --> 00:24:49,330
해당테이블 모드스캔 한다면 오후에는 시간이 걸리겠지만

517
00:24:49,330 --> 00:24:50,490
테이블로 찾기 때문에

518
00:24:50,490 --> 00:24:53,340
5월 로그 1시간 만에 해상도를 찾을 수 있습니다

519
00:24:53,340 --> 00:24:56,480
인덱싱 테이블은 트리형태로 값을 저장해놓기 때문에

520
00:24:56,480 --> 00:24:59,860
5월 로그인이 걸림

521
00:24:59,860 --> 00:25:02,760
하지만 인덱싱을 성으로 걸고 성이 김인환

522
00:25:02,760 --> 00:25:05,310
저를 찾을 때 해당 안으로 가 여러 개 있기 때문에

523
00:25:05,310 --> 00:25:07,680
스캔 속도가 크게 향상되지 않습니다

524
00:25:07,680 --> 00:25:11,920
여러로우 중에서 다시 찾아야 할 테니까요

525
00:25:11,920 --> 00:25:15,460
정리하자면 인덱싱은 조인 등을 사용해 자주 검색

526
00:25:15,460 --> 00:25:17,730
되어지는 컬럼에 걸어주면 좋지만

527
00:25:17,730 --> 00:25:19,760
데이터 모디피케이션 이 많이 일어나는

528
00:25:19,760 --> 00:25:22,420
컬럼에서는 변경이 일어날 때마다 인덱싱

529
00:25:22,420 --> 00:25:24,780
테이블도 같이 변경해줘야 함으로

530
00:25:24,780 --> 00:25:27,500
오히려 속도 저하를 유발할 수 있기 때문에

531
00:25:27,500 --> 00:25:30,620
무조건 해 주는 것이 좋은 것만은 아닙니다

532
00:25:30,620 --> 00:25:32,420
또 데이터가 많이 중복되는

533
00:25:32,420 --> 00:25:36,350
컬럼에는 크게 효과가 없습니다

534
00:25:36,350 --> 00:25:39,220
그럼 내 저희가 ML 모델의 보내 주기 위해

535
00:25:39,220 --> 00:25:42,080
패칭 해야하는 데이터는 시계열 데이터 입니다

536
00:25:42,080 --> 00:25:44,160
가장 최근 일 내 정보를 가져와서

537
00:25:44,160 --> 00:25:46,160
에브리싱 하는시기 니까요

538
00:25:46,160 --> 00:25:48,660
그래서 시간 기준으로 자주 검색 되어지고

539
00:25:48,660 --> 00:25:51,620
시간 데이터는 많이 중복되는 데이터도 아닙니다

540
00:25:51,620 --> 00:25:52,950
따라서 시간 필드에

541
00:25:52,950 --> 00:25:57,790
인덱싱을 하기가 매우 적절한 인덱싱은

542
00:25:57,790 --> 00:25:59,540
실제 코드에서 어떻게 하면 될까요

543
00:25:59,540 --> 00:26:01,800
인덱스를 걸고 싶은 컬럼에 집인데

544
00:26:01,800 --> 00:26:06,080
기는데 옵션을 주면 됩니다

545
00:26:06,080 --> 00:26:08,400
또 아까 데이터가 중복되는 컬럼에서는

546
00:26:08,400 --> 00:26:11,960
인덱싱이 큰 효과가 없다고 말씀드렸었는데

547
00:26:11,960 --> 00:26:13,040
이런 식으로 여러 개의

548
00:26:13,040 --> 00:26:15,140
컬럼을 한 번에 인덱싱할 수도 있습니다

549
00:26:15,140 --> 00:26:18,590
전혜성 만으로 검색할 때는 큰 효용성 없었던 인덱스

550
00:26:18,590 --> 00:26:20,740
테이블이 이름과 함께 있으니

551
00:26:20,740 --> 00:26:22,480
데이터의 중복성이 크게 떨어져

552
00:26:22,480 --> 00:26:26,750
형성이 높아진 것을 보실 수 있습니다

553
00:26:26,750 --> 00:26:33,930
이것은 모델 클래스 메타에 인덱스 투게더로 선물 주시면 됩니다

554
00:26:33,930 --> 00:26:36,050
마지막으로 베팅에 대해서 보겠습니다

555
00:26:36,050 --> 00:26:39,460
매칭은 ML 모델에서 보내주는 예측값을 저장할 때

556
00:26:39,460 --> 00:26:40,860
사용할 수 있는데요

557
00:26:40,860 --> 00:26:43,130
맵은 100개 이상의 결과를 받는 경우에

558
00:26:43,130 --> 00:26:46,810
요청 200개 쌓였을 때 한 번에 방식입니다

559
00:26:46,810 --> 00:26:49,850
100층에 장점으로는 개별적으로 하나씩 받아서

560
00:26:49,850 --> 00:26:52,800
세이브 할 때보다 한꺼번에 씹을 할 수 있게 되어

561
00:26:52,800 --> 00:26:57,420
아이오 시간을 효율적으로 줄일 수 있습니다

562
00:26:57,420 --> 00:27:00,680
지금까지 제가 어떻게 어떤 방법으로 서비스의 장고

563
00:27:00,680 --> 00:27:03,640
쿼리를 옵티마이저 옵티마이제이션 을 시켰는지

564
00:27:03,640 --> 00:27:06,090
보았습니다

565
00:27:06,090 --> 00:27:08,210
먼저 처음에 회사에서 개발 중인 잔고

566
00:27:08,210 --> 00:27:09,930
서비스에 대한 간략한 소개

567
00:27:09,930 --> 00:27:13,380
와 데이터 처리가 느린 부분에 대해서 설명

568
00:27:13,380 --> 00:27:17,000
평생을 최적화하기 위해 필요한 선수 지식을 위에 orm

569
00:27:17,000 --> 00:27:20,620
개념설명과 california 소개해드렸습니다

570
00:27:20,620 --> 00:27:23,720
이후 실제 사례 에서 허리 옵티마이제이션 을 1

571
00:27:23,720 --> 00:27:25,560
테크닉을 소개시켜 드렸는데

572
00:27:25,560 --> 00:27:27,410
첫 번째는 대용량에 업데이트

573
00:27:27,410 --> 00:27:28,530
또는 생성 해 줘야 하는데

574
00:27:28,530 --> 00:27:30,700
이터가 들어오는 상황이었고

575
00:27:30,700 --> 00:27:34,130
두 번째는 시간 기준으로 빠르게 릴레이 티드 오브젝트를 배팅

576
00:27:34,130 --> 00:27:35,950
해 줘야 하는 상황이었습니다

577
00:27:35,950 --> 00:27:39,480
첫 번째 같은 경우는 결국 원하는 것을 해 주는 사람이 없어

578
00:27:39,480 --> 00:27:43,600
로컬을 두 번째 같은 경우에는 matthew

579
00:27:43,600 --> 00:27:46,890
인덱싱을 이용해 성능을 개선시켰습니다

580
00:27:46,890 --> 00:27:52,840
추가적으로 받은 예측값을 빠르게 저장하기 위해 대칭도 소개시켜드렸습니다

581
00:27:52,840 --> 00:27:54,970
제가 한 부분은 제너럴 한 부분보다는

582
00:27:54,970 --> 00:27:57,980
측정 케이스에 집중되어 있는 부분이 많지만

583
00:27:57,980 --> 00:28:01,610
그래도 이 발표를 통해서 개발자분들이 비슷하게 고민하는 문제들에

584
00:28:01,610 --> 00:28:04,500
점 안에 해결 방안을 공유해 드리고 싶었습니다

585
00:28:04,500 --> 00:28:07,240
그래서 여러분들이 자신의 상황에 맞는 장고의 기능이

586
00:28:07,240 --> 00:28:08,220
어떤 것인지 알고

587
00:28:08,220 --> 00:28:11,410
더 유용하게 잔고를 보면 좋겠습니다

588
00:28:11,410 --> 00:28:13,440
감사합니다 이 자리를 빌려서

589
00:28:13,440 --> 00:28:15,540
지난 7개월에 인턴기간동안

590
00:28:15,540 --> 00:28:17,660
제가 이 모든 걸 할 수 있게 끌어 주시고

591
00:28:17,660 --> 00:28:18,690
도와주었던 개발팀

592
00:28:18,690 --> 00:28:21,490
특히 저를 많이 도와주신 안재만 개발

593
00:28:21,490 --> 00:28:24,510
팀장님께 감사하다는 말씀을 드리고 싶습니다

594
00:28:24,510 --> 00:28:26,880
않지만 팀장님께서는 바로 전에 어드밴스

595
00:28:26,880 --> 00:28:30,530
파이썬 캐스팅 체크해 대해서 굉장히 유익한 발표를 해주셨는데요

596
00:28:30,530 --> 00:28:32,380
관심있으시다면 나중에 발표

597
00:28:32,380 --> 00:28:35,520
들어가셔서 영상을 보시면 좋을 것 같습니다

598
00:28:35,520 --> 00:28:37,350
저희 회사에서 이번에 많이 발표를 하는데요

599
00:28:37,350 --> 00:28:40,940
다음 발표는 다음 타임에 피크닉 알려주시면 와있습니다

600
00:28:40,940 --> 00:28:42,220
분명히 재미있을 테니까

601
00:28:42,220 --> 00:28:44,930
많은 관심 부탁드립니다 감사합니다
