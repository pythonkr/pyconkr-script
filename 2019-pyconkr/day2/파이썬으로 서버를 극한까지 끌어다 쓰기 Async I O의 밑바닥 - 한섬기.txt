https://youtu.be/zAvWv_Wi0z0

-(사회자) : 자리에 모두 앉아주시면 감사하겠습니다.
시작하겠습니다.
안녕하세요.
이번 시간에는 한섬기 님께서 파이썬으로 서버를 극한까지 끌어다 쓰기,
AsyncIO의 밑바닥이라는 주제로 발표하시겠습니다. 원활한 발표를 위해 질문은
시간이 끝나고 난 뒤에 받도록 하겠습니다.
-(한섬기) : 안녕하세요.
방금 소개 받은 한섬기라고 합니다.
제가 제 소개하는 장표를 만드는 걸 깜빡해서요.
제 이름을 소개를 못 했어요.
제 이름을 다시 말씀을 드리면 한섬기라고 하고요.
저는 피플 펀드라는 회사에서 피투비 금융 서비스를 만드는 작업을 하고 있어요.
발표는 바로 시작하고 마지막에 조금 더 회사에 대해서 간략하게만 말씀을 드리
도록 하겠습니다.
지금 제가 준비한 건 파이썬으로 서버를 극한까지 끌어다 쓰기, AsyncIO의 밑바
닥을 주제로 했는데 부족한 부분이 있을 것 같아요. 생각보다 아쉬운 부분이 있
더라고요, 알아보니까. 그래서 양해의 말씀을 부탁드리겠습니다.
먼저 이 용어를 설명을 드리고 넘어갈게요. sync, Async, 블로킹, 논블록킹이 등
장하는데 이게 어떤 의미를 뜻하는지 확실하게 짚고 넘어가면 좋을 것 같아서요.
제가 이해하는 바에 대해서 설명을 드리도록 하겠습니다.
비동기 방식이랑, 동기 방식이라는 프로그램이 있는데 간략하게만 말씀을 드리
면 프로그램의 주실행 프로그램을 멈추지 않고 진행할 수 있는가가, Async냐
Asynchronous라고 할 수 있는데요.
별도의 채널에 맡겨둔 뒤에 결과를 기다리지 않고 바로 다음 코드를 실행하는 방
식으로 프로그램을 개발하게 된다면 이거는 Asynchronous 프로그램이라고 부를
수 있는데 여기서 쓰이는 기법들이 파이썬에서는 코르틴 같은 것들이 쓰이게 되
죠.
Asynchronous라고 하면 반대로 코드의 실행결과들이 즉시 실행이 되면서 다른
작업들을 할 수 없는 방식이 Asynchronous 프로그램일 거고요. 많이 헷갈릴 수
있는 게 Asynchronous랑 논블록킹이라고 하면 헷갈릴 수 있는데 논블록킹이 어
떤 차이가 있는지 짚고 넘어갈게요.
논블록킹 IO라고 하면 시작만 해두고서 다음 작업을 바로 진행할 것이냐, 이 여
부에 따라서 블록킹이냐 논블록킹이냐가 IO 방식에 따라서 결정이 됩니다. 만약
에 후속 작업이 있을 수도 있는데 이런 경우에는 폴링을 하거나 콜백 같은 함수
를 넘겨줘서 처리하는 방식을 보통 사용해요.
사실 제가 지금 설명하는 게 굉장히 비슷해서 개념상 헷갈릴 수 있어서 비동기랑
논블록킹이랑 어떤 차이가 있는지 질문을 한다고 하면요. 만약에 블록킹 IO를 사
용했어요. 그럼에도 불구하고 만약에 별도의 채널을 통해서, 아까 설명을 드린
것처럼 별도의 채널을 통해서 작업해서 어떤 프로그램의 주 실행 흐름을 막지 않
았다고 하면 Asynchronous 프로그래밍으로 개발했다고 할 수 있어요. 논블록킹

이라고 하면 IO에 대한 이야기를 하는 게 되고 Async라고 하면 프로그램의 방식
인데 프로그램 자체가 멈추지 않고 돌아갈 수 있느냐를 비동기 방식으로 프로그
래밍을 했다고 말씀을 드릴 수 있을 것 같아요.
그러면 비동기 방식의 프로그래밍을 활용하는 프레임워크가 어떤 거가 있는지
짚고 넘어갈게요.
제가 Asynchronous 프로그래밍 하고서 파이썬이라고 검색을 하니까 엄청나게
많은 게 나왔는데 저도 깜짝 놀랐는데 기타부터 말씀을 드리면 제가 여기에 정리
해놓은 순서는 깁허브에서 얼마나 좋아요를 받았는지로 정리를 했는데 코트라는
프레임워크가 있더라고요. 스타를 568개를 받은 걸로 나와 있는데 깃랩에서 좋
아요를 받으면 이러한 형식의 유아이로 표현이 됩니다.
실제로 프로덕션에서 사용할 수 없는 프레임워크이겠죠.
밑에는 Growler라는 것도 있는데 스타를 686을 받았는데 3년 전에 마지막 커밋
이 있더라고요. 설명으로는 마이크로 웹 프레임워크라고 하고 Async IO를 사용
한다고 돼 있는데 개발이 멈춰있고 스터디 형식으로 개발하다가 중단된 게 아닌
가 싶어요. FastAPI가 있는데 스타를 3700개 정도 받았는데 이거는 살펴보니까
10일 전에 마지막 커밋이 있었는데 이 친구는 특이한 게 설명을 해놨는데 최신
어Asynchronous 웹 프레임워크는 전부 다 파이썬을 쓰고 있어요. 3.2 기반으로
만들어져 있기 때문에 다들 쓰고 있죠. 그래서 자랑거리를 해놨더라고요.
그리고 나서 다음으로 스타를 많이 받은 게 vibora라는 프레임워크가 있어요.
이거는 스타를 5000개 이상을 받았는데 설명을 보면 Flask랑 유사한 프레임워크
라고 돼 있더라고요. 파이썬에서 웹 개발을 하게 되면 웹서버를 개발하게 되면
보통 일반적으로 선택하는 게 Django 아니면 Flask 둘 중에 하나인데 대부분의
지원이 되는 편안하게 Django를 선택하거나 Flask를 선택하는 선택지가 몇 년
전까지만 있어도 했었는데 Flask가 가볍고 빠르게 만들을 수 있어서 그 방식을
활용하는 Asynchronous 웹 프레임워크가 있더라고요.
첫 번째로 vibora라는 웹 사이트에 들어가 보면 첫 번째로 나오는 게 가장 빠른
파이썬 서버를 만드는 게 목표라고 나와 있고 기본적으로는 코어를 있는 대로 활
용하는 게 기본적인 전략이고 가능한 경우에는 uvloop이 있고 더 빠른 방식으로
사용한다고 소개되어 있어요.
제가 궁금했던 게 uvloop가 뭐길래 빠르다고 하는지 궁금해서 이번 발표를 시작
하게 됐고요.
좀 더 넘어가보면 aiohttp라고 있는데 이 친구는 깃헙에서 스타를 8000개 이상을
받았는데 Async IO를 사용하는 비동기 HTTP 클라이어면서 동시에 서버도 다룰
수 있는 그런 프레임워크라고 소개하고 있어요.
웹소켓도 지원하고 웹서버에서는 미들웨어와 시그널을 제공한다고 소개되어 있
는데 알고 보니까 엄청 대단한 일은 아니고 보통 웹서버 개발을 하게 되면 실제
로 리퀘스트를 처리하는 과정 전과 후에서 리퀘스트 핸들러로 작업하게 되는데
시그널이라는 제공을 특이하게 하는데 만약에 HTTP 하드웨어를 수정하거나 할
때는 내가 작성하는 과정 중에서는 수정을 직접 할 수 없고 뒤에 맡겨놔야 되더
라고요, 프레임워크에. 그래서 그거를 시그널로 제공을 하고 있더라고요.
그러고 나면 작년, 재작년부터 파이콘에서 소개가 되었는데 sanic이 있어요. 이
것부터는 스타가 12000개가 되었는데 이 친구의 특징으로는 높은 성능의 HTTP
서버를 구축하고 동시에 확장성이 유리하게 되어 있는 그런 프레임워크를 만드
는 게 목표입니다. vibora보다는 조금 더 명확한데 블loop린트라고 이름을 붙여
놨는데 결국 서브라우팅을 한다고 특징으로 돼 있더라고요.
서브라우팅을 하시면 여타 프로그램에서는 지원을 하고 있죠, 장고도 그렇고.

라우팅을 할 때 이거를 분리해서 관리할 수 있냐의 여부로 보시면 쉬울 것 같아
요. 여기서도 똑같은 게 나오더라고요. uvloop을 사용해서 비동기로 HTTP를 빠
르게 처리할 수 있다고 하더라고요. sanic에서도 쓰고 아까 vibora에서도 쓰고 있
는데 도대체 uvloop이 뭔지 조금만 더 설명을 드리도록 하겠습니다.
마지막으로 토네이도라는 프레임워크가 있어요. 이 친구는 스타를 18000개를 받
았는데 실제로 이렇게 검색을 하시면 가장 많은 검색 결과가 나오는 그런 프레임
워크예요.
그런데 토네이도는 현재는 잘 사용은 안 되고 있죠. 토네이도가 사용됐던 게 파
이썬 2점대에서 비동기로 개발하려면 선택지가 토네이도가 밖에 없었어요. 그래
서 그 당시에는 토네이도가 많이 쓰였는데 최근에는 많은 부가기능을 제공하는
거로 가면 Asynchronous하게 Django로 가거나 빠르게 가고 싶으면 방금 말씀을
드렸던 sanic이라는 프레임워크를 주로 사용하고 있죠.
토네이도는 똑같이 클라이언트랑 서버 둘 다 제공을 하고, 윗줄에 있는 것처럼
웹 프레임워크인데 동시에 비동기 라이브러리 네트워크라고 있어요. 파이썬의
최신 버전에는 Async나 이런 거를 제공하는데 그전에는 그런 게 없으니까 직접
구현한 게 많은데 비동기 라이브러리 네트워크라고 소개하고 있어요.
토네이도 젠이라는 거랑 파이썬에서 예전부터 제공해 주고 있던 일드라는 법을
활용해서 비동기를 직접 구현을 한 프레임워크라고 보시면 됩니다.
제가 계속 몇 번 언급을 해드렸던 uvloop이라는 친구가 있더라고요. 그 친구랑 파
이썬에서 이야기하는 Async IO를 설명 드릴게요. Async IO는 다른 컨퍼런스에
서도 소개가 되어서 간략하게 특징만 설명을 드릴게요. 3.6에서 등장을 했는데
이것을 사용해서 동시성 코드를 작성할 수 있는 그런 라이브러리입니다. Async
IO는 동시에 실행하거나 제어할 수 있는 거를 제공하기도 하고 동시성 코드를 동
기화하는 이런 작업들을 해 주고요.
저수준 API를 제공해 주는데 네트워크나 직접 실행할 거냐, OS에서 실행을 받았
을 때 하는 것을 핸들링을 받아서 하고 있어요. 이 부분에 관심을 두었는데 비동
기 API를 제공하는 이벤트 loop라는 걸 직접 만들고 관리할 수 있는 거를 제공하
고 있습니다.
Async IO는 사용법을 간단하게 말씀을 드리고 넘어갈게요. 이런 식으로 활용할
수 있어요. Async로 임포트를 하게 되면 어웨이라는 구문을 사용해서 할 수 있
죠. 나중에 처리할 수 있도록 대기를 시켜주는 건데 Async IO에서 함수를 Async
라고 키워드가 달려있는 함수를 실행해 주면 이 친구는 아까 말씀을 드렸던 처음
에 설명 드렸던 개념인 Asynchronous 프로그래밍 방식으로 되기 때문에 런 뒤에
만약에 다른 프로그램을 내가 작성을 하더라도 메인이라는 게 실행되지 않았음
에도 불구하고 다음 코드가 실행이 될 수 있어요.
그러면 이제부터는 uvloop에 대한 이야기인데 uvloop이 어떤 거냐면 파이썬에서
Async IO에 보면 이벤트를 루브가 있어요. 이벤트 loop가 결국 Asynchronous 프
로그래밍에서는 핵심적인 역할을 한다고 볼 수 있어요. 이 친구가 아까 방금 보
여드렸던 Async 어웨이트하는 이런 함수들을 뒤에 숨겨놓고 어떻게 이 친구들을
순차적으로, 순차적이 아니라 어떻게 하면 효과적으로 처리할 수 있는지 이거를
담당하는 게 이벤트 loop이거든요.
이벤트 loop를 얼마나 잘 만들어지는지에 따라서 성능이 좌지우지 된다고 볼 수
있더라고요.
uvloop는 싸이선으로 구현이 되었는데 이 친구는 libuv를 기반으로 한다고 설명
이 돼 있더라고요.
libuv에 대해서도 알아봤는데 libuv는 파이썬이 아니고 싸이선도 아니고 시로 작

성돼 있는 모듈입니다.
uvloop의 사용법은 간단한데 Async IO에 보면 비동기로 처리할 수 있는 것들이
있어요. 비동기로 처리할 수 있는 다른 API는 사용하면서 uvloop는 이벤트 loop
라는 것만 대체를 하게 되는 겁니다. Async IO에서 셋 이벤트 loop 폴리시를 할
때 설정을 해 주시면 그 다음부터는 Async IO가 동작을 할 때 uvloop이 제공하는
이벤트 loop를 사용하게 돼요.
uvloop가 뭐냐면 이름의 유래를 찾기 어려웠는데 결국 뜻하는 게 유니콘 밸런시
레이터이더라고요.
이 uvloop가 어떤 거냐면 크로스 플랫폼을 제공하는 라이브러리인데요. 노드 제
이에스를 위해 만들어진 건데 노드 제이에스가 모든 처리를 다 하게 되죠. 그 노
드 제이에스가 돌아가는 근본적인 걸 구현하기 위해서 작성이 된 건데 만들어진
이유가 노드 제이에스를 다른 플랫폼에서, OS에서 윈도우즈나 맥이 될 수도 있
고 한데 여기서 실행을 하기 위해서 각자가 개발된 방식들이 다 달랐죠.
비동기로 IO를 처리할 수 있는 방식들이 각자 OS마다 다른데 각각 흩어져있는
것들을 한번 추상화를 해서 간단한 방법으로 쓸 수 있도록 만들어놓은 게 립 uv
라는 프레임워크예요.
이 친구는 이벤트 드리븐 비동기 IO로 만들어졌고 밑에 있는 것들로 추상화를 해
놨습니다.
케이큐라고 하면 많이 쓰고 계실 비에스디 계열에서 활용을 하는 비동기 방식 IO
처리 API고요.
이폴은 리눅스고 IO 씨피는 윈도우즈에서 사용하는 비동기 모델 IO입니다.
libuv는 방금 설명을 드렸던 이폴이나 그런 것들이 좌측 하단에 보면 나와 있죠.
이거를 랩핑을 해서 동일한 API로 사용할 수 있게 돼 있고요.
방금 설명 드리지 않았던 이벤트 포츠 같은 경우에는 요즘에는 거의 쓸 일은 없
는 것 같은데 솔라리스라고 하는 OS에서 사용하고 있는 비동기 IO 모듈을 말합
니다.
오른쪽에 보면 디엔에스 관련된 작업들, 유저 코드 이런 것들은 여기서 동작을
해요.
좌측에 있는 네트워크 IO 같은 것들은 이폴이나 이런 것을 활용하는 거고 파일
IO 같은 경우에는 아직까지는 뭔가 확실하게 만들어져 있는 그런 라이브러리나
이런 게 제공이 되는 게 없어서 동기 방식으로 동작을 해요.
스레드풀에서 파일 핸들링하는 게 있으면 스레드풀에 넣고 거기서 작업이 완료
가 되면 다시 가져와서 작업을 하는 그런 방식으로 구현이 돼 있더라고요.
IO loop가 어떤 거냐면 각각 다른 스레드에서 실행되는 여러 가지의 이벤트들을
이벤트 loop에서 실행되도록 해 주는 거고요. uvloop의 이벤트 loop는 이 부분이
중요한데 다 스레드 세이프하지 않기 때문에 내가 프로그래밍을 작성할 때 그거
를 이해하고 작성하셔야 성능에서도 이득을 볼 수 있으면서 동시에 안전한 프로
그램을 만들 수 있어요.
그리고 모든 IO는 OS에 맞도록 수행이 됩니다.
이게 loop가 어떻게 돌아가는지에 대한 원리인데 이 원리에 대해서 간략하게 설
명을 드릴게요.
처음에 libuv에서는 어떻게 시작 하냐면 제가 살펴보니까 여기서 오티마이제이션
이 많이 돼 있어요. 최대한 빠르게 만들기 위한 그런 처리들이 많이 돼 있고요. 그
중에 하나가 시작부터 돼 있더라고요.
숫자 자체를 줄이기 위해서 libuv를 시작할 때 시스템에다가 시간을 물어보지 않
고 직접 프로그램 내에서 시간을 물어보기 위해서 매번 loop를 돌 때마다 현재 시

간을 기록해놓고 그거를 활용하게 됩니다.
그러고 나서 loop가 살아있는지를 살펴봐요.
만약에 이벤트 loop가 활성화가 돼 있다고 하면 반복을 시작하게 되는 거고 그렇
지 않으면 종료가 되는 건데 사실상 웹서버를 제작한다고 하시면 항상 살아있는
상태겠죠. 죽지 않고 살아있는 상태일 텐데 만약에 그냥 일반적인 피씨에서 사용
하는 애플리케이션이나 이런 데에서는 한번만 사용하고 종료될 수 있기 때문에
확인하는 작업이 한번 있고요. 핸들은 그냥 어떤 작업 단위로만 이해하시면 될
것 같아요.
어떤 작업이 활성화가 돼 있거나 아니면 어딘가에 참조가 돼 있거나 닫히지 않았
거나 하는 상황이면 모든 게 활성화가 돼 있는 상황이라고 판단하고 이벤트 loop
가 계속 돌아가게 됩니다.
이벤트 loop가 살아있는지 확인하고 나면 마감 타이머라는 게 동작해요. 마감 타
이머가 이벤트 loop를 돌 때 안에 들어가 있는 작업들을 종료를 할 것이냐, 말 것
이냐를 판단하는 타이머고요.
이 타이머를 시작을 시켜놓고 나면 그 다음부터 대기 중이었던 콜백을 호출하게
돼요. 대기 중이었던 콜백이 어떤 의미냐면 보통은 콜백 펑션이라고 하면 펑션을
실행할 때 거기에 펑션 개체를 하나 넘겨주고 그게 작업이 완료되면 콜백, 함수
를 호출하게 되는 개념으로 활용하는데 비동기 라이브러리들에서는 그런 방식으
로 사용하지는 않고 모든 콜백들을 직접 관리를 하게 돼요. 그래서 콜백이 그 이
전 함수가 종료되었다고 하더라도 콜백이 바로 실행되는 게 아니라 그 콜백을 언
제 실행할지를 이벤트 loop 안에서 결정하게 돼요. 이것 때문에 성능이 빨라지고
효율적으로 실행하게 되는 거죠.
여기서 만약에 한번 이번 화차에서 콜백을 호출할 타이밍이 안 되면 다시 이 친
구는 이벤트 loop 안으로 들어가게 되고 다음 loop에서 확인을 다시 한 번 할 수
있도록 지연을 시키기도 해요.
그리고 아이들 핸들이 있는지 그거를 확인하는 콜백이 또 호출이 됩니다. 이름은
아이들 핸들인데 매번 돌 때마다 항상 체크를 하게 돼요.
프리페얼 핸들이라고 부르는 것이 호출이 됩니다.
이 친구는 어떤 친구냐면 loop가 IO를 차단하는 작업을 하거든요. IO를 직접 다
루지 않도록, 건들지 않도록 차단하는 작업을 하게 되는데 그 작업을 하기 직전
에 준비 핸들이 자기가 실행해야 됐던 콜백을 호출하게 되는 그런 개념입니다.
그러고 나면 IO를 차단을 하기 전에 loop가 얼마나 오랫동안을 차단할 건지 여기
서 계산해요. 이게 성능을 좌지우지하는 핵심일 것 같고요. 어떤 거냐면 콜백 함
수를 등록을 해놓고 비동기 IO를 다른 스레드에 할당을 해놓을 텐데 그 친구를
언제 다시 한 번 확인할 건지를 계산하는 거예요. 그 시간 동안 그 시간이 완료되
기 전까지는 확인을 하지 않는 거죠. 그 시간을 정밀하게 확보함으로써 하는 방
식을 쓰고 있습니다.
loop가 IO를 차단하게 되면 그다음에 체크 핸들이라는 게 호출이 되는데 이 콜백
을 호출해야 되냐 안 되냐를 판단하는 로직이라고 보시면 됩니다.
마지막으로는 유브이 클로즈라는 함수가 있는데 이거를 호출해서 핸들을 닫게
되면 닫기콜백, 이번 이터레이션을 종료하는 콜백을 호출하게 됩니다.
이걸로 이벤트 loop가 한 바퀴를 순회를 하게 되는 건데 방금 설명 드린 과정을
통해서 이벤트 loop가 계속 반복해서 호출하게 돼요.
이런 방식을 통해서 이벤트 loop가 구현이 되어 있고요. 이거는 libuv라는 라이브
러리에서 구현을 한 방식이고 파이썬에서도 구현된 이벤트 loop도 방식 자체는
이거랑 유사한 방식으로 구현이 돼 있더라고요.

이벤트 loop가 이런 역할을 한다는 거를 알았으니까 이제는 싱크랑 어
Asynchronous 프레임워크가 어느 정도의 성능 차이가 있는지 궁금했어요.
uvloop이라는 친구가 Async IO에서 이벤트 loop를 대체하는데 이벤트 loop만 대
체하는 거지 파이썬에서 구현돼 있는 API를 기본적으로 활용하게 돼요. 유일하
게 이벤트 loop만 대체해서 활용하게 되고요. 그러면 도대체 어떤 것 때문에 이것
만 대체를 하게 됐는지 그 성능 비교를 통해서 알아보도록 할게요.
성능 비교를 할 때 활용했던 프레임워크는 Django랑 Flask, 동기 방식이죠. 동기
방식과 어떤 차이가 있는지 보려고 하고요. sanic, vibora 등을 확인해보겠습니
다.
오롯이 이 작업에만 서버 자원이 활용될 수 있도록 준비했어요. 투엑스 라지라고
하면 씨투를 이 정도 하고요. 깃헙 링크가 있는데 vibora라는 친구가 제가 처음에
소개를 드렸던 프레임워크 중에 하나인데 여기서 테스트를 할 수 있는 사전 준비
를 많이 해놨더라고요.
이거를 갖고 테스트를 해봤고요.
각 프레임워크의 버전들은 피아이피 인스톨 하면서 버전을 지정하지 않고 인스
톨을 하면 설치가 되는 최신 버전의 안정화 버전의 웹 프레임워크를 사용했습니
다.
폼 파싱이라는 거랑 레지스를 활용을 하는 두 가지 정도를 테스트해봤는데 간단
하게 제작했어요. 제가 제작한 건 아니고 vibora에서 미리 이 코드들을 해놨고요.
멀티파크 폼으로 파일을 전송하고 파라미터를 전송한다는 가정 하에 API를 실행
하게 되고요.
코드에서 보이시는 것처럼 리퀘스트에서 파일이 몇 개가 있는지만 간단하게 해
서 바로 response를 주는 그런 것입니다.
이걸로 테스트를 해보니까 이런 결과가 나오더라고요. Flask가 라이트한 프레임
워크이어서 그런지 Django에 비해서 두 배의 성능이 나오고요.
굉장히 신기한데 파일을 핸들링할 때 제가 생각했을 때는 아무리 봐도 이거는 버
그가 아니인가 하는 생각이 듭니다. sanic이 빠르다고 소개가 되고 있는데 초당 4
만 7000건 정도 하는데 vibora가 빠르다고 소개하고 있는데 80000건 정도 처리
하는 두 배 가까운 성능을 하고 있는데 vibora는 한참 개발 중이어서 웹 프레임워
크에서 필요한 여타 기능들을 제공하게 되면 좀 더 느려지지 않을까 생각이 됩니
다.
레디스 API를 활용하는 것도 봤는데 간단하게 리퀘스트를 받아서 리턴하는 간단
한 시나리오고요.
아까 여기서 봤던 성능이 올라왔어요. 훨씬 더 빠른 성능을 보여주고요. 여기서
도 vibora가 많은 리퀘스트들을 처리할 수 있더라고요.
그러면 여기까지 테스트를 해봤으면 uvloop랑 uvloop에서 구현해놓은 이벤트
loop가 뭐 때문에 Async보다 빠른지 궁금하실 텐데요.
결론부터 말씀을 드리자면 제가 코드를 엄청나게 확인을 해봤어요. 도무지 차이
를 알 수 없어서, 그런데 차이를 알 수 없는 이유를 나중에 깨달았는데 Async IO
에서는 많은 부분이 파이썬 코드로 작성이 돼 있어요. 그리고 uvloop에서는 거의
대부분의 것들이 CE에서, 싸이선이랑 CE에서 작성이 돼 더라고요. 이 차이가 만
든다고 보시면 될 것 같아요.
uvloop이라기보다는 그 밑에 있는 libuv에서는 파이썬 개체를 전부 다 CE에 있는
함수로 구현을 해놨고요. 메모리 관리를 최적화를 해놓았고 시스템 자원 사용을
최적화로 해놨어요.
Async IO에서 구현돼 있는 이벤트 loop, 베이스 이벤트 loop를 제공해 주거든요.

그거랑 사실 libuv에서 구현된 이벤트 loop는 구현 방식은 동일하다고 보시면 됩
니다. 다만 구현돼 있는 게 파이썬 내부에서 구현된 게 있느냐, 아니면 CE에서 최
적화된 방식으로 구현돼 있느냐의 차이더라고요. 이 차이에서 나오는 게 이 성능
의 아까 보여드린 성능 차이를 가져오는 그런 결과를 보여줬습니다.
그러면 왜 이벤트 loop에만 사용했냐고 하면 다른 것들도 할 수 있지 않았냐고 할
수 있는데 이거는 제가 테스트해 본 거는 아니고 다른 곳에서 해봤던 거를 가져
왔는데 글자가 안 보이실 수도 있는데 좌측에 보면 Async IO를 여기서 활용한 거
고, 간단한 작업만 하는 건데 사실상 레이턴시 기준으로 보면 최악의 경우의 케
이스를 보면 사실상 거의 비슷한 성능을 보여줘요. 우측에 있는 것들은 고랭까지
도 같이 비교를 해본 거거든요. HTTP 툴즈를 기반으로 해서 HTTP를 파싱을 하
는 해석을 하는 부분만 구현이 돼 있는 건데 이것을 기준으로 했을 때 Async나
libuv랑 실제적으로 차이가 없더라고요. 결론적으로 말하면 기본적인 로직들은
대부분 직접 CE나 이런 것들로 구현을 직접 하지 않더라도 성능의 차이가 없었
던 거죠. 이것 때문에 이벤트 loop만 대체를 하고 그 외 모든 것들은 Async IO에
서 제공한 기본적인 전략을 택했던 것 같아요.
여기까지가 제가 준비했던 uvloop에서 실제로 활용을 하고 있던 그 안에 있는 uv
에 대한 설명이었고요. 마지막으로 한 가지만 더 설명을 드리면, 비동기 프레임
워크는 잘하고 있는데 동기 프레임워크는 뭐하고 있냐고 해서 검색해봤어요.
저희 회사에서는 초창기부터 Django를 쓰고 있어서 Django는 프레임워크가 점
점 개발하는 양이 비대해질수록 점점 관리하기가 힘들어지고 속도가 나오지 않
는 그런 단점들이 있기는 하거든요.
도대체 Django에서는 어Asynchronous하게 프로그래밍할 수 없냐고 했을 때 작
년에 프로포절을 제안하신 분이 있었고 받아들여져서 지금 개발하고 있어요.
Django 3.0에서는 Async노로스한 에스아이지와 같이 할 수 있는 완전한 비동기
방식을 지원할 예정에 있고요. 다만 Django라는 프레임워크 자체는 가장 간편하
고 빠르게 엠브이피를 만들어볼 수 있는 이런 프레임워크를 지향하고 있으면서
동시에 대용량 처리도 같이 할 수 있는, 모든 거를 커버하려고 하는 지향성을 갖
고 있거든요. 비동기를 기본적으로 활용할 수 있는 건 아니고 선택적으로 원한다
고 하면 비동기 방식을 쓸 수 있도록 그렇게 지원할 예정이라고 합니다. 3.0은 19
년 12월, 얼마 안 남았는데 올해 말이면 배포를 해서 바로 어Asynchronous한 프
로그래밍을 장고에서도 할 예정이라고 합니다.
만약에 비동기 방식을 지원한다고 해서 바로 사용을 하시려고 하면 기존 방식대
로 코딩을 하시게 되시면 에러를 볼 수 있다고 하더라고요.
사실 Async 프로그래밍을 하게 되면 만약에 중간에 블락을 하는 로직이 있거나
하면 사실상 어Asynchronous 프로그래밍의 혜택을 볼 수 없거든요. 이것 때문에
기존에 Django를 활용하시면 Async 프로그래밍을 어떻게 하는지에 대한 이해를
먼저 하셔야 될 거고 만약에 엄청난 작업이 소요될 거라는 예상이 되고 있습니
다.
여기까지가 제가 준비한 발표 자료고요.
혹시 질문이나 아니면.. 제가 자세한 것들은 질문에 대한 답변을 못 드릴 수 있는
데 오늘 내용에 대해서 질문이 있으시면 질문을 받도록 하겠습니다.
앞에 마이크에서 해 주시면 좋을 것 같아요.
-(사회자) : 죄송한데, 제가 질문하기 전에 공지 좀 하겠습니다.
Q&A 시간인데 저희가 지금 책을 나눠드리고 있어요.
Q&A를 적극적으로 해 주시면 감사하겠습니다.
지금 한 5분 정도 남았는데 세 분 정도만 Q&A에 응해 주시고요.

Q&A를 다 하신 분께서는 뒤쪽에 보시면 책을 나눠주는 자원봉사자 분이 계신데
그분한테 가주셔서 책을 수령해 주시면 되겠습니다. 감사합니다.
-(질문) : 안녕하세요. 잘 들었습니다.
재미있게..
궁금한 게 uvloop로 사용해서 사용을 했을 때 뭔가 메모리립 같은 문제가 발생했
던 적이 있는지가 궁금하고요.
혹시 어떤 버전 때 그런 문제가 생겼으면 어떤 식으로 해결하셨는지 사례가 있으
면, 궁금해서 여쭤보고 싶습니다.
-(한섬기) : 질문 감사드립니다. 저도 이런 것들이 궁금했었는데 솔직히 말씀을
드리면 저희는 아직 비동기 프레임워크를 프로덕션 환경에서는 써보지 않았어
요. 방금 질문주신 메모리립이나 그런 거는 경험을 해보지 않았는데 제가 알아보
면서 봤던 걸로는 uvloop 안에서도 메모리립 같은 버그가 있기는 하더라고요. 그
런데 이것들은 자주 쓰지 않는 API에서 나오고요.
아까 초반에 말씀드린 것처럼 sanic에서도 uvloop을 쓰고 있는데 메인, 주로 사
용되고 있는 API에서는 버그는 없다고 보셔도 무방할 것 같아요.
-(플로어) : 감사합니다.
-(질문) : 그냥 앞에 나가서 하면 되나요?
앞에 테스트를 했던 거 봤었는데요.
Flask 앞에 혹시 어떤 다른 거를 써서 했는지 그러면 그 안에서도 워크아웃을 선
택할 수 있는데 거기서 유브이를 쓸 수 있다고 알고 있는데 혹시 테스트를 해보
셨는지.
-(한섬기) : 다시 한 번만 확인하면 libuv 같은 거를 Flask나 이런 쪽에서도 활용할
수 있는지를 질문주신 게 맞나요?
-(질문) : Flask 앞단에서 써보셨는지..
-(한섬기) : 앞단에는 지유니콘을 달아서 테스트를 해봤습니다.
-(질문) : 거기에 워커를 여러 개를 선택할 수 있잖아요. 그 워커를 혹시 어떤 거를
테스트를 해보셨는지.
-(한섬기) : 워커는 기본적으로 제공되는 것만 활용했어요.
-(질문) : 워커에서도 이벤트 loop를 쓸 수 있는 동작이 있는데 그것까지 테스트를
해보셨으면 좋을 것 같아서요.
-(한섬기) : 고맙습니다. 저도 그 부분까지 테스트를 해보고 싶었는데 거기까지는
해보지 못 했어요. 말씀하신 대로 Flask에서도 하면 충분히 성능을 낼 수 있는데
요. 저희도 프로덕션에서 지 이벤트를 활용해서 잠깐 돌려봤는데 지금은 사용하
지 않고 있는데 다른 전략을 선택했기 때문에, 활용하면 훨씬 더 성능이 올라가
요. 씨피율도 올라가면서 다만 테스트는 오늘 준비했던 자료와 관련해서 비교하
면서 테스트를 준비해보지는 못 했습니다.
-(플로어) : 감사합니다.
-(한섬기) : 뒤에 하얀 옷 입으신 분..
-(질문) : 안녕하세요. 저는 반 년 정도 sanic을 사용하고 있는데요. sanic을 사용
해보니까 생각보다 자잘한 오류들을 많이 만나게 되더라고요. 혹시 아직 프로덕
션에서 사용 중인 비동기 프레임워크가 없다고 하시는데 지금 가장 쓸만하한 비
동기 프레임워크가 어떤 건지 여쭤보고 싶어요.
-(한섬기) : 저도 이거는 프로덕션에서 직접 써보지 않았으니까 명확하게 답변 드
리기가 힘든데 제가 조사하면서 이것저것 여기에 나와 있지 않은 프레임워크를
살펴봤는데 제가 봤을 때 가장 많은 API를 제공해 주는 그런 프레임워크로는
sanic이 제가 봤을 때는 가장 유용하다는 생각이 들더라고요.

이거는 제가 조사하면서 봤던 거기 때문에 직접 써본 게 아니라서 딱히 말씀을
확실하게 드리기는 어려운 점 양해 부탁드리겠습니다.
-(플로어) : 감사합니다.
-(사회자) : 이제 발표 시간이 종료가 되어 세션을 마무리하도록 하겠습니다.
지금까지 발표해 주신 한섬기 님께 큰 박수 부탁드리겠습니다.
감사합니다.
-(박수)

