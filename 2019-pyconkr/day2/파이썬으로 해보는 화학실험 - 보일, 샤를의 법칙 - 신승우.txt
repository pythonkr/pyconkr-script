https://youtu.be/i6yhRr2FWN8

-잠시 후 발표를 시작하겠습니다. 안녕하세요? 이번 시간에는 신승우 님께서 파이썬으로 해보는 화학실험 진행하겠습니다. 큰 박수 부탁드립니다.
-안녕하세요? NC소프트 재직 중인 신승우라고 합니다. 진행자분이 말씀해주신 것처럼 물리적인 실험을 파이썬해보는 시간을 가질 건데요. 들어가기 전 간단히 몇 가지 말씀드리겠습니다. 물리하면 수식, 수식이면 물리인데 최대한 빼려고 했습니다. 공식을 물리 시간이 아니라 파이콘이니까 그대로 타이핑하는 데만 씁니다. 사실 라이브러리를 쓰지는 않아요. 최대한 안 쓰고 가능하면 시각화할 때만 쓰고 대부분 내용을 직접 구현하는 걸 목표로 하고 있습니다. 발표 메인이 파이썬이 아니라 좀 더 물리틱한 것 같습니다라고 말하기에는 미묘한 게 둘 다 메인이 아니고 둘 다 더한 거라 플러스가 메인입니다.
저 플러스가 사실 보면 개인적인 경험으로는 물리 같은 체계를 가지는 학문이라 파이썬이랑 합이 잘 맞는 경우가 많아서 예시로써 물리를 예시로 들었습니다. 먼저 파이썬으로 해보는 실험이라고 하면 의아한 생각이 들 수 있는데요. 생각하는 게 파이썬 쓸 때 어떤 일을 시키는 계산기로 쓰는데 크롤링해라, 수식 계산을 해라, 정해진 일을 해라는 계산기로 쓰는데 실험은 우리가 뭔가 시키는 게 아니고 자연한테 주어지는 거죠. 저거로 실험하는 게 의아할 수 있어요. 실제로 일반적으로는 저런 식으로 잘 안 쓰는 게 프로그래밍 언어들이죠.
저걸로 어떻게 실험하는지 간략하게 설명드리기 위해서 스포츠와 드라마 예시를 갖고 왔는데요. 공통점은 사람들이 나와서 서로 인터렉션하죠. 그게 결국 스포츠와 드라마 공통점인데 차이가 있죠. 각본 없는 드라마라고 스포츠를 말하죠. 한마디로 간단히 하면 드라마는 각본 있고 스포츠는 각본 없는데 각본이라는 건 큐시트예요. 그래서 미리 여기 있는 애들끼리 어떻게 작용하는지 정하고 그대로 쭉 해라, 일반적인 드라마죠. 그걸 그대로 안 하면 NG가 되고요. 우리가 생각해보면 일반적인 프로그래밍 절차형 프로그래밍 같은 경우에는 드라마에 가깝다고 할 수 있어요. 컴퓨터한테 인스트럭션을 주고 거기 맞춰서 시킨 대로 실행하니까 우리가 일반적으로 계산기라는 인식을 가지고 있고 실제로 맞기도 하고요. 드라마에 가깝다는 그런 생각을 할 수 있어요.
생각해 보면 스포츠는 각본이 미리 정해진 게 없고 일이 일어나면 관찰하잖아요. 한화가 이길 수도 있지만 질 수도 있죠. NG라는 게 원칙적으로 없어요. 흘러가는 대로 쭉 그걸 관찰하는 게 스포츠에 가깝다는 말이죠. 실험은 드라마보다는 스포츠에 가까워요. 각본 있는 게 아니고 그래서 실험은 어떤 현상이 일어나면 우리가 그걸 적법한 조건을 맞춰서 관찰하는 게 실험인 거죠. 이 차이 때문에 처음에 파이썬으로 실험하지? 하는 게 맞습니다. 제가 볼 때 직관적으로 맞고요. 둘이 말씀드린 것처럼 공통점이 있잖아요. 그 공통점이란 사람이든 캐릭터든 뭔가 나와서 인터렉션한다는 거죠. 그 공통점을 가지고 우리가 일반적으로 큐시트 짜는 것처럼 프로그램을 짜지 않고 조금 다르게 짜면.
스포츠가 실질적으로 어떻게 굴러가는지 살펴보면 야구를 예시로 들어볼게요. 스포츠를 보면 경기가 시작하고 그다음에 투수가 공을 던지면 그것에 맞춰서 경기 상황이 바뀌죠. 계속 바뀌는데 바뀌다가 9회가 돼서 점수가 차이가 나면 그것에 따라서 경기가 끝나면 전광판을 보고 어떤 팀이 이겼다고 경기 결과 확인하고 그러면 끝나죠. 대부분 스포츠에서 비슷하게 생각되는 구조일 거예요. 우리가 만약 아까 말씀드렸던 것처럼 실험은 스포츠랑 비슷하니까 스포츠 경기를 게임 구현한다고 치고 실험에서 비슷하게 구현할 수 있지 않을까. 그렇게 생각할 수 있어요.
이걸 잘 뜯어보면 우리가 스포츠를 볼 때 약간 상태의 시퀀스를 볼 수 있어요. 경기가 시작하면 처음에 선수 9명 나와 있고 심판 자기 자리 가 있고 타자 와서 타석에 서면 그게 이니셜 스테이트죠. 상태에서 투수가 공을 던지면 어떻게 공이 돌다가 다른 상태로 가요. 투수가 던지기 전까지 어떻게 일이 벌어지는 걸 이벤트라고 하고 그걸 홈런이라고도 하고 스트라이트, 아웃, 다양하게 있죠. 그리고 또 다른 상태로 가는 거죠.
마지막 파이널 상태가 있으면 그 상태에서 우리가 원하는 걸 뜯어서 보면 그게 우리가 전산적으로 만약 진짜 야구를 구현한다면 그런 식으로 구현할 거예요. 그래서 이런 식으로 스포츠를 구현할 거라는 걸 염두에 두고 생각해 보면 우리가 물리 같은 거 비슷하게 구현할 수 있는데요. 말들이 어벙하게 나와서. 야구를 볼 때 경기로도 보시지만 문자중계로도 보실 거예요. 문자중계를 보면 저건 한 줄 한 줄 텍스트잖아요.
저게 아무런 비주얼도 없는데 우리가 저 정도만 보면 룰을 안다는 가정 하에서는 충분히 야구 경기장에 어떤 일이 벌어지는지 이해할 수 있어요. 왜 그러냐면 저기 있는 것들은 야구 상태를 담고 있는 게 아니라 상태가 어떻게 변하는지에 대한 것만 담아두면 시뮬레이팅해서 저렇게 문자중계가 흘러갔으면 누가 공격, 누가 타석인지 알 수 있죠.
그래서 실제 시뮬레이션 짜는 것도 우리가 머릿속에서 문자중계를 보고 상상한 거랑 비슷하게 이루어져요. 그래서 우리가 어떤 스테이트를 정의할 거고 그 스테이트 정의한 거에서 어떻게 바뀔 수 있는지 구현하고 구현한 다음에 흘러가게 내버려 두면 걔가 알아서 시뮬레이션이 되는 거죠. 상태란 건 뭐냐면 스냅샷이에요. 어떤 특정 시간에 그 상황에 뭐가 있는지 어떤 일들이 벌여져 있는지 보고 원하는 정보들만 딱 얻어낼 수 있으면 그걸 가지고 충분히 시뮬레이션할 수 있는 거죠.
약간 모든 걸 다 시뮬레이션에 넣으려고 하는 게 아니라 단순화해서 넣는 거죠. 원하는 정보만 얻을 수 있도록. 다 넣으려면 천지창조를 하는 거니까 우리가 할 수 있는 영역이 아니에요. 원하는 것만 잘 넣어주면 우리가 원하는 대로 짤 수 있는 수준에서 시뮬레이션을 짤 수 있다는 거죠. 보통 시뮬레이션 하면 고리타분한 이야기 전에 앞서서. 우리가 어떤 상태의 시퀀스를 시뮬레이션이라고 했는데 그 상태를 시각화할 수 있으면 스냅샷이라고 했으니까 이미지랑 비슷한 거죠. 결국 시뮬레이션이라는 건 상태의 시퀀스였는데 이미지의 시퀀스라고 하잖아요. 실제로 계산은 복잡하지 않고 오히려 시각화 코드가 더 많기는 한데요. 동영상을 만들어볼 거예요.
동영상이 중요한 건 아니고 이런 식으로 시뮬레이션을 만들 수 있다 정도를 중요하게 보면 좋을 것 같습니다. 그래서 이런 프로그램을 통칭해서 시뮬레이션이라고 부르죠. 이런 식의 생각으로 어떻게 가질 수 있냐면 비록 파이썬이 계산기더라도 자연계에서 기체로 실험하듯이 실험 비슷한 건 할 수 있다. 비슷한 조건 맞춰볼 수 있다.
어떻게 하냐면 시뮬레이션을 통해서. 아까 말했던 것처럼 상태에서 우리가 어떤 정보를 가지고 있는지 그걸 잘 정의해야겠죠. 그다음에 한 상태에서 다음 상태로 넘어갔는지 정의하면 그다음에는 직관적으로 쭉 얻어갈 수 있죠. 처음 상태에 놓고 말 그대로 계산만 시키면 계속 다음 상태로 넘어가도록. 결국 결과를 얻어낼 테니까요. 이렇게 하면 우리가 진짜로. 어떻게 충돌하는지만 잘 짜 놓으면 그런 우리가 굳이 미리 다 언제 어디서 충돌할지 안 정해놓더라도 충돌해서 원하는 결과를 얻을 수 있다는 거죠.
여기서 조금 어렵다 혹은 눈여겨봐야 하는 게 상태 말을 했는데 물리적으로 상태에 대해서 이야기할 때 어떤 것을 중점적으로 봐야 하는지. 우리가 원하는 보일샤를의 법칙을 시뮬레이션할 수 있는지. 그 상태가 있으면 거기서 다음 상태를 어떻게 가는지. 필요한 걸 얻는 건 그렇게 어려운 게 아닙니다.
앞에 2개가 중요한데요. 봐도 느낌이 오겠지만 물리틱하죠. 그래서 우리가 물리를 배야 합니다. 물리를 배워야 하기는 한데 물리를 하는 시간은 아니니까 간단하게 넘어갈 거예요. 그래서 간단하게 역학이 뭔지. 역학에서 뭘 하고 싶은지. 어떤 목적을 가지고 있는 건지. 그다음에 역학은 뭔지 몰라도 뉴턴은 다 아시죠. 뉴턴의 법칙에서 뉴턴이 뭘 했길래 유명한지 그걸 아주 간단하게 보고요. 운동량과 충돌을 보는데 공식만 보고 넘어갈 거예요.
역학이라는 건 이름은 힘 력자인데 실제로 원하는 건 초기 속도가 있을 때 시간이 어떻게 지난 다음에 어디서 어떻게 움직이고 있을지 아는 게 역학이에요. 많이 쓰이거든요. 주로 우리가 아는 대부분의 기계도 다 쓰이고요. 미사일도 그렇고 자동차 여러모로 많이 쓰이죠. 그러면 운동상태를 알고 싶은데 운동이라는 건 시간에 따라서 위치가 바뀌는 걸 운동이라고 해요. 우리가 어떤 위치를 좌표값을 나타낸다고 치면 물체에 대한 위치를 곱하는 걸 말합니다. 시간에 대한 함수죠.
그래서 조금 더 길고 포멀하게 쓰면 X랑 VX9 초기 속도를 알 때 얘가 어디 있을지 어떻게 움직이고 있을지 이걸 구하는 게 역학의 기본적인 목표입니다. 어떻게 하느냐. 뉴턴이 등장하죠. 진짜 뉴턴이 알려준 대로 구하는 게 다고요. 뉴턴3법칙도 그것에 관한 겁니다. 1법칙은 관성의 법칙. 외부에서 주어진 힘이 없으면 지금 가는 대로 가요. 어떤 속도로 이동하고 있으면 그대로 쭉 이동한다는 겁니다. 그리고 이 법칙은 매력이 있으면 어떻게 바뀌는지가 2법칙에 관한 방법이고 3법칙 많이 아시죠. 어떤 A가 B한테 힘을 줬으면 B도 A한테 똑같은 힘을 주는데 크기는 똑같고 방향만 반대로 주는.
그럼 이 법칙을 보면 1법칙도 직관적인 게 휴일에 보면 누워 있잖아요. 비슷한 겁니다. 자극이 없으면 움직이지 않죠. 2법칙이 실질적으로 많이 쓰는데요. 2법칙을 보통 F=MA라고 불러요. F는 힘입니다. 스타워즈의 포스가 되게 비슷한 스펠링은 똑같은 포스입니다. 그 환경에서 힘을 구할 수 있는 걸 환경이 주어졌다고 하고요. A는 가속도인데요. 가속도는 아까 우리가 위치함수를 구하고 싶어 한다고 말씀했는데 시간으로 2번 미분하면 가속도라고 합니다. 나오면 문과분들은 슬퍼할 수 있어서 안 쓸 겁니다.
물리학 하면 근사거든요. 근사로 미분방식 안 풀고 할 건데 원래 F는 M하고 쓴 식 풀 건데요. 그래서 F가 상수인 경우 혹은 우리가 할 근사인 경우 등가속도 운동을 볼 건데 저런 식으로 주어집니다. 저 식을 이따 보시면 알겠지만 그대로 타이핑할 거예요. 그 이상 아무것도 안 합니다. 2, 3차원 X축만 이야기했는데요. 2, 3차원에서는 X Y Z 따로 쓴다고 생각하면 돼요. 각각 구해서 좌표 찍어두면 운동방정식을 그대로 푸는 겁니다.
이제 드디어 파이콘틱하게 파이썬을 볼 건데요. 할 게 파티클이라는 클래스랑 시스템이라는 클래스를 구현하고 힘들을 구현할 거예요. 원래 소스코드에는 저기 있는 시스템을 관찰하는 코드를 따로 짜 놨어요. 짠 이유는 원래는 시스템이랑 클래스를 조금씩 바꿔가면서 짜려고 했는데 그런 걸 하기가 싫으니까 파이썬에 있는 좋은 기능 데코레이터를 해서 밖에 빼놨습니다.
그래서 우리가 파티클에 대해서 구현하는데 파티클 진짜 구현하는 건 천지창조하는 거니까 안 할 거예요. 그걸 구할 때 필요한 건 넣어주면 되는 거죠. 그걸 구할 때 물리에서 필요로 하는 게 뭘 필요로 하냐면 일단 초기 속도랑 초기 위치 기본적으로 필요해요. 보통 질량을 많이 써요. 질량도 넣어줄 거고요. 물리 시뮬레이션과 상관없는 거지만 시각화할 때 떠다닐 때. 시각화에 대한 정보를 넣어줍니다. 파란색만 떠다니는 걸 볼 거예요. 그런 정보만 담고 있으면 됩니다. 이런 식으로 클래스를 만드는 건 소스코드를 보면서 보실 거고요. 시스템이라는 클래스는 이름이 참 거창한데 실제로는 아무것도 없고요.
어떤 환경이라는 건 힘이 정의되면 물리적인 환경이 정의된다고 했잖아요. 예를 들어서 우리 지구 같은 경우는 중력이라는 유니버셜한 환경이 있죠. 일반적으로 생각하는 지구의 환경은 중력이라는 게 지구 중심망에서 작용하는 그런 환경은 물리적인 환경이라고 해요. 힘도 필요하고 그다음에 시뮬레이션 할 때 실린더 같은 거에 기체를 넣고 눌러가며 압력이 어떻게 변하는지 관찰하거든요. 벽을 원래는 따로 구현하는 게 정석으나 벽을 시스템 안에 있는 컴포넌트로 구현하겠습니다.
본격적으로 코드를 볼 건데요. 생각보다 짧아요. 한 500줄 정도 되고 기본적인 운동만 짜는 거 하면 200줄 정도만 하면 눈으로 보이는 것까지 짤 수 있으니까 한 번 더 보시는 거 괜찮을 것 같습니다. 파티클 클래스가 필요로 하는 게 포지션, 위치랑 속도, 질량 그리고 시각화를 위한 정보가 필요하다고 했는데요. 딱 봐도 위치겠고 속도겠죠. 별표 2개 옵션을 아시나요? 저건 이름 있는 인자들이 들어가는 개수가 정해져 있지 않을 때 저런 걸 쓰면 딕셔너리 형태로 읽을 수 있어요. 저런 식으로 쓰는데 코드를 읽다 보면 매스라는 게 MASS, 질량이죠. 나머지는 혹시 모르니까 지금은 저 정도만 넣으면 땡인데 다른 걸 넣고 싶을 수도 있고 색다른 뭔가를 넣을 수도 있고 하니까 확장성을 위해서 써놓은 겁니다.
파티클이 그러면 아까 말씀드렸던 등가속도 운동을 할 거라고 예상했잖아요. 어떻게 할 거냐면 짧은 시간 동안만 등가속도 운동을 하고 앞이랑 뒤랑 등가속도 가속도가 다르게. 보시면 우리가 어떤 함수가 있는데 그 함수를 근사하려고 하면 구간을 잘게 쪼개서 구간 안에서는 맨앞에 있는 값으로 다 근사하는 게 가장 간단하죠. 그렇게 하는 겁니다. 그 기간 동안에는 상수일 거라고 상정하고 계산하는 거죠. 지금 스탭이라는 함수에서 하는 건데요.
포스가 원래는 벡터인데 물체의 운동상태 자체가 힘에 영향을 미치는 게 많아요. 공기정화 같은 게 있으면 빠르면 빠를수록 공기저항 많이 받잖아요. 물체 운동 상태도 영향을 미치기 때문에 힘을 벡터로 구현하면 끝나는 게 아니고 파티클 운동상태를 가지고 계산되는 함수를 구현해놨습니다.
그렇게 한 다음에 A는 F=MA에서. 그렇게 한 다음에 새로운 포지션은 아까 봤던 식처럼 공식을 타이핑한 거예요. 아래에 있는 것도 타이핑한 거고요. 그렇게 한 다음에 업데이트해줍니다. 땡이에요. 사실상 메인 코드의 전부라고 볼 수 있죠. 그래서 사실 수직 타이핑한 게 메인이라 보시면 됩니다. 시각화도 뒤에 간단해요. 복잡하게 할 게 아니라서 원형만 할 거예요.
그리고 시스템이란 클래스를 볼 건데요. 얘도 간단하게 생겼죠. 포스는 아까 말했던 힘을 포스라고 할 겁니다. 시스템을 정해줄 때 힘을 미리 정해줘야 하니까 저런 식으로. 벽이 있을 때도 있고 없을 때도 있어서 편하게 하려고 코딩할 때 넣었습니다. 그다음에 어떤 시스템이 있으면 그게 우리가 진짜 아는 물리적인 체계잖아요. 그게 지금 움직인다 하는 걸. 이게 지금 뭐하는 거냐면 우리가 이 시스템 인스턴스는 우리가 말했던 상태 개념이 되고 스탭 함수는 우리가 말했던 상태에서 다른 상태로 넘어갈 때 대응이 되는 거죠.
실제로 보면 시스템 스탭에서 오브젝트별 스텝을 보죠. 저렇게 하면 뉴턴법칙에 따라서 그 시스템 안에 있는 오브젝트들이 속도랑 위치를 바꿔가면서 움직일 거라고 기대하고 있어요. 시뮬레이션 코드가 있는데 사실 라이브러리 쓰는 거에 가까워서 라이브러리 어떻게 쓰는지 간단하게 설명드릴게요. 펑션 애니메이션이라는 함수가 있는데 다른 건 설정 같은 부분이라서 그때그때 환경에 맞게 넣어주시면 되는데 딱 3개만 아시면 됩니다. 처음 아규먼트가 배경. 애니메이션 생성될 배경이고요. 맨 아래는 이니펑셜이라는 게 맨 처음 이니펑션. 그걸 두 번째 인자로 넣어줘요. 그렇게 넣어주면 이 함수가 해주는 건 맨 처음 이미지를 만들어놓고 애니메이션 상태를 만들고 두 번째 인자.
그렇게 굴리면 결국 계속 이미지를 만들어가면 쭉 이어붙이고 동영상이 만들어져요. 내부적으로는 그렇게 돌아갑니다. 아까 말씀드렸던 것처럼 맨 처음에 하는 건데요. 오브젝트 아티스트들이 뭐냐면 오브젝트들을 시각화하기 위해서 만든 어트리뷰트고요. 거기 있는 애들한테 처음에는 아무것도 없게 넣어놔라고 하면 땡이고 아래에 있는 복잡한 코드가 있는데요.
코드가 복잡하게 있는데 그 부분은 시각화형 코드라서 크게 신경쓰지 않으셔도 되고 가장 중요한 거 셀프 점 스텝을 부르잖아요. 결국 시스템 안에 들고 있는 애들의 리치랑 속더를 조금씩 바꿔주는 거죠. 어떤 달 그림 그리면 위치를 지정해주잖아요. 위치 지정해준 게 다음번에는 스탭에서 바뀐 위치에다 생긴 겁니다. 가장 중요한 건 언제나 시각화 부분 말고 스탭핑하는 부분이 가장 중요하다고 말씀드립니다.
힘들을 보면 좋을 것 같은데요. 힘들이 복잡하게 쓰여 있는데 실제로 뜯어 보면 수식으로는 간단한데요. 일단 제로퍼스트를 보면 힘이 없는 거예요. 0, 0으로 리턴하면 어떤 파티클이 들어와도 0,0이니까 힘이 없는 거고요. 보통 늘릴 때 늘어나기 전에 위치가 있고 맨 처음 아규먼트로. 두 번째 아규먼트는 늘어난 거에 비례해서 힘이 되니까요. 탄성력을 잘 쓰고 싶으면 2개의 파라미터가 필요해요. 받아서 탄성력이라는, 만들어주는 함수를 짠 거죠. 코드에서 보면 탄성계수값 원래 위치값 넣고 하면 탄성력을 나타내는 식이 됩니다. 그렇게 됐고요.
그래비티는 중력이죠. 옛날 물리 때 배웠던 거 기억하는 분들은 가속도 곱하기 질량인 거 기억하는데요. 얘는 아까 말씀드렸던 것처럼 공기저항 같은 걸 담아봤는데요. 공기저항은 P가 파티클, B가 벨로시터 벡터. 그런 식으로 내가 이동하는 속도에 비례하는데 속도의 반대 방향으로 힘을 받도록. 이렇게까지 하면 물체랑 운동을 구현한 거고 이 정도까지 짜면 그럼 대충 2, 300줄 정도 됩니다. 여기까지 한 거로 다양한 것들을 할 수 있는데요. 생각보다 많은 걸 할 수 있어요. 간단하게 살펴보면요.
P는 입자 하나만 있어도 돼요. 시스템에는 중력만 있으면 돼요. 중력가속도를 원래는 9.8인데 1.0으로 넣었어요. 그렇게 하고 시뮬레이터를 돌리면 되는데요. 우리가 시스템에다가 이런 파티클 맨처음에 1만큼 정지해 있는 파티클 시뮬레이터 돌리면 시뮬레이션 되는데요. 볼게요. 느리게 떨어지죠. 실제로 저게 너무 중력가속도가 느려서 가속을 받는 게 맞냐, 그런 생각이 들면 바꿔서 높여보면 되죠. 도긴개긴인 것 같은데 눈으로 보면 알기 어려우니까 관측하는 코드를 짜서 놓는 중인데요.
이게 Y방향 속도를 관찰하고 있는 거예요. 보면 여기서 시작했다 계속 속도가 마이너스 방향으로 가죠. 저런 식으로 시뮬레이션을 간단하게 할 수 있고요. 사실상 헬로월드가 자유낙하였으면 그다음으로 하는 게 보통 공기저항 있는 게 일반적인 건데요. 공기저항 있을 때 뚝 떨어진 걸 보면요.
이런 식으로 보면 속도가 공기저항 속도랑 계수가 엄청 크게 설정돼 있어서 바로 뚝 떨어진 걸 볼 수 있죠. 낙하산 펴면 중력을 받음에도 불구하고 똑같은 속도로 쭉 내려오잖아요. 그거랑 똑같은 겁니다. 이런 식으로 여러 가지 해볼 수 있는데 이거 하나만 보고 다음으로 넘어갈게요. 포트리스에서 바람이 반대로 불면 백샷이 되잖아요. 이게 옵저브 샘플스가 관찰한 시간. 잘 보시면 처음에 앞쪽으로 날아가다 뒤로 날아가죠. 그래서 이런 식으로 할 수 있는데요. 여기다 간단하게 충돌까지만 넣고 벽이랑 충돌하는 거, 분자끼리 충돌하는 거 넣으면 그냥 그대로 이상기체를 실린더에 넣은 걸 시뮬레이션할 수 있어요. 복잡하게 생긴 공식을 여기서 이렇게 타이핑해놓은 게 복잡하게 된 공식입니다.
그러면 이렇게 해놓고 벽도 비슷하게 충돌하고요. 이렇게 해놓으면 시간이 부족해서 빨리 최종 결과로 넘어가겠습니다. 이런 식으로 좀 작은데 파란색 애들이 기체분자고 빨간색이 상자면 정확하거든요. 그래서 저걸 가지고 뭘 할 수 있냐면 압력이라는 거는 저 기차들이 주는 충격을 압력이고 온도는 저 애들의 운동에너지를 온도라고 불러요. 그거로 그래프를 그리면 저기서 세 가지 그러보면 되겠죠. 실제로 그려보면 그래서 P랑 T 플롯은 직선으로 나옵니다. 저런 식으로 하면 우리가 일반적으로 봤던 첫 번째 플록이 보일, 두 번째가 샤를의 법칙을 구현할 수 있습니다. 몇 가지첨언이 있는데요. 시간이 다 된 것 같아서 여기서 마치도록 하겠습니다. 감사합니다.
-발표를 해주신 신승우 님 감사합니다. 지금부터 질의응답 시간을 갖겠습니다. 원활한 진행을 위해 질문은 1, 2개로 부탁드립니다. 가운데 마이크로 나와서 질문 드립니다.
-재미있는 발표 감사합니다. 질문 2개 있는데요. 이중 람다 부분은 놓쳐서 간단하게 설명 부탁드리고 또 하나는 소속이 NC셨는데 이런 생각을 하셨는지.
-저게 원래 다행히도 첨언에 써놨던 건데요. 이상기체 상대방정식을 가르쳐줄 때 실제로 카운팅을 하면 저렇게 된다는 걸 원래 수식으로 보는 게 고등학교 과정에 있는데 수식으로 보면 모르니까 짜서 보여줬는데 그때는 반응이 별로였는데 생각해보니까 물리랑 프로그래밍 중 하나만 아는 분들은 잘 이해해요. 둘 다 모르면 어려우세요. 둘 중 하나 아는 분한테 이런 식으로 만들면 모르는 걸 아는 거 기반으로 학습할 수 있지 않을까 생각했고요.
실제로 아까 말씀드렸던 시뮬레이션 짤 때 보면 얘가 자유낙하 짤 때 시스템에다 설정 줬는데요. 보시면 두 번째 인자가 하이라이팅된 부분이 힘을 줘야 하는데 중력을 줬잖아요. 중력가속도를 주고 싶으면 그냥 함수인 건 이해 가시나요? 원래 중력가속도를 주고 싶은데 시뮬레이션 상에서 편하게 받고 싶어서 트릭을 부린 건데요. 원래는 어떻게 주는 게 맞냐면 벡터면 예를 들어서 원래는 이런 식으로 주는 게 맞잖아요. 돌아가기는 할 텐데 원래는 안 돌아가야 정상인데요. 언디파인드가 돼야 맞죠. 그래서 파티클의 상태를 알아야 지금 그래야 힘을 정확하게 정의할 수 있겠구나 어떻게 생각하냐면 벡터를 내뱉는 애를 힘으로 놓자고 했습니다. 나중에 놓고 보니까 중력가속도가 9.8로 하니까 빨라요.
얘를 리턴함수를 하나 더 만들어보자. 그렇게 하면 얘는 g라는 파라미터를 받아서 중력을 리턴하는 함수를 만든 거죠. 이런 식으로 해서 람다문을 쓴 건데요. 트릭에 가까운 거고 그렇습니다.
-발표 시간이 모두 종료돼서 세션은 이것으로 종료하도록 하겠습니다. 질문 남으신 분들은 앞에서 발표자분과 따로 의견 나누시기 바라고요. 마지막으로 발표자분께 큰 박수 부탁드립니다.