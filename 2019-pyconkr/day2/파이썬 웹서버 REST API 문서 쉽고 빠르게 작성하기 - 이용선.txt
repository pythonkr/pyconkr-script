https://youtu.be/HLSFTD9apw4

-(사회자) : 문 좀 닫아주시기 바랍니다.
이제 발표가 시작될 예정입니다. 모두 자리에 앉아주시기 바랍니다.
안녕하세요.
이번 시간에는 아트릭스의 이용선 님께서 파이썬 웹서버 REST API 문서 쉽고
빠르게 작성하기라는 제목으로 40분간 발표해 주시겠습니다.
원활한 발표를 위해 질의응답은 발표 후 시간이 남으면 진행하도록 하겠습니다.
그럼 큰 박수 부탁드리겠습니다. 감사합니다.
-(박수)
-(이용선) : 안녕하세요.
파이썬 웹서버 REST API 문서 빠르고 쉽게 작성하기를 시작하도록 하겠습니다.
저는 5년째 파이썬 백엔드를 하고 있고요. Flask를 쓰다가 Django를 쓰고 있습니
다. 회사 이름은 AITRICS이고요. API 문서가 필요했는데 어떻게 하면 날로 먹을
수 있을까 고민을 하다가 파이콘에서 이 주제에 대해서 발표된 적이 없길래 다
같이 날로 먹고자 이 세션을 준비하게 되었습니다.
먼저 REST API 문서가 왜 필요한지 짚고 넘어가고 이거를 생성할 때 하는
OpenAPI에 대해서 설명을 드리고 파이썬 웹 애플리케이션으로부터 어떻게 생성
할 수 있는지를 설명을 드리고 이거로 인해서 어떻게 Django에서 어떻게 생성이
되는지를 말씀드리겠습니다.
REST API 문서 필요성으로 시작하겠습니다.
REST는 리프리젠테이션 스테이트 트랜스펄이고 행위를 지정해서 웹 애플리케
이션과 통신하는 방법을 뜻합니다. 이거를 만족하는 거를 REST API라고 하는데
세세하게 들어가면 다른 조건들이 붙는데 여기서는 예시만 간단하게 보고 넘어
가겠습니다.
여기에 보시면 콜렉션 왼쪽이 스피커 콜렉션에 요청을 내린 부분이고 오른쪽이
스피커 한 명을 지정해서 요청을 보내는 부분인데, get 메서드는 정보를 조회할
때, 포스트는 수정, 딜리트는 삭제 이런 식으로 요청할 때 사용합니다.
완벽한 기준이 있는 게 아니라서 구현에 따라서 풋, 패치 이런 요청을 보내지 않
는 걸 허용하지 않을 수도 있고요. 어떤 개체에 따라서 풋을 요청했는데 그 개체
가 없을 경우 생성하는 식으로도 구현할 수 있습니다.
왜 API 문서가 필요하냐면 사실 API 규모가 되게 작고 사용하는 사람 수도 적고
이러면 그때그때 전달하는 게 더 효율적일 수도 있어요.
그리고 백엔드랑 프론트 개발을 한 사람이 다 하는 경우에도 문서가 필요가 없고
요. 그런데 API 규모가 크고 업데이트도 잦고 쓸 사람도 많고 그러면 매번 사용자
들에게 API 스펙을 전달하기가 힘들어지고요. 이럴 경우에는 백엔드랑 프론트개
발을 다른 사람이 나눠서 하기 때문에 문서를 작성할 때는 커뮤니티 코션을 크게
낮출 수 있습니다.
REST API 문서는 이런 식인데 간단하게 소개나 라이센스도 들어가고요. 접속
주소와 포트, 인증방법, 그리고 어떤 URI들이 있고 거기에 어떤 메서드들이 지원
이 되고 어떤 파라미스를 받고 어떤 response가 되는지가 포함이 됩니다.
대충 이런 식으로 생겼는데 패키지라는 콜렉션에 요청을 보내는 포스트가 형성

이 되는데 리퀘스트를 보낼 때 뭘 보내야 되는지 쓰여 있고요. 성공했을 때 200일
응답이 왔을 때 어떤 필드들이 내려오는지도 나타나있습니다.
이런 게 있으면 좋은데 손으로 직접 작성을 하려고 하면 너무 귀찮고요.
그다음에 코드를 업데이트를 했을 때 문서도 같이 업데이트를 해줘야 되는데 이
거를 자꾸 잊어버립니다. 큰 문제고요.
반복되는 게 많아서 한 곳만 바뀌어도 문서에서 수정해야 할 것이 많아서 힘듭니
다.
그래서 API 문서 작성을 직접 하지 않고 자동으로 생성되게 하고 싶은데 이거를
쉽게 하도록 해 주는 OpenAPI Specification이 존재합니다.
이게 뭐냐면 REST API 문서의 내용을 사람과 코드를 읽을 수 있도록 한 것이고
얌엘로 작성이 됩니다.
이런 데에 쓰이고요.
스웨거에서 시작을 했는데 지금은 OpenAPI 이니시에서 하고 있습니다. 여기서
스웨거가 뭔지 보면 API 개발을 돕는 프로젝트인데 세 가지 툴셋이 오픈 소스로
돼 있습니다. 첫 번째로 스웨거 코드젠에는 서버나 클라이언트를 이렇게 변환해
주고요.
제이선이나 얌엘을 이렇게 바꿔주는데 이게 핵심인데요.
오른쪽처럼 API 문서로 렌더링을 해 주는데요.
얘는 스웨거 URI에서 공식으로 제공하는 데모 페이지인데 들어가면 보실 수 있
습니다. 여기에 들어가면 맨 왼쪽에 이름과 설명, 버전이 들어가고요.
바로 아래쪽에는 지원하는 모든 URI들이랑 어떤 메서드들이 있는지 그리고 각
API가 어떤 용도들인지 설명이 간략하게 있고요. 이 중에 하나를 클릭하면 이런
식으로 펼쳐져서 어떤 리퀘스트 파라미트와 어떤 response 키마를 갖는지 확인
할 수 있습니다.
우측 상단에 트라이 아웃이라는 버튼이 있는데 이거를 클릭하면 이렇게 또 펼쳐
져서 직접 HTTP 리퀘스트도 보낼 수 있고요. 문서가 이렇게 생겼는데 이거를 만
들어주는 OpenAPI Specification 얌엘이 어떻게 생겼는지 보겠습니다.
이렇게 생겼는데 제이슨은 이번 발표에서 안 다루고 얌엘로 할 텐데 제이슨이 너
무 커서 슬라이드에 안 담겨서 얌엘로 진행하고요.
먼저 API 이름, 설명, 버전, 라이센스 이런 게 들어가고요.
그다음에 이거는 요청을 보낼 서버 정보인데 접속 주소와 포트 같은 게 있고 여
기는 서버가 한 대만 나와 있는데 실제로는 용도에 따라 여러 대가 될 수 있겠죠.
가장 중요한 API 리소스 설명입니다. 스피커라는 메서드에 겟 요청을 보냈을 때
어떤 응답이 들어오는지 써 있는 거고요. 응답 형식이 제이슨이라는 것과 스피커
레퍼런스로 지정된 스피커의 어레이가 내려온다고 써 있고요.
그리고 이렇게 앞에서 레퍼런스로 지정한 스피커에 어떤 필드들이 있는지 써주
면 가져다 쓸 수 있는 형태입니다.
이런 얌엠을 스웨거 URI에 집어넣으면 API 문서가 나오고요. 이 말은 즉 얌엘까
지만 자동생성하면 이후의 문서는 자동으로 다 들어온다고 할 수 있습니다.
이제 어떻게 파이썬 웹 어플리케이션 코트에서 저 OpenAPI 얌엠을 뽑아낼 수 있
는지 알아보겠습니다.
얌엠을 뽑아낼 앱 어플리케이션 서버는 이런 것들로 구성이 돼 있는데요. 먼저
베이스 유알엘 포트 이런 기본 정보가 있고 펑션들을 원하는 맵핑을 해놓은 라우
터가 있고요.
리스폰스 스키마를 어떻게 내려줄지가 있습니다.
이 부분 얌옘을 생성하게 되고요.

라우터 코드로는 어떤 API가 존재하는지, 나타내는 얌엘을 생성합니다. 오른쪽
에는 스피커스 하나만 있지만 이것 말고도 여러 메서드들이 있을 수 있죠.
리퀘스트 파라미터를 받는 코드로는 해당 부분이 얌엘을 생성하는데 오른쪽은
비어있습니다.
리스폰스 내려주는 곳에서는 리스폰스 얌엘을 생성하는데 200 코드에서 스피커
들의 어레이들이 내려온다고 생성을 합니다.
가장 많이 쓰이는 프레임워크인 Django랑 Flask에 대해서 각 정보를 어떻게 가
져올 수 있는지 한번 보겠습니다.
Django의 경우에는 서버 Django의 경우에는 어차피 어플리케이션 내부 환경보
다는 배포 외부 환경에 따라서 달라지는 게 많기 때문에 문서를 생성할 때도 손
으로 한번 적어 줘야 됩니다. 어차피 잘 바뀌는 것도 아니고 양도 적어서 적어줄
만 합니다.
핵심인 라우팅 정보는 유알엘 패턴스에서 가져올 수 있고요.
리퀘스트 파라미터랑 그외 정보는 뷰에서 가져올 수 있습니다. 간단히 코드로 보
겠습니다.
이런 식으로 API 문서 뷰를 만들을 때 서버 정보를 같이 적어주고요.
아래쪽은 Django를 써보셨다면 익숙하실 수밖에 없는 유알엘 패턴스인데 이거
를 가져다가 어떤 API들이 있는지 나열할 수 있습니다.
파라미터랑 리퀘스트 정보를 가져와야 되는데 펑션 뷰 같은 경우에는 형식이 정
해져 있지 않고 리퀘스트를 내려주는 부분도 일정하지가 않아서 정보를 갖고 오
기가 힘듭니다.
오른쪽처럼 독 스트링으로 일일히 하자니 직접 문서 쓰는 거랑 다를 바가 없고
요.
클래스트 뷰는 가능성이 있는데 장고에는 제네릭뷰라는 게 있는데 오른쪽에 있
는 거와 같이 저거를 제네릭뷰라고 하는데 이거를 쓰면 포스트 메서드와 스테이
틱코스 코드들이 자동으로 만들어주는 것이 포함되어 있는 거고요.
업데이트뷰 이런 것도 있어서 이것만으로도 패스에 어떤 메서드가 있는지 알 수
있습니다.
그리고 클래스 베이스드 뷰에는 모델과 겟 함수가 있는데 어떤 리소스에 대한
API인지 그리고 폼 클래스를 통해서 어떤 파라미터를 받는지를 알 수 있습니다.
Flask도 한번 보겠습니다.
마찬가지로 서버 정보는 배포 환경에 따라 달라지는 거라서 직접 적어줄 수밖에
없고요. 나머지도 Django랑 유사한데 장고에서는 리스트에 직접 코드로 적어줬
었는데 Flask는 데코를 통해서 등록을 합니다. 이때 뷰에 차곡차곡 들어가는데
라우터 함수를 보시면 안에서 애드 유알엘 룰 함수를 하고, 여기에 뷰 펑션을 매
핑을 해서 넣어두는 거를 보실 수 있습니다.
이거를 꺼내서 패스 부분 얌엘를 생성하면 되겠지요.
리퀘스트와 response 부분은 Flask는 이거를 붙이지 않으면 되게 힘들어요. 펑션
뷰는 Django와 마찬가지로 답이 없고요. 클래스뷰도 장고처럼 붙어있는 게 아니
라서 이거를 가져오지 않으면 힘듭니다.
정리를 해보면 서버 정보는 배포 환경에 따라 달라져서 직접 적어줘야 되고 라우
터 정보는 어떤 프레임워크든 간에 개체를 저장해서 쓰면 되고 Flask는 코드로부
터 정보를 얻기가 힘들었고요.
Django는 그나마 가능하기는 한데 Django 자체가 제이슨보다는 템플릿 엔진을
써서 에이치티엠엘을 내려주는 데 최적화가 되어 있어서 애매한 감이 있습니다.
OpenAPI를 장고로만으로는 만들기가 어렵습니다.

그래도 둘 다 익스텐션을 사용하면 충분히 가능한데 먼저 Django부터 어떻게 하
면 되는지 보겠습니다.
Django REST API 서버를 만들려면 Django 프레임워크를 쓰는 게 좋은데 맵핑
을 해서 더 쓰기 좋게 돼 있고요, 뷰가. 그리고 제네릭뷰가 엄청 잘 돼 있는데 시
니얼라이저만 어떤 거를 쓰는지 명시를 하면 리트리브 등등 이런 메서드들을 만
들어줍니다. 여기서 시니얼라이즈 개념이 등장하는데 예시를 보시면 스피커라는
장고 모델 오브젝트가 있을 때 이거를 스피커 시니얼라이저에 넣으면 지정된 필
드만 정해진 형식으로 딕션으로 변환해줍니다.
그리고 이 경우는 보통 에이치티피 리퀘스트로 여기서 값을 처리할 때 이렇게 되
는데요. 데이터로 넣으면 벨리데이션도 할 수가 있고요. 아래처럼 바로 모델 어
트리뷰트에 넣을 수 있는 상태로 잘 바꿔줍니다. 크리에이티드 데이트 타임은 자
동 생성돼서 입력하지 않아도 되는데 스트림이 저 오브젝트로 변환되는 거를 보
여주기 위해서 넣었습니다.
그리고 심지어 벨리데이션을 통과한 상태면 그냥 이렇게 시리얼라이저 닷 세이
브만 해도 디비에 바로 적용이 돼요. 여기까지 이따가 나올 장고 생성의 핵심이
되는 시리얼라이저의 내용이었고요.
클라이언트에서 필터화를 할 수 있는 파라미터들을 저절로 잘 만들어주고요.
뷰마다 이거를 넣어서 권한 관리도 쉽게 할 수 있습니다.
그리고 OpenAPI 스키마를 기본적으로 생성해 주는 기능이 있는데 이거는 잘 안
써요. 이유는 이따가 나올 거고요.
그래서 REST API 구현을 하려면 이 프레임워크를 쓰는 게 좋은데 이 REST 프레
임워크 위에서 API를 생성해 주는 라이브러리는 두 개가 크게 있었는데 그중 장
고 라이트 스웨거라는 라이브러리가 지난 달에 되면서 DRF Yet 하나만 남았습
니다.
그래서 지금부터 이 DRF Yasg가 어떻게 작동이 되고 어떻게 사용하면 되는지를
설명드리겠습니다.
DRF Yasg는 뷰마다 설정된 아까 보셨던 시리얼라이즈를 갖고 와서 스키마를 생
성하고요. 자동생성이 잘 안 될 때는 오버라이트를 할 수 있도록 데코도 잘 돼 있
습니다. 그리고 OpenAPI 스펙 2.0에 맞춰서 얌엘을 생성하는데 기본적으로 제공
하는 얌엘이 3.0 버전인데도 그거를 생성하지 않고 직접 합니다.
기본적인 제공 얌엘이 좋지가 않은데 저희 중에 건강검진을 하는 거를 예시로 따
왔는데요. 기본제공 얌엘을 보시면 페이션 관리 관련해서 이런 파라미터 하나도
없고요.
아이디 데이터 패키지시 이 부분으로 나와 있는 게 우측 하단에 보이시는 레퍼런
스로 쓰여있는 레코드 부분인데 이것도 레퍼런스 없이 하드 코딩 돼 있고 어레이
라고 명시를 해줘야 되는데 그런 정보도 하나도 없습니다. 그래서 장고 유알엘
패턴스에는 어떤 엔드 포인트에서 어떤 뷰셋을 쓰는지 어떤 뷰를 사용하는지 저
장이 돼 있는데 이거를 리터라이트를 하면서 얌엘을 생성하는 거고요. 뷰셋, 시
리얼라이저만 이렇게 명시를 하면 겟, 포스트 등 다 메서드를 만들어준다고 하던
걔네들인데 이중에서 맨 위에 있는 스앞이 커뷰셋만 파보도록 하겠습니다.
이런 식으로 뷰셋의 시리얼라이저 클래스가 들어 있고 스피커 시리얼라이저는
오른쪽으로 어떤 필드를 쓰는지 정보를 갖고 있습니다.
여기서 시리얼라이저 안에 또 시리얼라이저가 들어갈 수 있는데 이런 식으로 붙
어있는 상황이고요. 리퀘스트와 얌엘을 만들게 됩니다. 이거를 해 주는 코드를
말짝 보겠습니다.
이건 API 문서 페이지에 접속하면 실행되는 뷰펑션인데요.

보시면 스키마 제너레이터의 겟스키마로 얻은 스키마를 리스폰스로 내려줍니다.
이 겟스키마를 타고 가보면 OpenAPI 스키마 제너레이터의 겟 스키마인데 먼저
URI에서 가져온 패스를 가져옵니다. 여기서 패스는 아까 봤던 얌엘에서 각 API
별 스펙을 가지고 있는 핵심 부분이었고요.
그래서 겟 패스 코드를 보시면 각 API를 URI로 오퍼레이션을 뽑아내는데 그거를
모아서 패스를 만드는 거고요.
그래서 겟 오퍼레이션을 타고서 이런 식으로 리퀘스트 파라미터랑 리퀘스트 스
키마를 모아서 해 주는 거를 볼 수 있고요. 여기서 겟 리스폰스가 뭐하는지를 보
면 뷰에서 시리얼라이저를 갖다가 필드에서 시리얼라이저 메서드 필드, 페이진
네이션 이런 거를 처리해서 정확한 스키마를 만들어냅니다.
여기까지 정리를 해보면 DRF Yasg는 유알엘 패턴스를 가져다가 유알엘 뷰 클래
스 맵빙을 획득을 하고요. 여기서 각 유알엘 메서드별로 리스펀스를 찾는데 필드
에서 다양한 경우를 처리해서 정확한 스키마를 만들어냅니다.
이렇게 만든 스키마를 가지고 OpenAPI 얌엘을 생성하는 거고요. 아까 말씀드린
것처럼 얌엘만 있으면 문서는 스웨거 유아이가 다 그려주기 때문에 손을 대지 않
아도 됩니다. 그러면 이거를 어떻게 쓰면 되는지 볼 건데요.
예시 프로젝트를 하나 만들어봤는데 프로젝트 구조는 왼쪽에 보시는 것과 같이
간단하고요. 먼저 유알에스 닷 파이에 OpenAPI 스키마 뷰를 만들어서 유알엘에
등록을 합니다. 그리고 저 패스로 접속하면 문서가 나오게 되는 거고요.
이때 뷰를 만들면서 API 이름이나 버전 정보들을 적어주고요. 이렇게만 해놓으
면 사실 모든 API 다 찾아서 알아서 해 주기 때문에 90%는 끝나는 거나 다름 없
습니다.
그래서 직접 간단한 API를 만들어서 문서가 어떻게 생성이 되는지 볼 건데요.
오른쪽은 발표자를 관리하는 모델과 클래스를 만들어봤는데 모델을 보시면 이메
일, 네임 이런 필드들이 있고 그다음에 발표자 소속 회사인 올가니제이션이 포링
큐로 붙어 있습니다.
아래쪽은 세 줄만에 스피커, 크리에이 등 모든 거를 한번에 생성하는 모습이고
요. 여기서 어떤 리퀘스트 파라미트를 받고 하는 것을 시리얼라이저가 결정하게
되는데 이것이 어떻게 생겼는지 보겠습니다.
먼저 아래 쪽에 메타클래스를 보시면 스피커 모델을 사용하고, 모든 스피커 모델
에 있는 모든 필드를 사용한다고 써놨고요. 포링키 처리를 해야 되는데 리퀘스트
파라미트를 읽어올 때는 이렇게 하고 싶고, 리스트를 내려줄 때는 오브젝트를 펼
쳐서 읽고 싶단 말이죠. 그래서 이렇게 나눠놨고요.
그래서 이거를 이렇게 넣었고, 올가니제이슨 아이디는 인시젼으로 받을 수 있게
설정을 해놨습니다.
요청을 이렇게 보내보면 올가니제이션 아이디에 1번으로 인티젼을 보내면 생성
결과 응답에서는 이렇게 펼쳐져서 나오는 걸 보실 수가 있습니다.
간단하게 API를 만들어봤는데 바로 문서로 생성이 되고요.
저는 리독 유아이를 사용했는데 깔끔하게 만들어진 것을 보실 수가 있습니다.
여기서 리퀘스트랑 리스폰스가 좀 이상한데..
리드론입니다,라고 써놨는데 그것도 여기에 안 들어갔습니다. 이런 거 빼면 로직
코드 작성 외에 아무 것도 안 해도 거의 완벽하게 문서를 그려준다는 점에서 존
재하는 라이브러리 중에는 가장 좋다고 할 수 있습니다.
그런데 만약에 이렇게 스피커 시리얼라이저랑 관련이 없는 , 발표자 수를 세서
내려주는 API가 있다면 어떻게 될까요?
DRF Yasg는 기본적으로 시리얼라이저에서만 기본적으로 정보를 가져오기 때문

에 어떤 파라미터를 받는지 또 어떤 리스폰스를 내려주는지 알 방법이 없어요.
그래서 아까랑 똑같이 시리얼라이저만 보고 리스폰 스키마를 작성한 걸 볼 수가
있고요.
이거를 해결하려면 어쩔 수 없이 이렇게 API에 리퀘스트 정보를 적어줘야 되는
데 이게 200 코드인 경우 하나에 대해서만 써 있고 리퀘스트 파라미터도 없이 리
스폰스만 적었기 때문에 코드가 이 정도지 리퀘스트 파라미터가 있거나 하면 굉
장히 길어집니다.
그래서 이렇게 차라리 실제로 로직에서 쓰지 않더라도 맨 위에서 보시는 것처럼
스피커 카운트 시리얼라이저를 만들어서 데코레이터에 넣어주는 게 코드가 훨씬
더 깔끔하고요. 이렇게 달아주면 잘 인식해서 문서를 제대로 작성하는 걸 볼 수
가 있습니다.
그래서 장고 레스트 프레임워크를 사용하실 때는 간단하게 설정하셔서 문서를
바로 생성하실 수가 있고요.
몇 가지 한계점들이 있는데 아까 보셨듯이 리드온리랑 라이트온리 필드를 인식
을 못하고요. 시리얼라이저를 쓰지 않는 API에는 직접 스펙을 적어줘야 되는데
요.
이거는 뭘 쓰든 똑같이 마찬가지라서 큰 단점은 아니라고 생각을 하고요.
여태 보신 스크릿샷들이 이거였는데 여기에는 HTTP를 보낼 수 있는 기능이 없
어요. 그런데 스웨거 유아이에는 그런 기능이 있기는 한데 좀 예쁘지가 않아서
보기가 안 좋아서 쓰지 않고 있고요.
이런 식으로 필드가 좀 읽고 싶지 않게 생겨서 저는 리드온 유아이를 쓰고 있습
니다.
OpenAPI 스펙 최신 버전이 3.0.2인데 2.0을 쓰고 있어요. 그래서 3.0에서 구조가
간단하게 변했고, 좀 더 표현할 수 있는 게 늘어나기는 했는데 기능상에는 큰 차
이가 없어서 괜찮고요.
궁금하신 분들은 아래 링크에서 3.0 버전에 대해서 확인하실 수 있습니다.
여기까지가 장고 문서 자동생성이었고요.
이제 Flask에서는 어떻게 하는지 보겠습니다.
Flask도 장고처럼 이거를 생성해야만 API 문서 생성이 쉬운데 그 중에 하나가
Flask 레스트 풀이라는 건데요. 아래 보는 것처럼 리소스 단위로 만듭니다. 겟 메
서드를 만들어놨죠.
이런 식으로 하고.
리퀘스트 파라미터가 없어서 안 나왔는데 이것을 미리 만들어서 리퀘스트 파라
미터를 정의하고요. 리퀘스트 스키마도 저기에 보시는 것처럼 미리 정의를 해놓
고 사용합니다.
딱 봐도 이거를 가지고 문서를 작성하면 될 것 같죠?
Flask 레스트풀이라는 것도 있는데 이것으로 시작을 했고요. API 문서 생성으로
시작을 했으니까 당연히 자체 생성 기능이 탑재가 되어 있고 나머지 레스트 구현
등은 Flask 레스트풀하고 거의 같습니다. 개발도 활발하게 되고 있어서 사실상
현재 생태계에서는 레스트풀 플라스크가 좋다고 돼 있습니다. 만약에 레스트풀
을 쓰지 않는다고 하면 생성하기 위해서 쓸 수 있는 라이브러리가 크게 이 정도
로 두 가지가 있는데 Flask 스웨거는 기본이 1.2 버전을 지원한 상태에서 멈춰버
렸고요. 새로 시작한 2.0도 활발히 개발되고 있지는 않아요.
그래서 에스큐엘알 캠이, 디비 모델의 문서생성 관련 상속하는 좀 독특한 방법을
쓰고 있는데 문제와 모델과 직접 관련돼 있지 않은 메서드들은 독스트리밍에 의
존하고 있습니다. 이런 식으로 센드메일 같이 기본 버전에서 벗어난 애들은 독스

트밍으로 적어줘야 되고요. 인벤션도 맞춰줘야 돼서 굉장히 귀찮습니다.
사실상 Flask 레스트가 유일한 선택지고요. 이거를 어떻게 쓰는지 예시를 보여드
릴 건데 먼저 플라스크 앱을 만들고요. 그다음에 API로 감싸줍니다. 작동 원리는
DRF Yasg랑 비슷하니까 넘어가도록 하고요.
아까 장고랑 똑같이 스피커랑 올가니제이션 모델을 만들어봤고요.
API에서 사용할 인풋하고 아웃풋을 미리 정해놓은 코드인데요. 스피커 아웃풋에
서 올가니제이션 아웃풋을 해놨고 스피커 아웃풋을 정의를 해줬습니다.
아래에는 리퀘스트 파라미터로 쓸 인풋을 이거로 정의를 해줬고요. 장고랑 똑같
이 올가니제이션을 이렇게 받고 오브젝트로 펼쳐서 받을 수 있도록 해줬습니다.
이거를 사용해서 구현한 코드인데요. 제일 먼저 봐야 될 게 API 라우터로 등록을
해서 문서를 생성할 준비를 해 주고 있고요.
리스트 에이피아이와 이거를 구현해봤는데 리스트는 이렇게 리스폰스 타입에 어
레이라는 걸 명시를 해줬고 스피커 아웃풋을 정의해놓으면 이것도 만들어지고
API 문서에도 자동으로 들어갑니다.
크리에이트는 이게 필요해서 앞에서 만들어놓은 알규먼트 파서, 스피커 인풋 얘
를 API에 넣어서 문서로 나타나게 해 주고요. 실제 문서에서도 이거를 갖고 와서
넣어주는 모습입니다.
그리고 결과를 내려줘야 돼서 마샬위도 넣어주고요. 오른쪽은 추출한 결과입니
다. 장고랑 똑같죠.
여기까지만 하면 로직코드 작성 외에도 별 거 안 했는데 깔끔한 API 문서로 날로
먹을 수 있습니다.
결론은 핵심은 어떻게든 OpenAPI REST API이나 제이슨을 생성하게 되면 스웨
거가 다 그려준다는 거였고요.
장고랑 Flask 외에도 바이보라 이런 것들도 다 라우팅 정보를 저장해둔 개체를
가지고 있어요. 이거를 런타임에 가지고 와서 OpenAPI를 생성할 수 있고 sanic
의 경우에는 레스트 Flask에서 파생된 건데 이거를 써보시면 좋을 것 같고요.
바이보라는 검색해봤는데 안 나오더라고요.
Flask를 쓸 때는 Flask 레스트 플러스로 API 문서를 생성하시면 되겠습니다. 제
발표는 여기까지고요. 잠깐 회사 홍보를 하자면 제가 속해있는 AITRICS는 지금
세브란스 병원과 의료 쪽을 개발하고 있습니다. 머신러닝 개발자 채용중이니까
많이 지원을 부탁드리고 저희 회사에서 네 명이나 발표를 하게 되었는데 하나는
이 발표랑 동시에 진행이 되어서 보실 수가 없을 것이고 1시 55분, 2시 55분에 재
미있는 발표 있으니까 참관 바랍니다. 끝까지 들어주셔서 감사합니다.
-(박수)
-(사회자) : 좋은 발표 들려주신 이용선 님께 다시 한 번 큰 박수 부탁드리겠습니
다.
제가 몇 가지 공지를 해야 될 것 같은데요.
질문 사항이 있으시면 저 앞에 마이크 보이시죠?
저 앞에 마이크에 선착순으로 서시고 질문해 주시면 되시고요. 질문해 주신 질문
자 분들께는 책을 선물드리겠습니다. 한 권씩요. 책은 저 뒤에 보이시는 자원봉
사자 분께 수령하시면 되겠습니다.
질문 선착순으로 부탁드리겠습니다.
-(질문) : 발표 잘 들었습니다.
제가 개인 프로젝트를 진행하려고 API 서버를 구축하고 싶었는데 문서화까지 한
다는 가정하에 장고랑 플라스크를 보여주셨는데 둘중에 어떤 거를 쓰는 게 문서
화까지 봤을 때 어떤 게 더 나을지 발표자 님께서 취향이나 이런 게 있으신가요?

-(이용선) : 저는 개인적으로는 장고를 선호하는데 왜냐하면 API 서버가 점점 커
질수록 익스텐션을 갖다 붙여야 되거든요. 그런데 플라스크에서 갖다 붙이다보
면 장고처럼 돼버리는 경우가 많아서 이미 다 구현이 되어 있는 장고를 선호하는
편입니다.
-(플로어) : 감사합니다.
-(질문) : 발표 잘 들었고요. 저도 레스트 에이피아이로 개발하고 있는데 문서화
가 안 되는 부분이 있어서 문서로 진행을 하고 실무적으로 프로젝트를 진행하면
서 어떤 큰 도움을 받은 사례가 있으면 한 가지만 공유를 할 수 있을까요?
저도 필요성은 아는데 뭔가.. API 문서화 했을 때 획기적으로 프로젝트에 도움이
되는 부분이 있었다든지 ..
-(이용선) : 저 같은 경우에는 지금 개발한 프로젝트가 API 필드가 엄청나게 많고
요.
이게 계속 빠르게 개발 중이다 보니까 아직 출시 중이어서 업데이트가 되는데 이
거를 매번 바뀔 때마다 프론트 개발자 분들도 여러 분인데 일일히 전달할 수가
없어서.. 그냥 이거를 코드를 업데이트를 하면 바로 API 문서가 업데이트되기 때
문에 최신이라는 거를 보장할 수 있거든요. 그 문서 주소만 알려드리면 되는 거
라서 API 스펙 관련 커뮤니케이션이 줄어들었습니다.
-(질문) : 한 가지 더 궁금한 게 보면 리퀘스트 쪽은 유아이로 했을 때 안 되는 부
분이 있다고 하셨는데 유아이적으로 API 문서로 바꿨을 때 리퀘스트 부분으로
처리하고 싶은 부분이 있잖아요. 그런 거는 추가적으로 알아보신 부분이 있는 건
가요?
사용할 수 있는 추가적인 프레임워크가 있다든지..
-(이용선) : 제가 잘 안 들리는데 아까 문서에서 리퀘스트 날리는 부분이 없다는
그 부분 말씀하시는 거죠?
이거는 사실 장고 그 문제인데 스웨거 URI가 아까 보셨던 데에서는 읽기 좋게 나
오는데 걔만 이상하게 만들어주는 게 있어서 이 유아이를 쓰는데 그렇게 만들어
진 API 문서에만 리퀘스트를 보내는 기능이 없어요. 그래서 꼭 필요하시다면 스
웨거 URI를 선택하시면 그대로 쓰실 수 있습니다.
-(질문) : 우리가 장고로 코드를 만들면 안에 유니테이션이라든지 검증을 할 수가
있잖아요. API 문서를 만든다는 건 독자를 위한 거잖아요. API 문서 자체를 어떻
게 검증하시나요?
API 문서를 만들면 독자가 있고 독자를 위해서 검증이 필요할 것 같은데 검증을
어떻게 하시는지 알고 싶습니다.
-(이용선) : 구현된 코드로부터 API 문서를 작성해내는 거기 때문에 안 맞을 리가
없고요.
안 맞을 수 있는 부분이라면 자동생성되지 않는 부분에 직접 조금씩 데코레이터
로 넣어주는 부분이 있을 텐데 그 부분이 실제 최신 버전인지 아닌지 확인하는
그런 부분은 생각을 안 해봤네요.
-(플로어) : 고맙습니다.
-(질문) : 발표 잘 들었고요.
저는 아직 학부생이라서 학과 안에서 팀 프로젝트를 진행할 때가 많은데 사실 오
늘 발표해 주신 내용은 서버측에서 구현이 끝난 상황을 문서화하는 작업이라고
생각했거든요. 혹시 앞단계에서 협업할 때는 현업에서 어떻게 하는지 궁금해서
여쭤보고 싶습니다.
-(이용선) : API 구현이 되기 전에?
-(질문) : 스펙을 정한다거나 어떤 점이 필요한다던가 회의나 오프라인으로 만나

는 부분도 있겠지만 문서로 하는 것도 되게 좋은 것 같은데 그 부분이 잘 진행이
안 되고 있어서요.
-(이용선) : 저는 그 단계에서 그렇게 크게 막 문서가 필요할 정도로 큰 규모에서
일을 해 본 적이 없어서요.
항상 관련 개발자들이 다 모여서 일단 세세한 필드들은 그렇게 바로 바로 정하지
는 않고요.
어떤 것들이 크게 필요한지, 어떤 화면을 그릴 때 어떤 게 필요한지를 대충 논의
를 하고 그다음에 구현을 한 다음에 어쨌거나 구현을 서버에서 해야지 그걸로 프
론트에서 붙여보면서 개발할 수 있기 때문에 구현이 완료가 되었을 때 상세 필드
이름이라던가 그런 것들은 아까 보신 것처럼 문서를 생성해서 통신을 하고 있습
니다.
-(플로어) : 감사합니다.
-(사회자) : 공지 사항을 알려드리겠는데요.
혹시 은색 카드나 분홍색 카드를 잃어버리신 분들께서는 103호 앞에 가보시면
분실물을 찾으실 수 있습니다.
그리고 질문 더 받지를 못할 것 같습니다.
그리고 질문 더 받지를 못할 것 같습니다.
발표시간이 종료가 되어서 세션을 마무리하도록 하겠습니다. 지금까지 발표해
주신 이용선 님께 박수 부탁드리겠습니다.
-(박수)
감사합니다.

