*** Advanced Python testing techniques - 안재만 ***
-(발표자) 안녕하세요? 저는 이번 세션에서 파이썬의 테스팅 기법에 대해서 발표를 하게 될 안재만입니다. 반갑습니다.
(박수)
제 생각보다는 되게 많은 분들이 오셨는데 사실 테스팅 기법이라는 게 엄청 매력적이거나 엄청 궁금한 주제가 아니기 때문에 좀 이 자리에 오신 분들에 대해서 먼저 경의와 감사의 말씀을 드리고요.
사실 오늘 발표의 초점은 테스트를 어떻게 하면 재미있게 짤 수 있느냐가 초점이 되겠습니다.
그래서 테스트코드라는 것이 아무래도 여러분도 잘 아시겠지만 좀 로직을 짜는 것보다는 덜 중요하게 여겨지고 그래서 우선순위에서도 밀리고 짜는 것도 귀찮고 고통스럽고 이런 경우가 많이 있기 때문에 이 테스트코드를 굉장히 재미있게 짜는 게 테스트코드를 잘 작성하는 데에 큰 도움이 됩니다.
그래서 오늘 발표에서 몇 가지 적용해볼 수 있는 기술들을 살펴보면서 조금 더 재미있게 테스트코드를 짤 수 있는 방법에 대해서 소개를 드리겠습니다.
먼저 대상청중은 이렇고요. 아마 여러분 이야기일 수도 있고 제 이야기일 수도 있고 한데, 테스트 짜봐서 비슷하게 느낀 점이 있으실 텐데 짜다 보니까 코드가 복잡해져서 어떻게 짜야될지 모르겠다고 생각하는 분도 있을 수 있고, 테스트를 짜기는 짰는데 완벽하게 짠 건가 걱정되시는 분도 있을 수 있고, 테스트 너무 짜기 귀찮고 고통스럽다. 그리고 다들 사실 느끼시는 감정이시죠.
그리고 좀 어느 정도 하다 보니까 테스트코드 잘 짜는 것 같은데 조금 더 잘하는 방법이 없나? 하고 고민하는 분들도 있을 겁니다.
그래서 이런 분들께 오늘의 발표가 도움이 됐으면 좋겠고요.
그래서 목차는 이런데 일단은 간단하게 보시고 바로 시작해보도록 하겠습니다.
그래서 먼저 기본적인 테스트 구현하기부터 살펴보실 텐데 많은 분들이 아시겠지만 사실 이 자리에 오신 분들은 테스트코드가 어떤 것인지에 대해서 다 아실 거라고 생각합니다.
왜 테스트가 중요하다, 이런 것도 사실 뭐 골백번씩 들은 내용일 텐데, 그런 것들에 대해서 다루지는 않을 텐데 Test Driven Development에 대해서는 한 번 더 설명드리도록 하겠습니다.
Test Driven Development에서 가장 중요한 건 먼저 테스트코드를 짜고 그다음에 로직을 짜라고 하고 있습니다.
여기서 테스트코드를 작성하는 사람이랑 로직을 구현하는 사람이 다르다면 더 좋겠지만 같아도 사실 큰 문제는 없습니다. 그런데 제일 중요한 건 로직을 작성하기 그 전에 테스트코드를 짜는 게 중요하죠.
여러분도 아시겠지만 로직을 짜게 되면 "아, 나 일 다했다. 퇴근해야지." 이런 식으로 빼먹는 경우가 발생을 하고 테스트코드를 짜면서 기획이나 내가 생각한 부분에서 빠진 부분을 보충하려면 코드를 이렇게 짜야겠다, 이런 생각이 들기도 합니다.
그래서 테스트코드를 미리 짜는 것이 굉장히 중요하고요.
이제 조금 기술적인 걸로 넘어가면 파이썬에서 기본적인 지원하는 테스트코드는 unittest 같은 게 있고요. 장고 같은 데서 unittest 기반으로 테스트코드를 짜기도 하죠.
그리고 pytest는 흔하게 많이 사용하시는 건데 pytest가 unittest의 상용화 느낌이고 여러 가지로 강력하게 사용할 수 있습니다. 그래서 제가 여기서 unittest와 pytest를 비교해서 뭐가 더 좋다, 이런 걸 설명드리지는 않겠지만 간단하게 차이점을 보시면 unittest 같은 경우에는 비교하는 것도 저런 식으로 되게 복잡하게 써야 되는 반면에 pytest는 그냥 간단하게 할 수 있고요.
그리고 pytest가 조금 더 자유롭게 픽스쳐를 사용할 수 있게 지원합니다.
그리고 실패할 때 조금 더 자세하게 내용을 알려주고 그리고 무엇보다 여러 가지 다양한 플러그인들이 있어서 pytest를 사용하면 간단하게 파워풀하게 테스트코드를 작성할 수 있습니다.
그래서 웬만하면 pytest를 사용해서서 테스트를 작성하시는 걸 추천드리고요.
기본적으로 일단은 unittest로 테스트코드를 어떻게 구현하는지 보겠습니다.
테스트코드를 짜보신 분들은 아시겠지만 unittest를 쓰려면 테스트케이스를 저런 식으로 클래스 기반으로 구성을 해서 코드를 짜야 되고 그래서 이 코드 같은 경우에는 굉장히 간단하게 1+1은 2인데 1이라고 했죠.
그래서 당연히 이 테스트는 틀렸습니다. 그래서 이걸 돌려보면 이런 테스트 결과가 나오게 되죠.
그래서 뭐 파이썬에서 unittest를 주고 뭐 이렇게 해서 주면 2는 1이 아니다, 틀렸다.
이렇게 나오게 되고요.
pytest는 두 가지 방식을 지원을 하는데 첫 번째 function 베이스. 두 번째는 클래스 기반으로 짤 수도 있습니다. 그래서 첫 번째 거는 다 아시겠지만 1 더하기 1은 2이니까 맞고, 두 번째 거는 1 더하기 1이 1이니까 틀렸죠.
그래서 이걸 돌려보면 이렇게 나옵니다.
그래서 테스트 플러스 파이에서 점 에프, 이런 식으로 표시가 되고요.
밑에서 보시면 아까 unittest보다 조금 더 자세하게 결과가 나오는 걸 보실 수 있죠.
그래서 2는 1이 아니다.
이런 식으로 테스트 결과가 나오는 걸 보실 수 있습니다.
그리고 픽스쳐 같은 경우에 저런 식으로 pytest가 픽스쳐에서 데코레이터로 넣어두고 이걸 테스트 펑션에서 저런 식으로 파라미터로 가져올 수 있습니다.
그냥 기억해두실 거는 픽스쳐로 저렇게 어딘가에 정의를 해두면 테스트코드에서 저런 식으로 파라미터를 받아서 쓸 수 있다.
이제 기본적인 건 대충 되셨을 것 같고 이제 본격적으로 여러분이 흔히 테스트를 짜는 그런 테스트코드에 대해서 보겠습니다.
그래서 이 테스트코드 같은 경우 유저가 가입한 후에 제대로 로그인이 되는지 테스트. 이런 거 되게 흔하죠.
코드가 어렵지는 않으니까 대충 보면 처음에 클라이언트를 만들고 싸인업을 요청해서... 이런 식으로 굉장히 간단하게 구현해봤습니다.
이게 장고의 테스트를 본 건데 장고는 unittest 기반으로 짤 수 있다고 했죠.
사실 pytest로도 구현할 수 있습니다. 이런 식으로 클라이언트를 먼저 픽스쳐로 정의를 해놓고 테스트 로그인 해서 클라이언트를 넣어서 클라이언트 포스트 싸인업 이런 식으로 할 수도 있습니다.
그런데 pytest는 여러 가지 플러그인을 지원한다고 했는데 pytest 장고 플러그인을 사용하면 저런 식으로 테스트코드를 조금 더 간단하게 쓸 수 있습니다.
그리고 조금 본격적인 걸로 넘어갈 텐데 보통 그 전까지는 되게 기본적인 테스트입니다.
사실 테스트를 하는 게 그렇게 막 엄청 간단하지는 않잖아요. 시나리오가 엄청 간단하지는 않아서 조금 더 복잡한 API 테스트 구현하기.
그래서 이번에는 유저가 가입한 후에 한 단계가 더 들어갔어요. 관리자가 승인을 해야만 로그인이 됩니다.
그래서 보시면 저 파란색 부분을 보시면 되는데 싸인업을 하고 200이 나오고 싸인인을 했는데 승인을 안 해서 403이 나오고, 그다음에 승인을 해주고 200이 나오고, 그다음에 로그인, 싸인인을 했더니 200이 나오는 그런 테스트로 이루어져 있습니다.
그런데 이걸 보시다 보면 테스트 검사가 저렇게 간단하게 200, 403 이것만 검사하지는 않을 겁니다.
그래서 보통은 이런 식이 되고요.
그래서 싸인업 해서 200이 있고 그다음에 뭐 데이터가 뭐 유저가 있고 아이디가 있고 이게 어쩌고 그다음에 로그인을 해서 이게 403이 나오고 어쩌고 저쩌고...
이렇게 가다 보면 테스트코드가 점점 읽기가 어려워집니다.
그래서 보통 많은 분들이 이런 단계를 경험을 하시는데 읽기가 되게 어려운 것 같아서 주석을 살포시 달아봅니다.
하지만 주석이 엄청 큰 도움이 되지 않습니다. 어차피 코드를 읽어야 되는 건 마찬가지고.
그리고 보통은 테스트 시나리오가 저것보다 더 복잡합니다. 그래서 유저가 가입한 후에 관리자가 승인을 했어요. 그리고 다시 밴을 시켰어요. 그다음에 로그인이 안 되는 테스트, 이런 테스트를 짜는 경우도 있죠.
그래서 막 열심히 짜는데 이거는 아까보다 훨씬 복잡해요. 그래서 여기에 적으면 아마 보이지도 않게 깨알같을 것 같아서 적지도 않았는데 이런 테스트도 하는 경우가 있고.
사실은 조금 더 간단하지 않죠. 유저가 가입한 후에 관리자가 승인을 하고 밴을 시켰는데 당연히 로그인이 안 되죠. 그런데 탈퇴는 할 수 있어요. 탈퇴한 후에 재가입을 하면 뭔가 계속 안 될 것 같잖아요. 그래서 재가입은 24시간 동안 막아놓는 그런 테스트가 되겠습니다.
이게 하다 보면 어떻게 짜야 할지 감도 안 오는데 엄청 길어질 것 같죠. 굉장히 복잡한 테스트케이스가 되겠습니다.
그래서 이런 식으로 복잡하게 시나리오가 되는데 어느 날부터 갑자기 기획자가 이런 말을 합니다.
"오늘부터 관리자가 승인 안 해도 가입할 수 있대요!"라고 이야기하면 멘붕이 오죠. 머리가 하얘지고. 내가 지금까지 뭘 했나, 테스트코드를 어떻게 바꿔야 하나. 이러면서 로직을 짜는 것보다 테스트가 힘들어지고 내가 왜 짰나... 테스트를 이걸 다 지워야 되나.. 이런 생각도 들고.
흔하게 발생하는 그런 시나리오입니다.
그래서 일단은 테스트코드를 굉장히 구조화 해서 되게 잘 짜는 게 중요한데요.
그래서 지금까지 문제는 테스트코드를 모두 다 읽기 전에는 어떤 테스트인지 알 수가 없고. 그래서 부분부분 다 찾아가면서 고쳐야 되는데 고통스럽고 그렇습니다.
그래서 이런 것들을 간단하게 테스트코드를 짤 수 있는 방법을 설명드리도록 하겠습니다.
처음에 Sure라는 라이브러리를 이용해서 직관적으로 테스트코드를 구현하는 방법에 대해서 보도록 할 텐데요.
Sure는 일단 Assertion을 쉽게 할 수 있도록 만들어주는 라이브러리고요. 코드를 보시면 이해가 될 텐데 , 오른쪽에 보시면 이런 식으로 굉장히 간단하죠.
그래서 저렇게 엄청 길게 쓸 필요 없이 사람이 읽을 수 있게 쉬운 방법으로 Assertion을 체크할 수 있도록 해주는 라이브러리입니다.
일단 주의할 점은 C파이썬에서만 사용이 가능하고요. 다른 종류의 파이썬을 쓰신다면 참고하시면 좋을 것 같고.
그런데 Sure는 넘버, 스트링, 콜렉션, 컬러블에 대해서 다 assertion을 지원을 합니다.
이걸로 아까 본 테스트코드를 직관적으로 만들어 보겠습니다.
보시면 아까보다 훨씬 더 간단해졌죠. 이거 같은 경우는 거의 네 줄 정도로 정리가 됐죠.
그래서 클라이언트, 레지스터, 스테이터스코드, 슈드 이퀄 200.
뭐 이런 식으로 해서 승인을 해서 그다음에 로그인 되는지 다시 체크하는 식으로.
이 Sure를 조금 더 매핑하는 펑션을 만들어서, 이렇게 하면 조금 더 간단해지겠죠.
보시면 클라이언트 레지스던스 석세스, 뭐 이런 식으로 조금 더 간단하게 펑션을 만들면 간단하게 사용할 수 있고요.
그다음에 아까 보셨던 안에 내용물들을 검사를 해야 된다고 하면 이런 식의 펑션을 만들어서 테스트코드를 간단하게 짤 수 있겠죠.
이런 식으로 안의 내용물들을 조금 더 쉽게 작성을 하면 조금 더 직관적으로 만들 수 있을 겁니다.
그리고 아까 보셨던 그 헬게이트 테스트코드는 이렇게 되는데 보시면 뭐 유저가 가입한 후에 관리자가 승인하고 다시 밴 시켰는데 로그인안 되는데 탈퇴는 성공하는데 이후 재가입 시 24시간 동안 가입이 되지 않는 테스트.
그래서 클라이언트 레지스터 석세스, 처음에 가입 성공하고 로그인은 실패하고.
그다음에 관리자가 승인한 다음에 성공하고 로그인 성공하고 관리자가 밴 시키고 로그인 실패하고 탈퇴 성공하고 레지스터 실패하고.
이런 식으로 구성을 할 수 있습니다.
Sure를 이용해서 이런 식으로 테스트코드를 하시고 잘 쓰시면 아까 보셨던 엄청 복잡한 코드들이 이렇게 간단하게 되는 걸 보실 수 있습니다.
그다음에 이제 Behavior Driven Development의 세션으로 넘어가도록 하겠습니다.
그래서 아까 보셨던 코드는 결국 내가 그 코드를 다 읽어야만 어떤 테스트 시나리오가 있는지 알 수 있었는데 Behavior Driven Development 같은 경우에는 Test Driven Development랑 굉장히 유사한데 TDD는 아까 저희가 고민했던 게 "아, 테스트코드를 어떻게 하면 잘 짤까? 테스트코드를 어떻게 하면 구조화해서 짤 수 있을까?" 이런 것에 대해서 고민을 하게 되는데 BDD 같은 경우에는 테스트코드 그 자체보다는 비즈니스 요구사항에 집중하자는 게 주요 컨셉입니다.
그래서 파이썬 라이브러리에는 이런 게 있는데 저희는 pytest BDD를 사용하도록 하고.
그래서 어떻게 쓰는 거냐 하면 먼저 자연어로 테스트코드를 작성하는 거예요.
그래서 예를 들어서 자연어로, 정상가입한 유저가 있을 때 올바른 정보로 로그인을 하게 되면 로그인에 성공해야 된다. 이런 식으로 자연어로 작성을 하게 되면 이 문장이 그대로 테스트코드가 됩니다.
이게 BDD의 기본컨셉이고요. 어떻게 사용하는지 조금 더 자세히 보시면요.
이런 식으로 시나리오를 쓰게 되고요. 그래서 Feature, 로그인 케이스, 이런 식으로. Given 한 클라이언트가 있다, When, 해당유저가 올바른 정보로 가입하면, Then, 정상적으로 로그인이 성공해야 한다.
그런데 이것만 쓴다고 컴퓨터가 막 AI가 있어서 테스트코드 작성해주고 이러지는 않겠죠.
그다음에 파이썬 코드로 이렇게 쓰면 됩니다. 그래서 Given, 한 클라이언트가 있다. 그러면 저렇게 디파인 해서 하고..
그다음에 Then, 정상적으로 로그인이 성공해야 한다. 클라이언트 로그인 석세스, 저런 식으로 구현을 하게 되면 아까 그 테스트 시나리오만 봐도 이게 어떤 테스트인지 알 수 있고 그리고 만약에 테스트 시나리오를 개발자가 아닌 사람도 만들 수 있겠죠.
그래서 한 번 더, 아마 보면서도 다 감을 잡으셨겠지만 한 번 더 설명을 드리면 Feature는 테스트할 기능이고 시나리오는 테스트할 상황 설명, Given, 테스트에서 사용할 데이터, 컨섹트스, When은 테스트를 수행할 조건, Then은 보장되어야 할 결과. 이렇게 정리해서 사용하시면 되고요.
여기에 한 가지 더 들어가는데 Background는 한 Feature에 여러 시나리오가 있을 때 공통적으로 사용하는 데이터나 컨텍스트가 있으면 정리해서 사용하시면 되겠습니다.
그래서 이런 유저 밴 테스트 해서 이 시나리오를 다시 한 번 파이썬 코드로 보시면 이제 이렇게 되고요.
그래서 시나리오, Given, Given, When, Then, 을 저런 식으로 파이썬으로 정리를 하고 왼쪽에서 시나리오를 작성해서 테스트를 수행할 수가 있습니다.
그리고 그다음은 이제 파라미트라이즈드 테스팅이라고 해서 내용물만 조금 바뀌어요. 일반 유저가 해외에서 로그인을 진행한다. 일반유저를 실패하고 관리자 유저는 성공해야 한다. 이런 경우가 있을 수 있는데 이런 거를 하나하나 디파인을 해서 하시기보다는 저런 식으로 파라미터로 저 자리를 만들어서 저 자리에 이제 일반을 넣든 관리자를 넣든 해서 테스트를 수행하실 수 있습니다.
그래서 이게 약간 무슨 말인지 감이 잘 안 오실 수 있는데 이거 같은 경우를 보시면 감이 잘 오실 것 같습니다.
그래서 이거는 저희가 실제로 저희 제품에서 사용하고 있는 테스트코드인데요.
보시면 저희가 만들고 있는 것 중에 약을 사진으로 찍어서 이게 어떤 약인지 알려주는 그런 앱이 있어요. 구글플레이스토어에 올라가 있는데, 그래서 그 코드의 한 부분을 가지고 왔는데 여기 보시면 약 식별 기본 시나리오 해서 약이 뭐가 있다.
이 약은 무슨 색이다. 이 약은 뭐가 써져있어요.
그런데 약을 뭐 어떤 인풋 프린츠, 어떤 색깔로 검색을 하면 약 검색이 성공해야 되냐, 실패해야 되냐. 이런 테스트 케이스를 작성하려고 해요.
그러면 밑에 Examples을 저런 식으로 넣어서 테스트를 할 수 있는데 처음에 아스피린이라는 약이 있고 그다음에 얘는 빨간색이고 ABCD가 적혀 있어요.
그런데 ABCD로 검색하고 빨간색으로 검색하면 당연히 검색이 성공해야 되고.
그리고 아스피린2가 있는데 이거는 빨간색이 있고 ABCD인데 EFG랑 블루로 검색하면 당연히 검색이 실패해야겠죠.
그래서 이런 식으로 BDD를 사용하시면 굉장히 간단하고 쉽게 테스트코드를 시나리오를 작성을 하실 수가 있습니다.
그래서 BDD를 사용할 때 유의하실 점이 있는데 지금까지 내용만 보면 되게 "BDD만 사용하면 테스트코드 진짜 짱이겠다, 엄청 간단하게 짤 수 있겠다." 이런 생각이 드실 수 있는데 BDD를 사용할 때 유의하실 점이 있는데 보시면 먼저 자연어로 디파인된 시나리오가 있고 아까 보시면 파이썬으로 다시 그 자연어를 다시 디파인한 코드가 있습니다.
이게 서로 다른 파일에 있어요. 그러다 보니까 분리되어 있어서 찾기가 어려워요. 그러다 보면 여기 시나리오가 여기 정리되어 있고 재사용되고 이러면 찾기 어려운데 이럴 때는 깔끔하게 IDE의 도움을 받으시면 되고요.
그리고 BDD를 작성하실 때 처음부터 좀 이 문장을 재사용할 수 있겠다, 재사용 가능한 문장으로 테스트를 구성하는 것이 굉장히 좋습니다.
그래서 예를 들어서 가입에 성공하고 로그인을 한 유저가 있다.
이런 문장은 그냥 정상가입한 유저가 있다. 이거랑 유저가 로그인을 한다. 이런 식으로 분리해서 작성을 하시면 나중에 사용하실 때 로그인 안 한 정상가입한 유저가 있으면 저 문장을 떼어서 쓰면 되니까 이런 식으로 하면 좋고요.
그리고 또 한 가지, When에서 수행한 결과는 Then에서 검사를 할 수가 없습니다. 그래서 Given에다가 내가 어떤 수행한 결과들을 저장한 콘텍스트를 미리 만들어놓고 When에서 수행한 다음에 Then에서 검사하시면 되겠습니다.
그래서 BDD를 써야겠다고 생각하시면 이런 것들이 조금 더 크게 와닿으실 텐데 그럴 때 이런 것들에 유의하셔서 테스트를 작성하시면 좋겠습니다.
그다음은 이제 HTTP mocking과 Monkey patching에 대해서 알아볼 건데요.
어느 날부터 갑자기 팀장님이 오셔서 "오늘부터 인증서버를 분리해서 새로 구현을 하겠다. 새로운 마이크로서비스를 만들겠다." 이런 식의 말씀을 하셨어요.
예를 들어서.
그러면 또 갑자기 멘붕이 오죠. 아까 내 테스트 케이스 다 작성했는데.
그런데 어쨌든 간에 로직을 바꿔야 되는데 일단 아까 테스트 코드 여기저기 인증 같은 경우는 많이 엮여 있는데 테스트코드가 있었기 때문에 조금 리팩토링을 그래도 내가 심리적 안정감을 가지고 진행할 수가 있었어요.
테스트의 중요성이죠.
어쨌든 그런데 이게 테스트를 하려면 인증서버가 하나 필요해요.
그래서 보통 이럴 때 이런 생각을 하죠. 1번, 테스트를 할 때 인증서버를 띄워야겠다.
2번, 뭔가 개발용 인프라에 인증서버를 띄워놓고 그 테스트를 돌릴 때 그 서버에 요청을 해서 받아야겠다. 이런 식으로 생각을 하게 돼요.
이렇게 외부서비스 디펜던시가 발생할 때 mocking을 주로 쓸 수 있는데요.
그래서 처음에 소개드릴 거는 HTTP mocking인데 mocking은 거짓의, 가장의 이런 의미가 있는데요.
발생하는 HTTP Call을 interrupt를 해서 실제로 콜은 안 보내고 거기 나오는 response를 자기 마음대로 조정할 수 있어요.
파이썬 같은 경우에는 HTTPretty를 쓰시면 되고.
그래서 어떻게 쓰는지 예제를 보시면 처음에 HTTPretty에 mocking을 활성화를 해주고 저 URL을 보낼 때 바디 오케이로 와야 된다, 이렇게 해놔요.
그러면 저렇게 돼야 된다고 mocking을 하실 수가 있습니다.
그래서 아까 거는 너무 간단하니까 이제 실제 사용하는 예시를 보시면 오른쪽 게 백앤드 로직인데 저기에서 로그인이 있고 로그인 해서 유저네임이랑 패스워드를 받아서 이거를 저 밑에 auth.aitrics.com/signin으로 보내요. 주로 이런 식으로 이루어지잖아요.
그래서 이걸 테스트를 한다고 하면 왼쪽 게 테스트 코드인데 저 인증서버에 있는 URL를 저런 식으로 모킹을 해서 먼저 등록을 해놓고 그다음에 밑에 테스트코드를 작성을 하더라도 백엔드에서 저기로 요청을 딱 보낼 때 이 HTTPretty가 딱 잡아서 OK를 만들어주는 이런 식으로 되어 있습니다. 그래서 HTTP mocking 같은 경우는 이런 식으로 쓰시면 됩니다.
그다음에 Monkey patching이라는 기술인데 이거는 아마 한번쯤 다들 들어보셨을 텐데 예를 들어서 G이벤트를 쓰거나 할 때 Monkey patching을 하라고 하죠.
그래서 Monkey patching이 뭐냐 하면 오른쪽 코드부터 보시겠습니다.
코드를 보시면 썸 모듈 닷 파이 해서 정리를 해놨어요.
클래스A, 뭐 이렇게 해서 프린트하는 함수예요.
나중에 제가 패치닷파이에서 썸모듈에 A의 펑션을 저 Monkey function으로 할 수 있어요. 이게 Monkey patching의 기본적인 거라고 생각하면 되고.
런타임에 정의되어 있는 클래셔나 모듈의 attribute를 바꾼다고 생각하면 되고.
테스트코드에서도 많이 활용하는데 제가 A모듈을 테스트하고 싶어요. 그런데 A모듈은 B모듈을 사용해서 구성이 되어 있어요. 그런데 저는 B모듈에는 관심이 없어요. 그냥 고정된 값으로 넣고 싶어요. 이럴 때 B모듈을 Monkey patching을 해서 원하는 값으로 바꾼 다음에 A모듈만 테스트를 할 수 있습니다.
그래서 아까 보셨던 것도 Monkey patching을 이용해서 돼있는데 이거는 뒤에서 보도록 하겠습니다. 그래서 Monkey patching의 실제 예시인데 이것도 저희 회사의 코드에서 가져온 건데 어떤 데이터를 받아서 나이를 예측하는 머신러닝 알고리즘이 있어요.
나이에 따라서 다른 운동방법을 추천하는 API가 있어요. 테스트를 하고 싶어요.
그런데 데이터를 받아서 나이를 예측하는 알고리즘은 사실 관심이 없어요. 그래서 밑에 것만 독립적으로 테스트를 하고 싶은데 이럴 때 오른쪽 테스트코드처럼 사용하시면 되는데 보시면 처음에 리턴, 뭔가 나이 많은 사람. 제가 나이가 많다고, 일단 100살로 잡았어요. 그러면 충분히 많은 것 같아요..
그래서 함수를 만들어놓고 그다음에 그 밑에 테스트펑션에서 이제 저 알고리즘에 저 펑션을 저 리턴 엘더리 에이지로 바꿔치기 해요.
그러면 무조건 100살이 리턴이 되는 저 펑션으로 Monkey patching이 되게 되고 그래서 이제 이 밑에 로직은 그냥 제가 원하는 대로 자유롭게 할 수 있죠. 무조건 100살이니까 무조건 나이든 사람의 운동이 추천이 되겠구나. 이런 식으로 독립적으로 테스트를 작성하실 수 있습니다.
그다음에 제가 아까 Monkey patching을 이용해서 HTTPretty가 구현되었다고 설명했는데 파이썬에서 저런 식으로 대체를 합니다. 이런 식으로 Monkey patching을 이용해서 구현이 되어 있습니다.
시간이 얼마 안 남아서 빠르게 진행하도록 하겠습니다. 그다음에 랜더마이즈 테스팅이라는 건데 보시면 테스트코드를 작성하다 보면 "이거 정말 모든 경우에 다 되는 걸까? 모든 걸 테스트한 건가?" 이런 의문이 들 때가 있어요.
모든 경우, 모든 경우. 모든 경우는 뭘까?
사람이 모든 경우를 다 테스트해볼 수는 없어요, 수동으로.
그래서 어떤 식으로 생각을 해보게 되냐 하면 어떤 function을 약간 blackbox처럼 생각을 한 다음에 여기에 랜덤한 인풋이 들어가요.
여기서 나온 리턴 값이나 수행해야 할 동작을 정의를 해서 여기에 대한 테스트를 하는 겁니다.
예를 들어서 어떤 인풋이 들어와도 이 함수에서는 에러가 나면 안 돼.
예를 들어서 어떤 인풋이 들어와도 이 함수에서는 0 이상의 값이 나와야 돼. 이런 식르테스트하는 걸 말하고요.
이 랜더마이즈 테스팅을 한 것 중에 가장 유명한 게 QuickCheck이라는 라이브러리인데 이게 약간 랜더마이즈 테스팅의 아버지 느낌이고 이거를 다른 언어에서 영감을 얻어서 구현을 했고요.
그래서 파이썬에서는 hypothesis라는 걸 쓰면 됩니다.
그래서 어떻게 쓰냐 하면 오른쪽 테스트코드부터 보시면 오른쪽에 테스트 베이직 스퀘어 해서 뭔가 제곱하는 테스트코드가 있어요.
그런데 보시면 v를 받아서 v 곱하기 v가 0 이상이래요. v는 위에 보시면 Given으로 정의가 되어 있는데 임의의 실수가 들어가요.
뭔가 수학을 잠깐 떠올려보시면 임의의 실수는 0 이상이잖아요.
이런 식으로 0 이상이기 때문에 이런 식으로 혹시 0 이상이 안 되는 실수가 있나 하고 테스트를 해볼 수 있고.
밑에는 조금 더 어려운 제곱근인데 어떤 양의 실수를 루트를 씌우면 뭔가 양의 실수가 나올 수 있죠.
그래서 저런 식으로 v가 들어가 있는데 임의의 실수인데 민 밸류가 0이다, 이런 식으로 해서 테스트를 구현할 수 있습니다.
그래서 Given을 보게 되면 Given은 테스트펑션은 어떤 랜덤한 인풋을 갖도록 만들어진 데코레이터이고 그 안에 어떤 인풋이 들어갈지는 스트레이지스로 정의할 수 있습니다.
그래서 이게 실제로 어떻게 동작하는지 보시면 제곱하면 0보다 크다. 실수를 제곱하니 0보다 크다는 테스트가 있어요.
0 곱하기 0은 0이니까 0보다 크지 않죠.
그래서 이걸 돌리면 왠지 v는 0이라는 걸 찾아줘야 될 것 같아요.
그래서 오른쪽에 돌리면 실제로 찾았으니까 v는 0.0 해서 v는 0일 때 이게 만족하지 않는다. 이런 식으로 되어 있고.
이거를 만약에 너가 다시 이 결과를 보고 싶으면 저 데코레이터를 붙이면 된다. 어쩌고저쩌고, 이런 식으로 설명을 하고 있습니다.
그래서 이게 실제로 언제 쓰이냐고 하면 이것도 저희 회사 코드에서 가져온 건데 저희는 이제 예를 들어서 나이를 예측하는 머신러닝 모델이 있다고 해요. 나이를 예측했으면 나이는 0에서 100 사이가 대충 나와야겠죠. 100보다 더 클 수는 있는데 일단 100으로 했다고 하면.
그래서 그거를 테스트하는 건데 보시면 밑에 것부터 보시면 테스트 랜덤 레코드 해서 Given, 여기 들어가는 건 뭔가 리스트인데 그 안에 들어갈 엘리먼트는 저거를 만족하는 엘리먼트이고.
레코드 스트레지는 어떤 딕셔너리인데 이 딕셔너리는 팩터스에서 하나씩 가져와서 이런 식으로 안에 들어가야 할 인풋을 자세하게 정의를 해서 테스트를 진행을 할 수 있습니다.
그래서 이런 식으로 넣고 어설트, 에이지는 0에서 100 사이다, 이렇게 테스트를 할 수 있고요.
그래서 만약에 이걸 만족하지 않는 어떤 인풋을 찾으면 얘가 찾았다고 알려주게 됩니다.
빠르게 하겠습니다.
그래서 그다음은 좀 벤치마크 테스팅에 대해서 보겠는데요. 많이들 들어보셨을 텐데 예를 들어서 "이거 잘 동작은 하는 것 같은데 너무 오래 걸리는 것 같아요." 이런 이야기를 들을 때가 있어요.
그래서 이거를 이런 걸 테스트하기 위해서 벤치마크 테스트를 주로 수행을 하는데 함수를 수행하는 데 걸리는 시간을 측정하는 테스트이고 이걸 하면 1초에 몇 개의 요청을 처리할 수 있는지에 대한 근사를 할 수 있고 그래서 다수가 사용하는 실서비스 환경에서는 반드시 써야 된다.
이거를 어떻게 하냐 하면 보통 타임잇, 이런 라이브러리를 이용해서 수동으로 측정할 수도 있어요.
그래서 벤치마크테스트를 보통 이런 식으로 짜죠. 그래서 스타트 타임 처음에 재고 썸 롱태스크를 한 다음에 앤드 타임, 0.5보다 작다.
이런 식으로 할 수 있는데 pytest 벤치마크 툴을 이용해서 작성하실 수도 있습니다.
그래서 썸 롱태스크가 있고 저 밑에 벤치마크라는 파라미터가 들어오게 돼요. 그래서 저기에 펑션만 씌워서 하면 되고요.
그래서 이거를 돌리게 되면 오른쪽에 나오죠.
오른쪽에 테스트 결과인데 다 비슷한데 뭔가 밑에 벤치마크에서 태스크롱이 미니멈 몇 초, 맥스 몇 초, 평균 어떻게 얼마나 걸리는지 테스트를 해줍니다.
그래서 사용하는 방법은 앞에서 보셨듯이 벤치마크를 감싸주기만 하면 되고요. 그 밑에 옵션 조정 가능하고 데코레이팅 이용해서 가능하고.
벤치마크 결과를 세이브했다가 로직 바꾸고 비교하는 것도 가능합니다.
그걸로는 조금 부족하실 수 있어요. 그래서 어디서 많이 걸리는 건지를 보시고 싶을 때가 있는데 그럴 때 프로파일러를 많이 붙여서 하실 수 있는데 pytest 프로파일링 툴을 사용하면 이런 식으로 함수별로 익스큐션 그래프랑 실행시간을 보여주게 됩니다. 이런 걸 보면서 디버깅을 쉽게 하실 수 있고
그리고 만약에 서버가 많은데 하고 싶다고 하면 저런 툴을 쓰시면 됩니다. locust.io 같은.
제가 간단하게 pytest 플러그인을 만들던 걸 소개를 해드리면 예전에 제가 go라는 걸로 코드를 짤 때 이런 게 있었어요. 로직을 바뀌면 실시간으로 코드가 바뀌면 테스트가 성공했다. 실패했다. 이런 결과를 바로 바로 뿌려주는 툴이 있었는데 이거를 보면서 하니까 재미있더라고요. 초록색이 됐다가 빨간색이 됐다가 실시간으로 볼 수 있어서 굉장히 재미있어서 이게 파이썬으로는 없을까? 했는데 없더라고요.
그래서 이런 거를 하나 만들어보면 좋지 않을까 싶어서.
아, 그리고 goconvey에서 이런 식으로 쓰게 됐는데 유저가 정상적으로 가입하고 맞는 아이디와 비밀번호로 로그인하면 로그인이 성공해야 한다. 이런 식으로 구조화 해서 작성할 수 있더라고요.
이런 걸 해보면 좋지 않을까 싶어서 몇 달쯤 이런 거를 시도를 하고 있었는데 아직 다 못 만들어서 이번에는 다음 파이콘 때까지 만들어서 제출을 해서 소개드리도록 하겠습니다.
그래서 이런 걸 만들 때 제가 pytest 플러그인 이런 걸 써서 했는데 처음에 코드변경되는 걸 감지해야 되는데 파일워쳐를 써야 되는데 파이테스트워치라는 걸 썼고요. 이것만 써도 충분하세요. 코드가 바뀌었을 때 테스트를 돌려주고 싶다고 했을 때 이걸 쓰면 사고
되고.
그다음에 이거를 이런 플러그인을 같이 붙여서 했고, UI는 고컨베이를 그대로 썼고. 그래서 다음 파이콘까지 완성해서 보여드리도록 하겠습니다.
거의 정리가 됐는데요. 조금 빠르게 오기는 했지만 보시면 가장 중요한 건 테스트코드를 작성하기 어렵거나 재미가 없으면 작성을 못해요. 이게 가장 중요한데요. 그래서 결국 재미있게 간단하게 테스트코드를 쓸 수 있게 만드는 게 굉장히 중요하고 그래서 리팩토링을 하신다면 이제 탑다운 방식으로 코드를 작성을 해보세요. 그러면 이후에 나는 클라이언트만 구현을 하면 되고, 이런 식으로 돼서 일단 탑다운으로 작성해보시면 좋고요.
그 밑에 몇 가지 라이브러리를 소개드린 게 있는데 Sure나 BDD 이런 거를 쓰시면 좋을 것 같고.
그다음에 밑에 써놓은 이런 거 필요하실 때 사용하시면 좋을 것 같습니다.
제 발표는 여기까지고요. 저희 회사 홍보를 잠깐 하려고 했었는데, 저희 회사 분들이 진행하시는 톡들도 소개해드리겠습니다. 재미있어요. 찾아보시면 좋을 것 같고. 그 밑의 것도 재미있습니다. 그래서 딱 순서가 맞게 잘 되어 있어서 가셔서 보시면 재미있을 것 같습니다.
저희 회사도 당연히 채용을 하고 있어서 개발자나 머신러닝엔진 이런 분들. 의료, 금융, 게임 분야에서 인공지능 만들고 싶은 분들, 오시면 좋을 것 같습니다. 감사합니다.
(박수)
-(사회자) 발표해주신 발표자 분께 다시 한 번 박수드리도록 하겠습니다. 시간상 질문은 개인적으로 부탁드리겠습니다.
다음은 점심시간인데요. 점심시간 후에 다시 뵙도록 하겠습니다. 감사합니다.