https://youtu.be/uKWSFZbGtbk

*** Python Daemonize : 파이썬으로 악마를 만들어보자 - 이수호 ***
-(사회자) 곧 발표가 시작될 예정이니 자리에 앉아주시기 바랍니다.
안녕하세요? 이번 시간에는 이수호 님께서 파이썬으로 악마를 만들어보자 라는 제목으로 25분간 발표해주시겠습니다. 원활한 발표를 위해 질의응답은 발표 후 시간이 남으면 진행하도록 하겠습니다. 그럼 큰 박수 부탁드립니다.
(영어 통역 중)
(박수)
-(발표자) 네, 안녕하세요? 방금 소개받은 이수호라고 합니다. 오늘 이렇게 마지막 자리에 여러분이 많이 와주셔서 감사드리고 이제 파이콘이라는 대장정의 막을 제가 내리게 돼서 굉장히 영광스럽습니다.
파이썬으로 악마를 만들어보자라는 주제로 발표를 시작하도록 하겠습니다.
일단 가볍게 스몰토크를 하자면 저고요. 저 맞아요. 이게 지금 얼굴이 좀 많이 바뀌었는데 이게 얼마 안 됐거든요.
그래서 저는 헛짓거리 하는 거 되게 좋아하거든요. 주제도 봤듯이 "어, 파이썬으로 뭘 이런 걸 해?" 이런 것들 되게 많이 했어요. 그래서 삽질이라든가.
그래서 주로 하던 게 학부 때나 많이 할만한 거 있잖아요. 커널로드 만들기 이런 것들. 시간많이 남을 때 하는 거, 그런 거 위주로 했었고요.
이제 백엔드 프로그래머를 주니어로 시작을 하게 되었습니다.
그런데 이제 여러분들 중에 여기 오신 분들 중에 딱 제목 보고서 이렇게 생각하고 오신 분들이 많을 거예요.
"왜 그런 걸 해요?" 하면서 오신 분들 많을 것 같아요. 대답을 드리면 할 수 있으니까 한 거겠죠. 하는 데 이유가 있겠어요? 그냥 하는 거지, 뭐.
그래서 지금 대학을 재학 중이고요. 레코벨이라는 스타트업 회사에서 인턴으로 지내고 있습니다. 그런데 자바 쓰고 있어요. (웃음)
자바 처음 써봐요, 그런데. (웃음)
하라면 해야죠, 뭐. 어떻게 해. 해야지.
그래서 오늘 할 거는 제목이랑 다르게 강령술은 아니고 데몬 만들기인데 이거랑은 관련없어요. 데몬이라는 시스템, 프로그래밍적 관점에서 데몬이라고 하면 그런 것들에 대해서 만드는 것을 오늘 해볼까 해요.
시작은 이렇게 인덱스가 이렇게 만들어졌는데요.
처음에 데몬을 많이들 알고 계실 거지만 혹시 모르실까 봐 데몬이 뭐하는 건지 좀 알아보고 그리고 데몬이 어디서 많이 쓰이는지 이런 것들에 대해서 간단히 짚고 넘어간 다음에 원리, 어떻게 하면 데몬이 되는지
그리고 실제로 데몬을 만들 수 있는 모듈을 만들어보면서 이걸 이용해서 애플리케이션, 간단한 거를 만들어보고 실제로 제가 만들었던 프로그램을 응용예제로 보여주도록 하겠습니다.
데몬이라는 무엇인가를 알아봐야겠죠. 데몬에는 여러 가지 정의들이 있잖아요. 악마라든가 데몬툴즈, 이런 것들 되게 많죠.
그런데 사실 저희가 볼 거는 시스템 프로그래밍에서의 데몬이에요. 이거는 사용자가 직접적으로 제어하지 않고 백그라운드에서 혼자 돌아가는 거예요. 여러분들 중에 그런 거 많이 써봤을 거예요. 우분투 사용자라면 언에이블, 스타트, 리스타트, 서비스네임 해서 돌리는 거 있잖아요. 그런 것들이 대부분 데몬으로 백그라운드에서 뭔가가 돌아가고 있고 실행이 되면 그게 무언가 작업하는 그런 형태예요.
그래서 엔진엑스라든가 도커D 써있는 거 있잖아요. 그 D가 데몬의 D거든요. 그래서 도커라든지 엔진X라든지 이런 것들에서 백그라운드에서 돌아가면서 이벤트가 발생하거나 시스템적으로 변화가 일어났을 때 그때 작업할 만한 그런 것들을 대부분 데몬으로 만들어서 돌리고는 합니다.
그래서 데몬은 그래서 어떻게 되는가. 그걸 설명을 하자면 데몬이 부모 프로세스가 init 프로세스여야 해요. 처음 실행되는 프로세스겠죠. 안 배우신 분들을 위해서 간단하게 설명하자면 운영체제가 실행이 되면 가장 먼저 init이라는 것이 실행이 돼요. 그러면서 얘가 자식 프로세스를 낳아가면서 분열을 하면서 운영체제가 올라오는 형태고요.
그 부모 프로세스에 바로 밑에 자식으로 들어와 있어야 되고 자신이 세션리더여야 해요.
그러면서 연결된 터미널이나 입축력 디스크립터가 없어야 해요. 즉 사용자가 제어할 수 있으면 안 된다는 거예요. 터미널이 있어서 출력이 보이거나 이러면 이건 데몬이 아니에요.
이걸 두 개를 만족하면 일단 데몬이라고 부를 수 있어요. 왜 일단 데몬이냐. 이 두 개만 한다고 그냥 두 개만 있으면 좀비잖아요. 뒤에 살아있잖아요.
살아있기만 한 거잖아요. 그러면 무슨 의미가 있어요?
얘는 일을 해야지, 일하라고 있는 건데.
그래서 오늘은 이걸 데몬을 만들고 그리고 실제로 그 일하는 것들을 어떻게 붙일 수 있는지까지 보여주고 끝내려고 합니다.
그래서 이 데몬이 되는 과정이 간단하게 네 가지 절차를 거쳐서 되는데요. 이것들을 실제로 코드를 하나하나 보면서 어떻게 만들어지는지를 알아보고자 합니다.
데몬모듈에 대해서 설명을 할게요.
가장 먼저 포크를 이용해서 프로세스를 복제를 해야 돼요. 포크는 들어보신 분들도 당연히 있겠지만 포크는 자신을 복제하는 거예요. 자기프로세스를 복제해서 자신의 자식 프로세스로 만들어줘요. 그러면 이제 두 개가 똑같은 일을 하는 거죠. 똑같은 애인데 프로세스 ID와 이런 것들은 다 다른 거예요.
자식으로 만들어진 프로세스는 부모 프로세스의 프로세스 ID를 세션ID와 그룹ID로 가지게 되죠.
이걸 이용해서 자식 프로세스를 만들어요. 그러면 그 자식 프로세스는 그걸 이용해서 하는 건데요.
이걸 하기 위해서 os.fork라고 파이썬에 os 많이 써보셨을 건데 이거는 시스템 펑션 같은 거를 호출하는 데 쓰는 모듈이잖아요.
이걸 사용해서 프로세스를 낳으면 부모 프로세스 쪽에서는 자식 프로세스의 프로세스 ID를 가져요.
그리고 자식 프로세스는 0을 가져요.
그래서 이렇게 하면 얘는 0를 가지고 있는 거고요. 얘는 얘의 프로세스 ID를 가지게 되겠죠.
그래서 그다음에는 이제 부모 프로세스를 자체적으로 강제종료를 해야 돼요, 자기를.
왜냐하면 이제 자기 부모 프로세스가 위에 올라와 있으면 자식 프로세스가 위로 올라갈 수가 없거든요. 그래서 이거를 하기 위해서 어떻게 하느냐.
밑에 프로세스 ID가 0보다 큰 경우. 아까 앞에서 말했듯이 프로세스 ID는 무조건 1 이상이거든요. 왜냐하면 init 프로세스가 1부터 시작하거든요.
그러면 당연히 pid는, 그러니까 정상적인 프로세스 ID라면 1 이상을 가질 거고 그렇기 때문에 pid가 0보다 큰 경우에는 부모 프로세스예요. 왜냐하면 자식 프로세스의 프로세스 ID를 가지고 있기 때문에.
하지만 프로세스 ID가 0인 경우, 그러니까 자식 프로세스인 경우는 그냥 가만히 있는 거예요. 그러면 1 이상인 경우에는 자체종료를 해버리고 그리고 자식 프로세스, 그러니까 0인 경우에는 이 프로그램이 계속 진행이 되겠죠.
그러면 이제 부모 프로세스가 없어졌으니까 이제 자기는 자기를 담당해줄 프로세스가 없어졌어요.
그래서 자기를 init 프로세스한테 넘길 수가 있죠. 그래서 자기를 넘기기 위해서 자기를 리더로 하는 프로세스 세션과 그룹을 생성을 해서 자기를 init 프로세스의 자식 프로세스로 입양을 가요.
말이 좀 이상한데 어쨌든.
그래서 os.chdir. 이거는 많이 써보셨을 건데 체인지디렉터리죠. 이걸 이용해서 루트 디렉터리로 작업을 옮겨줘야 돼요. 왜냐하면 프로세스가 어디서 실행될지 모르잖아요.
예를 들면 제가 USB 꽂은 다음에 그 안에 있는 프로그램을 실행시킬 겸, 예를 들어서 그 안에 데몬 서비스가 있어요. 이걸 실행시키는 경우도 있고 아니면 다른 마운트된 디바이스에서도 실행시킬 수 있잖아요.
그렇기 때문에 그거를 통일해줘야 돼요. 이걸 통일해서 자기가 어디든 접근할 수 있도록.
왜냐하면 데몬이면 시스템 감시를 당연히 해야 되는 거니까 루트를 작업공간을 가지고요.
보면 여기 해당 파일시스템이 언마운트 불가능한 상황을 막기 위한 거라고 했는데 USB를 꽂은 다음에 실행을 시킬 경우에 내가 이걸 뽑고 싶어요. 그런데 프로세스가 얘를 잡고 있기 때문에 마운트가 불가능한 경우가 발생을 해요. 그런 경우가 있어서는 안 되겠죠.
그렇기 때문에 이런 여러 가지 문제들을 막기 위해서 디렉터리를 변경해줘야 돼요.
그다음에 세션ID를 등록을 해야 되는데 이거는 그냥 호출하는 경우에 자기가 세션리더가 아니잖아요. 그러면 이걸 호출하는 애가 해당세션의 리더가 돼요. 그러면 동시에 tty에 대한 제어권한을 잃어요. 이게 무슨 소리냐 하면 자기를 사용자가 제어할 만한 터미널이 없어진다는 거예요. 그러면 입력도 출력도 받지 않고 어떤 것도 받지 않는 독립적인 프로세스가 되는 거죠.
왜냐하면 외부적 요소가 없어지는 거니까.
이 과정을 거쳐서 init 프로세스에 입양되는 그런 과정이고요. 이렇게까지 하면 자식 프로세스가 init 프로세스에 입양이 되어집니다.
그래서 umask. 이거는 리눅스 시스템을 써보셨던 분이라면 익숙하실 텐데요. 이거 같은 경우는 파일을 새로 생성할 때 커미션을 지정을 해줘요. 그런데 왜 0으로 하느냐. 그거는 만약에 이게 프로세스가 실행되면 이게 만들었는데 다른 사용자가 수정을 할 수 없으면 이 프로세스가 실행이 됐는지 아닌지 알 수가 없잖아요.
왜냐하면 pid 파일이라는 걸 만들어서 이 프로세스가 실행이 되었는지, 실행이 되었다면 프로세스id는 무엇인지, 지금 무슨 작업을 하고 있는지를 기록을 할 건데 그런 것들을 다른 프로세스에서 읽을 수가 없으면 문제가 생길 거란 말이에요.
그렇기 때문에 umask를 이용해서 제로를 만들어주면 777 권한이 생기게 돼요. 그렇게 해서 pid 만들고 다중 프로세스 실행방지를 할 거예요.
마지막으로 소유하고 있는, 자기가 가지고 있는 입출력 디스크립터를 해제해야 돼요. 얘는 어떤 입 력도 가지면 안 되고 어떠한 출력도 나가면 안 된다고 했잖아요.
그리고 어떤 파일도 잡고 있으면 안 돼요. 왜냐하면 백그라운드에서 돌아가고 있는데 그 파일을 얘가 무슨 파일을 잡고 있을지 모르는 경우가 있잖아요.
그러면 이제 "어, 이거 왜 삭제, 수정이 안 되지?" 이런 상황이 발생할 수 있단 말이에요.
그렇기 때문에 얘가 데몬이 되기 전에 모든 입출력 디스크립터를 다 해제해줘야 돼요.
그런데 사실 C에서 데몬을 만들어보신 분들이 여기에 오셨을까요? 오셨을지 모르겠는데 만들어보셨으면 아시겠지만 dup2를 이용해서 디스크립터를 받죠. 그런데 C나 로우레벨, 아예 시스템콜을 직접 호출할 수 있는 언어들에서는 디스크립터 0, 1, 2를 해제해요, 그냥. 왜냐하면 그걸 리다이렉트를 하죠.
왜 그렇게 하냐 하면 순서대로 스탠다드 인풋, 아웃풋, 에어 이렇게 불러와지고 그다음부터 내가 파일을 읽었다.
예를 들면 파이썬 같은 경우는 오픈 해서 뭐 파일을 열었다.
그러면 이제 거기부터는 디스크립터 3번, 또 열면 4번 이렇게 가는 거거든요.
그런데 파이썬에서는 왠지 모르겠는데 0, 1, 2를 리다이렉트 시키면 에러가 나요.
그거는 저도 좀 알아보고 있었는데 오늘 발표까지 알아내지는 못했고요. (웃음)
어쨌든 그래서 방법이 이렇게 하는 것밖에 없어요. 보시면 devnull이라고 갖다버리는 곳으로 리다이렉트를 해줘요. 등록을 해주는데 왜 굳이 세 개 만드느냐. 하나 만든 다음에 다 하면 안 되냐. 그렇게 하면 이게 보시면 첫 번째를 두 번째에 복제를 하고 가능하면 닫아요.
그렇기 때문에 앞에 보시면 이 뒤에 있는 게 닫혀요.
그렇기 때문에 이거를 세 개를 생성해서 세 개 다 리다이렉트를 해주는 거고요.
이 뒤에 보시면 atexit가 있어요. 이건 이름부터 알기가 쉽죠. 하는 일이.
프로세스가 종료될 때 자기가 받은 메소드를 실행시켜요. 이 프로세스가 종료되면 이걸 실행시키고 줘요.
죽어요.
그래서 마지막으로 이제 이 부분이 아까부터 말씀드리는 pid 파일인데요. 자신의 프로세스 ID를 가져다가 다시 디스크립터를 열어서 pid를 쓰고 다시 닫죠. 이렇게 해서 기존에 실행되어있는 데몬을 제어하는 거예요. 이걸 이용해서.
그래서 전체코드는 여기 있고요. 이거는 나중에 따로 PPT 올라와 있으니까 그거 보시면 참고하시면 될 것 같아요.
그래서 이걸 모듈을 만든다고 했잖아요. 이거 그래서 모듈을 어떻게 만드느냐.
스타트 부분. 이제 프로세스 ID, 그러니까 pid파일에 있는 프로세스 ID를 불러와요. 그다음에 데몬이 이미 실행되어 있는지 아닌지 검사를 해요. 똑같은 데몬이 두 개 실행되어 있으면 안 되잖아요. 그래서 이거를 검사를 하고 뭐 지금 이 파일 보면 "어, 그런데 프로세스 ID는 딱히 하는 게 없는데요?" 그렇죠? 원래 코드는 그런 건데 실제로 실행되어 있는지 없는지 검사하려면 이런 걸 쓰면 돼요.
이런 걸 실행시키고 받아와서 이제 검사를 하면 되는데 거기까지는 제가 안 넣었어요. 굳이 그렇게까지 할 필요가 있나 싶어서.
그래서 위에 있는 셀프 데모나이즈가 앞에서 열심히 설명했던 부모 프로세스가 자식 프로세스 만들고 그런 과정들이 이 함수고요.
이제 이 셀프런. 이 클래스를 상속받은 다른 클래스가 다시 재정의해줄 거예요. 그러면 이 위에 있는 프로세스가 런, 밑에 있는 거를 실행시키겠죠.
실제 애플리케이션을 따로 정리를 해주면 그렇게 분석을 할 겁니다.
그래서 스톱 같은 경우는 만약에 pid가 없을 경우에 pid를 그냥 삭제해버리고, 파일이 존재하지 않으면, 데몬이 실행되지 않았으니까 이 프로세스는 살아있을 이유가 없잖아요.
왜냐하면 지금 얘를 기존에 살아있는 데몬을 끝내려고 이 명령어를 실행시키는데 그렇기 때문에 여기 보시면 pid가 없으면 종료를 해요. 자기가 그냥 알아서 꺼지는 거고. 만약에 pid가 있으면 이제 명령어를 이용해서 프로세스가 종료가 될 때까지 계속 요청을 하죠.
그래서 프로세스를 끝내는 그런 형식괴요.
전체코드는 여기 있어요. 그래서 이걸 다 포함해서 이제 앞에서 말씀드렸던 데몬 모듈이 되는 거고요.
이거를 이제 이용을 해서 애플리케이션을 직접 만들어봐야겠죠.
그래서 이거를 실제로 만들어보는 부분이 여기 있는데요.
이거를 조금 만들어봤어요. 간단한 데모이기는 한데 앞에서 만들었던 모듈파이, 이게 이거고요.
그리고 이거를 상속받아서 데모파이라는 앱을 만들었어요.
이렇게 생겼죠. 잘 보시면 헬로텍스트를 만들고 10번 써요. 백그라운드에서. 그러고 끝나는 프로세스예요. 되게 간단하죠.
그래서 잘 보시면 여기 보셔야 될 부분이 데몬 아까 앞에서 만들었던 거를 상속받아서 이걸 하고, 데몬 스타트를 호출을 하면 지정된 런이 호출이 되겠죠.
그래서 실제로 10번의 출력이 있는 걸 확인할 수가 있어요.
응용예제를 간단하게 빠르게, 얼마 안 남아서 빠르게 빠르게 넘어갈게요.
비트로커 다들 들어보셨을 수도 있는데 비트로커는 윈도우에서 사용하는 드라이브 암호화 저거예요.
이게 리눅스에서 쓰려면 디스로커라는 걸 써야 돼요.
이게 암호화를 풀어주는 프로그램인데 이게 진짜 쓰기는 어려워요. USB드라이브 이름, 위치, 명령어 다 알아야 되고 되게 많은데 이거를 한번 쉽게 써보자.
GUI로 쉽고 써보고 싶어서 이걸 만들게 됐어요. 영상을 간단히 살펴볼게요.
보시면 명령어가 나오죠. 그래서 GUI로커를 다시 실행시키고 끈 다음에 USB를 꼽잖아요. 그러면 USB가 꽂히면서 GUI가 나와요. 암호를 입력하는 거죠. 입력하면 마운트가 돼요. 실제로 마운트가 되고.
그다음에 이거를 언마운트를 해야겠죠. 실제 실행되어 있는 명령을 날리는 거예요. 언마운트 하면 언마운트가 되면서 사라졌죠.
지금 이거 뒤처리를 안 해놔서 이렇게 되는데, 이렇게 이런 프로그램이고요.
그래서 이게 디스크가 연결된 거를 어떻게 확인하냐. 이런 파티션즈라는 파일이 있어요.
여기는 연결된 파티션들을 관리하는 파일인데요. 마운트 되지 않아도 여기에 다 떠요. 무슨 디바이스가 연결이 됐는지.
그래서 백그라운드에서 얘를 감시하고 있다가 새로운 디바이스가 연결됐으면 GUI를 끼우는 거죠.
그런 프로그램이고 뒤에 있는 거는 앞에서 보던 것처럼 이렇게 정리를 하면 여기서 호출을 하는, 그렇게 간단하게 구성이 되어 있습니다. 여기까지 데몬을 만들어보자, 발표였고요.
다들 늦게까지 참가해주셔서 감사합니다.
(박수)
-(사회자) 발표를 해주신 이수호 님, 감사드립니다. 지금부터 질의응답 시간을 가지려고 하는데 시간이 얼마 없어서 간단한 질문 한두 개 정도만 받으려고 하고요.
원활한 질의응답을 위해서 질문은 짧게 부탁드립니다. 그래야 발표자 님께서도 질문 내용을 쉽게 기억하고 답변해주실 수 있으니 양해 부탁드립니다.
그리고 저희가 16시 40분부터 앞으로 21분쯤 뒤부터 103호에서 라이트닝토크가 있을 예정입
니다. 참여를 원하시는 분들께서 참고가 되기를 바랍니다. 질문 시작하겠습니다.
-(질문) 혹시 윈도우에서도 데몬을 구현할 수 있는 그런 라이브러리나 구현해보신 경험이 있으신지.
-(발표자) 윈도우에서는 라이브러리는 잘 모르겠어요. 그런데 만들어본 적은 있거든요. 크게 다르지 않아요.
그 이유가 기본적으로 프로세스가 실행되고 그리고 기본적인 OS 기초는 둘 다 동일하기 때문에 크게 되지는 않은데 세세한 부분에서 조금 씩 달라요.
그래서 만약에 실제로 이거를 윈도우 환경에서 구현하고 싶다 하시면 윈도우는 아예 서비스를 만드는 게 있는 걸로 알아요. 그거를 알아보시는 게 좋을 것 같고, 만약에 이런 방식으로 데몬을 만들어보고 싶다면 윈도우즈에서 해보시면 이거랑 크게 다르지 않게 개념은 이해하셨다면 크게 다르지 않게 쉽게 만드실 수 있을 거라고 생각을 합니다.
-(질문) 감사합니다.
-(질문) 강의 잘 들었습니다. 질문드릴 게 있는데요. 만약에 생성하신 데몬 프로세스가 프로그램 진행을 하다가 데몬 프로세스가 죽는 경우가 있을 때 이런 경우에는 어떻게 처리를 하셨는지 경험이 있으시다면.
-(발표자) 데몬 프로세스가 죽었을 경우에는 두 가지로 처리했는데요. 얘가 바로 살아나야 되는 경우에는 다시 살리는 그 데몬 프로세스를 아예 하나 만드는 경우가 있었고.
아니면 얘가 굳이 바로 바로 살아날 필요가 없는 경우에는 탭에 등록을 해놓고 그냥 일정 주기마다 살아있는지 아닌지 검사를 해보고 죽었으면 살리고 이런 식으로 해결을 했던 것 같아요.
-(질문) 그러면 프로세스가 죽었는지 살았는지를 항시 체크를 했다가 계속 살려야 되는 게 있다면 그 친구를 살리고 그런 식으로 했다는 건가요?
-(발표자) 네네, 그러니까 무조건 계속 살아야 되는 경우는 걔만 감시하는 프로세스를 아예 따로 만들었죠.
-(질문) 알겠습니다. 감사합니다.
-(질문) 발표 잘 들었습니다. 백그라운드에서 돌아가는 프로세스를 구현하고 있는데 저 같은 경우는 개발하고 있는 프로그램이 지정된 시간에 동작을 하게끔 하는데 그걸 돌렸을 때 거기에서 백그라운드로 뭔가를 또 돌려주는 걸 하고 있어요.
그런데 여기서도 계속해서 백그라운드상에서 프로그램이 돌아가고 있는 건 알겠는데 만약에 특정 조건일 때 데몬을 실행할 수 있는 방법이 따로 있는지 알고 싶습니다.
-(발표자) 그거는 여기서 설명하지 않은 게 있어요.
프로세스를 실행하는 명령어들이 따로 있어요.
예를 들어서 포크를 해서 아니면 엑시스라고 있는데 이걸 이용해서 자기 프로세스를 프로그램을 실행시켜서 바꿔치기를 하거나 런을 하거나 자기 자식 프로세스를 만들면서 런을 하거나 여러 가지 방법들이 있거든요. 그런 경우는 이런 식으로 해야겠죠. 데몬을 하나 만든 다음에, 얘는 스케줄러이고 기능들을 추가해놓으면 일정 시간이 될 때마다 이 프로세스를 실행시키는 거예요.
그리고 워커들이 일을 하고. 그런 식으로 작업을 하면 아마 말씀하신 게 될 거예요. 스케줄 체크만 하고, 메인데몬은.
-(질문) 아, 그러니까 태스크라고 지금 개념을 부르고 있었는데 그게 아니라 프로세스가 계속 실행이 된다고 보면 되겠네요? 저희가 원하는 것에 대해서.
-(발표자) 원하시는 게... 제가 잘 안 들려서 혹시 조금 더 크게...
-(질문) 그러니까 그냥 용어가 샐러리로 생성할 때 저는 태스크라고 불렀는데 그게 아니라 프로세스를 실행하면 되겠네요?
-(발표자) 아, 네 알겠습니다. 태스크, 그러니까 프로세스가 그러니까 작업을 수행하기 위한 프로세스가 되는 거겠죠.
그거를 그냥 수행시키면 시스템콜들이 있어요. 여러 가지가 있는데 자식을 바로 만드는 프로세스 콜도 있고 아니면 복제를 해서 걔를 갈아치우는 것도 있고.
또 왜 이게 여러 가지가 많냐 하면 그것도 사용방법에 따라서 종류가 다르거든요. 내가 이 디스크립터를 상속받는지 아닌지 복잡한 이야기가 있거든요.
그런 것들에 따라서 자기가 원하는 게 뭔지 정확히 알고 그거를 적용하시면 원하시는 거를 할 수 있을 거예요.
-(질문) 네, 알겠습니다. 감사합니다.
-(사회자) 발표시간이 종료되어 세션을 마무리하도록 하겠습니다. 지금까지 발표해주신 이수호 님께 큰 박수 부탁 드립니다.
(박수)