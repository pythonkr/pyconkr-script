https://youtu.be/NEpVvBGPhLU

-(사회자) : 곧 발표가 시작될 예정이니 빈자리에 앉아주시기 바랍니다.

곧 발표가 시작됩니다.

안녕하세요. 이번 시간에는 김성현 님께서 리얼월드 메타클래스라는 제목으로 25분간 발표해 주시겠습니다.

원활한 발표를 위해 질의응답은 발표 후 시간이 남으면 진행하도록 하겠습니다.

그럼 큰 박수 부탁드립니다.

-(박수)

-(김성현) : 안녕하세요.

리얼월드 메타클래스라는 제목으로 발표하게 된 김성현이라고 합니다.

-(박수)

간단하게 제 소개를 하고 넘어가자면 저는 지금 마이뮤직 테이스티라는 곳에서 백엔드를 개발하고 있고 asyncio를 즐겨 사용하는 중입니다.

클린코드를 만들려고 노력하고 있는 개발자 중에 한 명입니다. 

일단 오늘 발표할 주제는 다음과 같습니다. 

메타클래스가 무엇인지 알아보고, 파이썬에서 구체적으로 무슨 역할을 하고, 어떻게 활용할 수 있으며, 이미 어떻게 활용되고 있는지 알아볼 것입니다.

참고로 이 내용은 정리되어 있고 블로그 포스트 그다음에 소스코드는 깃허브를 통해 공개되고 있습니다.

일단 제가 이 발표주제는 고른 이유는 많은 사람들이 메타클래스에 대해서 모르고 이름은 들어봤는데 무섭다고 하면서 잘 모르시는 분들이 있을 거라고 생각합니다.

저는 그런 분들을 위해 메타클래스가 무엇인지 그리고 왜 필요한지 설명 드리겠습니다.

일단 메타클래스를 알아보기 위해서는 파이썬 핵심인 데이터모델에 대해서 알아봐야 합니다.

파이썬에서 모든 것은 데이터를 추상화한 객체로 이루어져 있습니다.

객체로 이루어져 있다면 파이썬은 어떤 방식으로 객체를 추상화할까요? 

파이썬은 데이터를 아이덴티티와 값 타입으로 나눕니다.

아이덴티티란 객체의 수명 또는 유일하고 불변한 정수이며 아이덴티티를 통해서 얻을 수 있는 값입니다.

사실상 이것의 주소를 나타내기도 합니다.

그리고 값은 말 그대로 객체가 가지는 값으로 객체의 타입에 따라 불변할 수도 있고 가변할수도 있습니다.

마지막으로 타입은 객체가 지원하는 연산 등을 정의하고 타입이 가질 수 있는 가능한 값들을 정의하면서 객체의 특성을 정의합니다.

객체의 타입은 보통 불변합니다.

메타클래스를 알아보기 위해서는 우리는 이 객체 중 타입에 집중해야 합니다.

파이썬에는 수많은 내장된 타입들이 있습니다.

int, str, bool 등 몇 가지의 타입들이 파이썬에 존재합니다.

파이 그리고 파이썬의 기본적인 타입을 가지는 객체들은 이 내장 타입들에 의해 정의됩니다.

하지만 우리는 파이썬 프로그램을 만들면서 대부분의 경우에는 기본적으로 제공하는 타입들이 우리가 만드는 프로그램의 비즈니스 로직을 추상화하기에는 부족하기 때문에 새로운 타입을 정의합니다.

클래스를 사용해서 말이죠.

우리는 클래스를 통해서 정의한 타입으로 새로운 객체를 정의할 수 있습니다.

간단히 말하자면 파이썬에서 모든 객체들은 어떠한 타입에 의하면 정의된다는 뜻이죠.

그런데 메타클래스가 도대체 무슨 상관이 있을까요, 이게? 맨 처음에 파이썬의 모든 것들은 객체로 이루어졌다는 것을 말씀드렸습니다.

모든 것이 객체로 이루어져있다, 모든 것이라면 어떤 것일까요?

파이썬에는 다음과 같이 적혀 있습니다.

폰 노이만의 프로그램 내장식 컴퓨터 모델을 따르고, 코드 역시 객체로 표현됩니다.

 
하지만 이 말은 어려운 뜻이 아닙니다.

우리가 짠 코드들은 변수, 함수, 그리고 클래스로 이루어져 있습니다.

즉, 코드로 이루는 모든 요소들이 객체라는 뜻입니다.

방금 보시면서 이해가 잘 안 되시는 분들도 계실겁니다.

많은 파이썬 가이드, 문서, 튜토리얼에서 언급하고 있는데 클래스가 객체라니 이해가 안 되는 게 보통 정상입니다.

다른 언어에서는 클래스는 객체를 생성하는 코드 조각, 바이트의 일부입니다.

일단 파이썬의 클래스가 객체인지 알아보기 위해서는 방법은 간단합니다.

앞에서 소개한 이 객체의 세 가지 조건을 만족한다면 클래스는 객체인 것을 입증할 수 있습니다.

아이덴티티, 값, 그리고 타입을 한번 확인해보도록 합시다.

일단 간단히 클래스를 하나 만들었습니다.

아무 것도 없는 빈 클래스입니다.

우리는 이 클래스가 아이덴티티를 통해 이 클래스 객체가 가지는 메모리 주소를 확인할 수 있습니다.

그리고 디아이알 함수를 통해 어트리뷰트를 가지고 옴으로써 클래스가 값을 가지는 것을 확인할 수 있습니다.

그렇습니다.

파이썬에서 클래스는 객체임을 확인할 수 있습니다.

왜냐하면 이 세 가지 요건을 모두 만족하기 때문입니다.

이해가 안 가시는 분들이 있을 겁니다.

객체는 타입을 가진다고 했습니다.

그리고 타입은 객체를 정의한다고 했습니다.

그런데 클래스에 타입이 있다니 이거는 타입을 정의하는 타입이 있다고 하는데 당연히 이상한 사실입니다.

하지만 이 이상한 존재가 바로 타입을 정의하는 타입이자 클래스를 인스턴스로 가지는 특별한 클래스, 이것이 바로 메타클래스입니다.

이번에는 한번 메타클래스라는 것이 정말로 클래스를 만들어낼 수 있는지 확인해보려고 합니다.

일단 파이썬의 메타클래스는 무엇인지 알아봐야겠죠.

친근한 타입 콘솔을 통해 확인해보면 이 클래스가 가지는 있는 타입은 타입입니다.



지킬앤하이드도 아니고 이 타입은 객체의 타입을 가져온 간단한 함수가 아니냐고 생각할 수 있지만 놀랍게도 타입의 문서를 보면 타입은 두 가지의 역할을 한다고 되어 있습니다.

타입이 한 개의 인자를 가지고 출현할 때는 인자가 주어진 객체 타입의 클래스를 가지고 오지만 새로운 타입을 돌려주는 것으로 동작합니다.

그리고 메타클래스를 사용하여 새 타입을 정의할 수 있습니다.

그리고 이것은 클래스 문을 사용하여 만드는 것과 완전히 동일하게 됩니다.

파트 B.

이제 메타클래스가 무엇인지 파이썬에서 메타클래스가 무엇인지 분명히 알게 되었습니다.

파이썬에서 모든 것은 객체이고 객체로 만든 타입 클래스도 객체이며 메타클래스는 기본적인 타입에 의해 정의된다는 것을 알 수 있었습니다.

그렇다면 파이썬은 어떻게 새로운 타입을 정의해서 타입을 정의할까요?

다음의 과정들을 통해 이루어집니다.

첫 번째로 MRO를 결정하고 적절한 메타클래스를 결정한 후 클래스 네임스페이스를 준비하고 네임스페이스 안에서 클래스 바디를 실행한 후 클래스 객체를 형성합니다.

클래스를 형성하고 각 단계를 따라 가보면 어떻게 메타클래스에서 클래스가 새롭게 정의하는지 알아보려고 합니다.

실행하면 먼저 파이썬은 알고리즘을 통해 메소드를 가져오는 순서인 Method Resolution Order를 구성합니다.

클래스를 정의하기 위한 것을 정의합니다.

이제 메타클래스가 결정되었습니다.

메타클래스가 결정되었으므로 파이썬은 언더바 언더바 어트리뷰트를 추출하여 메인 스페이스를 정의할 것입니다.

만약에 없다면 파이썬은 기본적인 딕셔너리를 사용할 것입니다.

이것은 맵핑을 만족하면 되기 때문에 이것들은 아무런 상관이 없습니다.

네임스페이스가 정의가 되었다면 파이썬은 exec를 실행하여 바디에 들어있는 함수 정의, 변수 할당 등을 수행하여 클래스 네임스페이스를 정의합니다.

마지막으로 파이썬은 클래스 객체를 완성하는데 일반적인 클래스가 인스턴스를 만들때처럼 파이썬은 언더바 언더바를 사용하여 메타클래스의 인스턴스인 클래스의 객체를 만들게 됩니다.

그리고 파이썬 3.6 이상에서 메타클래스는 객체를 생성할 때 디스크립터를 수집한 후 디스크립터 객체를 하기도 합니다.

파이썬은 코드를 읽은 후 네임스페이스를 정의하였고 네임스페이스에서 바디를 실행했고 그후 메타클래스의 언더바언더바를 사용하여 객체를 형성했습니다.

그러나 메타클래스는 이것 이외에도 한 가지 더 관여할 수 있습니다.

일반적으로 클래스 인스턴스를 콜라보하여 만들을 때 우리는 클래스에 언더바 언더바를 콜을 하게 되는데 그런데 이것은 어디에 쓰일까요?

메타클래스의 언더바 언더바 어콜은 인스턴스를 생성할 때 관여합니다.

메타클래스는 클래스 인스턴스 생성에도 관여하고 이것 또한 호출되게 합니다.

이제는 이제까지 알아본 메타클래스를 활용해볼 시간입니다.

앞선 내용에서는 메타클래스가 클래스 생성에 어떤 정도로 어떻게 관여하는지 알아보았습니다.

이제 우리는 앞선 내용을 가지고 메타클래스의 메소드들을 가지고 변경하여 몇 가지 흥미로운 파이썬의 기능들을 확인해볼 수 있습니다.

객체를 생성하는 언더바 언더바 뷰, 그리고 이것들을 집중적으로 변경해보면서 확인해 볼 생각입니다.

언더바 언더바 뷰의 클래스 메소드에 객체를 생성하는 것을 삽입하여 확인해볼수 있습니다.

대표적인 예로 클래스가 똑바로 생성이 되었는지 어트리뷰트를 가졌는지 확인하여 올바른 방식으로 만들어졌는지 체크해볼 수 있습니다.

첫 번째로 알아볼 검사는 상속을 통제하는 것입니다. 언더바 언더바 뒤에 인자는 튜플의 형태입니다.

이제 클래스를 생성하면 괄호를 치고 거기에 상속받을 클래스를 정의합니다.

이때 그 클래스들이 언더바 언더바 뒤에 인자로 들어오게 됩니다.

그리고 다종 상속 시에는 이 베이스 튜플에 두 개 이상의 클래스가 담기게 됩니다.

이를 이용하여 다중 상속을 금지하는 메타클래스를 만들어볼 수 있습니다.

디스얼로 메타클래스는 두 번째로 들어온 베이스 튜플의 길이를 체크하여 하나보다 크다면 이렇게 하고 그렇지 않다면 클래스 생성을 지속하는 그런 메타클래스입니다.

그리고 이것을 메타클래스로 정한 것을 이용해서 다중 상속을 허락하여 예외가 발생하게 됩니다.

정의했던 대로, 그리고 단순히 생각하는 상속을 금지하는 메타클래스 또한 만들어볼 수 있습니다.

이 메타클래스는 상속 받은 베이스 튜플을 검사하여 상속이 한 번 더 됐다면 예외로 발생시키는 메타클래스입니다.

또한 메타클래스로 어트리뷰트를 검증해볼 수 있는데요. 우리가 기대하는 대로 클래스가 작성되었는지 검증하기 위한 방법입니다.

이 코드는 장고(Django)의 모델입니다. 이 메타가 없다면 장고는 시작도 되지 않았습니다.

만약에 이 메타를 정의하지 않고 이것을 구현하면 에러가 있을 텐데 이거를 구현하기 위해 이 메타를 만들어봤습니다.

이 메타클래스는 네임스페이스에서 메타라는 항목이 정의가 되었는지 체크하고 이게 만약 첫 번째로 만들어진 엑스트라 클래스가 아니라면 이것을 발생시킵니다.

그리고 메타클래스를 사용해서 싱글톤 또한 구현할 수 있습니다. 싱글톤을 구현하는 방법은 파이썬에서 많은데요.

메타클래스를 사용하는 방법도 있는데 저희는 메타클래스를 사용하는 방법을 알아보려고 합니다.

아까 전에 말씀드렸다시피 언더바 언더바 콜은 메타클래스를 사용하여 만들어진 클래스입니다.

다음에는 한번만 생성된 객체를 돌려주도록 하는 코드를 작성해볼 예정입니다.

이렇게 클래스로 인스턴스를 두고 이 딕셔너리에서 클래스를 사용해 인스턴스를 계속해서 돌려주는 딕셔너리입니다.

이 값을 이용해서 만들어진 객체를 돌려주게 됩니다.

아까 전에 제작한 싱글톤이라는 메타클래스로 지정했습니다.

객체를 두 번 생성했는데요.

이 메타클래스로 만들어진 클래스의 객체들은 값이 일치하다는 것을 알 수 있습니다.

파트 B에서 언더바 언더바 뷰를 말할 때 그런 이야기를 잠깐 했었는데 먼저 디스크립터가 무엇인지 간단히 설명을 드리면 새로운 프로토콜입니다.

언더바 언더바 셋 네임은 3.6부터 나온 기능으로 그 이전 버전에는 디스크립터은 상당히 불편한 것이 었습니다.

일단 디스크립터에 대해서 간단히 설명을 드리면 덕지덕지 붙은 것이 아닌 장고 필드 모양을 하고 있고 그것을 구현해낸 일종의 것이기도 합니다.

조금 더 깔끔하게 코드를 작성할 수 있습니다.

그런데 3.5까지 아까 전처럼 네임이란 이름의 키로 네임스페이스를 지정해주어야만 했습니다.

하지만 이것은 별로 좋은 모양은 아닙니다.

왜냐하면 같은 내용이 두 번 들어가면 일종의 중복이니까요.

그래서 파이썬은 이 중복을 제거하기 위해 3.2부터 이 프로토콜을 추가하고 메타클래스가 이후로 잡은 트리거에 네임스페이스 가져올 네임키를 지정하게 줍니다.

네임이라는 항목을 쓰지 않고 디스크립터를 완성할 수 있게 되는 것이죠.

피이피 484가 새롭게 구현된 것인데 간단하게 구현해보겠습니다.

메타클래스는 셋 언더바 언더바 네임을 가지고 있다면 어트리뷰트의 이름을 어트리뷰트에 할당된 것과 이것을 하게 됩니다.

저 벨류로 가지고 오고 겟 어트리뷰트에서 셋네임이 있다면 펑션을 저기에 주게 됨으로써 네임스페이스에서 가져올 수 있게 합니다.

디스크립터는 다음과 같이 똑같은 프로토콜로 정했습니다. 이것은 3.6부터는 돌아가지않는 코드라면 이 코드는 동작하지 않을 것입니다.

하지만 이렇게 메타클래스를 메타로 지정한 후 디스크립터를 바로 거쳤으면 중복되는 부분이 없는 것을 볼 수 있습니다.

그리고 이것은 당연히 멀쩡하게 저희가 생각하던 대로 올바르게 작동합니다.

이때까지 메타클래스를 사용하는 아주 기초적인 방법에 대해서 설명을 했는데요.

메타클래스의 활용 방법은 무궁무진하니 각각 재미있는 것들을 만들어볼 수 있을 것입니다.

마지막 파트입니다.

과연 메타클래스는 이미 어디에 쓰일까요? 장고 등 오래 전부터 메타클래스를 활용하고 있었습니다.

어떻게 활용되고 있는지 장고와 이것을을 통해서 확인해보겠습니다.

첫 번째로 셀러리 2.6버저 예시입니다.

샐러리에 대해서 간단히 설명을 드리면 바로 처리하기 어려운 작업을 비동기로 처리하는 것, 그런 오픈소스 라이브러리입니다.

이때 보신 분아는 아시겠지만 태스크 클래스를 상속받아 하게 되면 자동으로 등록될 수 있습니다.

이제 샐러리의 태스크 클래스는 태스크 클래스란 메타 타입을 가지고 있는데 여기에는 몇 가지 검증을 거친 후 이름이 없다면 이름을 부여하고 현재 맥락에 정의된 앱을 자동으로 등록하는 기능을 수행하고 있습니다.

다만 샐러리 4부터는 이 기능이 삭제되었으므로 이 코드를 찾아보시려면 4.0 버전 이하에서 찾아보실 수 있습니다.

마지막으로 장고의 메타클래스에 대해서 소개해보려고 합니다.

파이썬을 장고로 입문하실 분들이 있을 정도로 유명한 장고에서도 메타클래스를 많이 활용하고 있습니다.

장고에서 메타클래스를 활용한 대표적인 예는 모델과 폼입니다.

폼에서 쓰이는 메타클래스에 대해서 확인해보려고 합니다.

폼을 만들을 때 상속받는 폼 클래스는 메타클래스를 상속받고 있습니다.

이 메타클래스는 폼을 정의할 때 사용하는 필드들을 메타클래스에서 자동으로 수집합니다.

이제 이 네임스페이스에서 아이템을 가져오고 필드라는 항목을 상속받았다면 필드를 자동으로 등록하게 되는 메타클래스의 코드입니다.

그리고 폼을 알아봤는데 폼에서 바생되는 모델폼에 대해서도 메타클래스는 유용하게 사용되고 있습니다.

파트 C에서 모델을 들면서 검증했는데 그것과 같은 내용입니다. 

모델폼을 사용할 때 몇 가지 설정을 메타라는 것으로 정의하게 되는데 메타클래스는 이 메타를 이용해 폼을 설정합니다.

일단 메타클래스에서 메타롤을 추출한 후 올바른 형식인지 확인합니다.

예를 들면 이런 경우가 있을 수 있습니다.

장고의 메타클래스에서는 이런 코드를 체크하는 코드가 있습니다.

이게 스트림인데 특정한 값이 아니면 잘못 됐다고 알려주는 부분입니다.

모델 어트리뷰트로 장고 모델에서 필드를 가지고 오기도 합니다.

모델을 가지고 와서 필드를 추출하고 메타에 정의된 필드 중 이상한 것은 없는지를 체크하고 필드를 체크하면서 장고는 마무리하게 됩니다.

제 발표는 여기까지 입니다.

그리고 저희 회사에서는 함께 만들어갈 개발자들을 항상 기다리고 있습니다.

많이 지원해 주시면 감사하겠습니다.

지금까지 제 발표를 들어주셔서 감사합니다.

-(박수)

-(사회자) : 발표해 주신 김성현 님 정말 감사합니다.

지금부터 질의응답 시간을 가질 건데요.

궁금한 점이 있으신 분은 가운데에 마련된 마이크로 와서 질문을 해 주시면 됩니다.

지금 시간이 얼마 없기 때문에 질문은 딱 하나만 받겠습니다.

-(질문) : 발표 잘 들었습니다.

맨 마지막에 메타클래스 사용 예로 제시해 준 그 부분을 인상 깊게 들었는데요.

특정 로직 케이스에 스페시픽하다는 생각이 들었는데요.

그런 로직을 메타클래스로 빼내는 게 좋을지 아니면 그냥 해당 클래스에서 메타클래스로 분리하는 이유가 궁금합니다.

-(김성현) : 장고에서 저렇게 확인하는 이유는 장고는 앱이 실행되기 전에검사를 합니다.

메타클래스를 하는 것 중에 이것을 수행하기 위해서 관련 로직을 집어넣은 게 아닐까 추측하고 있습니다.

-(사회자) : 발표 시간이 종료되어서 세션을 마무리하도록 하겠습니다. 지금까지 발표해 주신 김성현 님께 큰 박수 부탁드립니다.

-(박수)

그리고 40분에 103호에서 라이트닝 토크가 진행될 예정이니까 많은 참여 부탁드리겠습니다.

감사합니다.