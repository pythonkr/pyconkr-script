ShareTyping
-(진행자) 이제 곧 발표가 시작될 예정이니 자리에 앉아주시기 바랍니다. 아침부터 많은 분이 와주셔서 감사합니다. 김준기님께서 리얼 월드 어싱크 아이오라는 주제로 발표 시작하겠습니다. 뜨거운 박수로 맞아주시기 바랍니다.
-(김준기) 안녕하세요? 다들 일요일 아침에 이렇게 아침 10시까지 나오기 쉽지 않죠, 편안하게 늦잠자야 하는데 그래도 이렇게 아침 일찍 와주신 분들께 감사드립니다. 그리고 제가 알기로 슬라이드 스크립을 미리 전달해드리면 문자통역이나 하시는 분들에게 도움이 된다고 들었는데 그런데 제가 미처 준비를 못해서 어느 분께서 타이핑을 하시는지 모르겠지만 양해의 말씀을 드리고 파이팅입니다.
그래서 제가 오늘 발표할 내용은 리얼 월드 어싱크 아이오라는 주제입니다. 올해 phyton 리스트를 보니까 생각보다 리얼월드라는 게 저 말고도 몇 개 있더라고요. 그래서 제가 어싱크 아이오 관련 내용을 파이콘에서 네 번째 발표인데요. 그동안 처음 발표한 거는 2016년에 파이선에서 네트워킹을 하기 위해서 어싱크라는 대안이 있고 이걸 어떻게 활용하는 그 과정에서 제가 벤치마킹을 하면서 성능 이슈 등을 어떤 걸 했는지 이런 얘기를 했었고
2017에는 AIO툴즈라고 해서 제가 어싱크 아이오를 쓰면서 반복적으로 작성해야 하는 코드들이 있더라고요. 그래서 그런 것들을 라이브러리화 해서 만들었던 aio 툴즈라는 프로젝트 라이브러리 소개하고 작년 파이선에서는 또 다른 어싱크 아이오 라이브러리가 있는데 거기에 제공되는 RPC IO가 있는데 클라이언트가 함수 구축을 하면 비동기적으로 가져오고 exception 처리도 해주는 그런 라이브러리가 있는데 그 라이브러리가 제가 원하는 기능이 안 되는 게 있고 여러 문제 때문에 킬로섬이라고 불리는, 킬로섬이 뇌 좌우 반구를 연결하는 굉장히 굵은 신경다발의 의미인데 킬로섬이라는 라이브러리를 만들게 된 계기, 그 라이브러리를 만들면서 어싱크 스케쥴 구현 관련 소개를 했었습니다.
올해는 제가 다른 얘기를 해보려는 게 그러면 그동안 async IO를 쓰면서 무슨 문제가 있었나, 프로덕션을 적용했을 때 asyncIO라는 걸 어떤 부분을 주의해야 하는가, 주의하지 않았을 때 어떤 대참사가 벌어지는가를 이야기하려 합니다. 시작하기에 앞서 제 소개를 간단하게 하겠습니다.
제가 그동안 했던 오픈소스 프로젝트가 크게 3가지있습니다. 텍스트 큐브라고 요새는 아마 아시는 분이 많이 계시는지 모르겠어요. 30대 정도 되신 분들은 들어본 적 있을지 모르겠는데 10년 전 유행했던 설치형 블로그 오픈 소스, 그래서 네.
PHP, 파이콘에서 PHP얘기 하기 이상하지만 어쨌든 PHP로 코딩을 열심히 했던 설치형 블로그고 여기 보면 이상한 아이콘이 하나 있는데요.
윈도우용 접속하는 프로그램 많이 쓰셨을 거예요. 얼마전에 윈도우용 탭용으로 내놔서 앞으로 입지가 줄어들 수 있지 않을까 생각이 들지만 어쨌든 현재까지 윈도우에서 표준으로서 사용하는 클라이언트인데 이 프로젝트가 여러 가지 토크가 있습니다.
제가 원본에 기여한 건 아니고 그중 제가 아는 분이 한글판 TT라고 해서 한글 입력 같은 처리가 매끄럽게 되는 걸 만드신 게 있었는데 그걸 메인테인을 이어받아서 했었고요. 제가 했던 건 유니코드가 잘 처리되게 했었고 그다음에 창, 윈도우, 투명도 기능 같은 것들을 다른 제 아는 분의 도움을 받아서 그런 기능을 추가한다든지 이런 걸 했었습니다.
그러다가 제가 맥 사용자가 되면서 더 이상 TT를 안 쓰게 되는 바람에 제 메인테인을 다른 분께 넘기고 지금은 이름만 올라가있는 상태입니다. 그리고 대학원 다니면서 했던 프로젝트는 NBA라고 불리는 프로젝트인데요.
이거는 GPU를 기반으로 네트워크 패킷 프로세스를 하는 고성능 네트워킹을 하기 위한 라이브러리가 있습니다. 그거를 이용해서 패킷처리 가속을 구현하는 그런 프로젝트를 했었고요.
그다음에 지금 하고 있는 게 백앤드.AI라고 하는, 뒤에 회사 부스가 있는데 거기서 실제 해보실 수 있고 이 프로젝트도 서버 사이드는 완전히 파이선으로 짜 있고 제가 asyncIO, 라이브러리 등을 헤비하게 사용해서 실제 프로덕션에 나가고 있습니다. 그리고 이 프로젝트에서 파생된 게 이 3가지 프로젝트인데요.
aiodocker는 어제 발표를 들은 분은 아시겠지만 이거를 하면서 일거리 산을 쌓았는데 그중 도커를 async 하는 에이아이가 라이브러리가 잘 안 돼서 이 프로젝트가 사실상 원래 원작자분이 시간이 없어서 버려둔 상태였고 제가 필요한 기능이 빠져있어서 그걸 구현하면서 직접 메인테이너가 된 케이스입니다. 이거를 하면서 여기 앞에 보이는 오가니제이션이 있는데요.
aiohttp를 만든 분이 asyncIO를 개발하면서 asyncIO를 만들면서는 생태계가 새로 만들어져야 합니다. 비동기 코드에서 동기코드를 부를 수 있지만 그렇게 되면 비동기의 입점이 완전히 사라지기 때문에, 예를 들어 데이터 베이스 접속하는 라이브러리 이런 것들을 정부 다 async로 만들어진 버전으로 써야 합니다. 그래서 async로 만들어진 이후에 그후 여러 접속 라이브러리, HTTP 라이브러리 등등이 다 사용할 수 없는 거예요.
그래서 이거를 사람들이 asyncIO에 대응된 버전을 사용했는데 그중 잘 쓰일만한 퀄리티 보장된 라이브러리를 모아서 한 군데서 관리해보자는 콘셉트로 만들어진 것입니다.
이런 프로젝트가 있었고 그다음에 callosum 관련한 것은 작년 파이콘을 참고해주시기 바랍니다. 그래서 제가 하고 있는 일, 기타 프로필을 소개해드렸고 asyncIO를 처음 쓴건 처음 나왔을 때부터 썼습니다.
이걸 바탕으로 튤립이라는 이름의 프로젝트가 있었습니다. 이게 asyncIO, 이거를 PEP-3156번을 통해서 공식적으로 파이선 표준 라이브러리에 되게 됩니다.
오래전부터 써왔고요. 그래서 제가 매년 파이콘에서 하는 게 올해는 이제 asyncIO가 쓸만해진 것 같아요. 그다음에 이러이러한 API와 이런 기능이 추가돼서 이번에는 asyncIO가 쓸만해졌다는 얘기를 3년째 했어요. 그런데 오늘할 얘기는 아직 갈길이 멀었다는 스포일러를 합니다. 왜 그런지 발표를 통해서 설명을 드리도록 하겠습니다.
그래서 오늘 주로 중심적으로 얘기할 거는 제목은 리얼 월드 asyncio라고 했는데 캔슬레이션에 대해서 얘기를 하려고 합니다. 어싱크하다는 얘기는 비동기로 뭔가 실행하다 멈추고 또 실행하다가 멈춰서 계속 이런 것들을 반복한다는 얘기예요.
그런데 그러면 잠깐 멈춘 사이에 무슨 일이 벌어질지 모르거든요. 네트워크 커넥션에서 커넥션이 끊길 수 있고 사용자가 갑자기 프로그램을 종료하려고 할 수도 있는 거고 그런 상황들에 대해서 어떻게 대처를 하느냐?
그리고 라이브러리들을 저 앞에서 쓰다 보니까 어떤 경우들이 있는가, 어떤 문제점들을 내가 잘 구분해야 하는가 이런 얘기들을 하려고 합니다. 그런 사례들을 몇 가지 소개하고 최근에 이야기가 되고 있는 것 중 스트럭드 콘커런시라는 게 있습니다.
아주 고전적인 개념이죠, 예전 어셈블리 베이직으로 코딩하던 시절 함수라는 개념이 약했기 때문에 다 점프를 하면서 코드를 짰습니다.
그러면 고투같은 것들의 문제점이 추상화를 할 수 없게 만들어요. 왜냐하면 현재 맥락 그대로 가진 채로 다른 지점으로 건너뛰어 실행하기 때문에 추상화가 작동 못 하는 문제가 생기는데 이런 거를 언어적으로 조건문, 반복문을 제공하면서, 요새는 당연하게 배우는 건데 그런 것들의 개념이 명확하게 성립이 안 돼 있었습니다. 50, 60년대.
그래서 그런 구조화된 프로그램의 개념을 통해서 현재는 우리가 훨씬 프로그램을 잘 추상화된 방식으로 할 수 있게 됐는데요. 마찬가지로 이런 비동기 프로그램에서 비슷한 개념이 필요하겠다, 이런 것들을 하려면 어떤 요소가 필요하냐고 해서 asyncIO 개발자와 asyncIO를 사용하면서 어떤 불만을 느꼈던 여러 오픈소스 개발자가 나름대로 제안을 제시한 게 있습니다. 그런 것들에 대해서 간단하게 소개하려고 합니다.
그래서 asyncIO를 써본 분 계신가요? 생각보다 많이 하셨네요.
그래서 제가 그저께 튜토리얼을 했어요.
aio 기반의 튜토리얼을 했는데 들은 분이 계실지 모르겠는데 생각보다 asyncIO 써본 분이 없더라고요. 그래서 그런 일이 있을까 봐 요약 슬라이드를 1장 들고 왔는데요.
사실 이거를 설명을 길게 하면 이것만 해도 아마 시간이 꽉 찰 텐데 간단하게 하고 넘어가겠습니다. 써본분이 많은 것 같으니까.
asyncIO 기본적으로 IO에서 알 수 있듯 연산을 변경하고 그런 라이브러리가 아니고요.
블로킹 아이오가 발생했을 때 맥락을 코르틴을 함수를 사용해서 쉽게 하는 거라고 볼 수 있겠습니다.
파이선의 asyndef await이 있습니다.
이거는 이런 식으로 돌아가야 하는 거예요라고 딱 정해줄 수 있는 거예요.
그래서 이거를 이용해서 사실은 asyncIO가 아닌 다른 써드 파티 구현도 존재합니다. 뒤에서 설명을 드릴 텐데 trio, curio 이름의 다른 라이브러리가 존재하고 이거는 asyncIO하고 전혀 상관없이 문법을 사용을 하지만 내부적으로 새로 구현된 그런 이벤트 루프가 있습니다.
비동기 특징은 이벤트 루프가 있습니다. 운영체제가 어떤 IO작업이 끝났을 때 어떤 유저 프로그램에게 너가 작업 끝났으니 다음 일을 해도 된다는 건 운영체제에서 지원해야 하거든요. 운영체제에서 다양한 비동기가 있습니다.
윈도우 같은 경우에는 IO 콤플레이션컴퍼라고 해서 비동기 IO가 있습니다.
엑스트렙션을 해서 하이레벨화 한 인터페이스를 일관되게 쓸 수 있도록 제공해주는데요.
그러다 보니까 이벤트 루프라는 주체가 내가 생성한 코루틴을 직접 호출해줘야 이벤트 비동기 코드가 돌아갑니다.
그래서 그런 최상위 호출자가 없으면 비동기 코드는 돌릴 수 없어요.
그냥 제네레이터하고 똑같습니다. 수동으로 내가 한 땀 한 땀 불러서 실행할 수 있지만기본적으로는 이벤트 루프를 통해서 스위칭을 한다, 그런 개념으로 보시면 되겠고요.
그래서 파이선이라는 언어는 언어가 처음 만들어졌을 때부터 비동기로 만들어진 게 아니에요.
이 기능이 나중에 추가돼서 파이선은 기본적으로 동기모드로 돌고요.
동기 모드라고 굳이 용어를 붙였지만 사실은 파이선 코드가 동기모드로 돌고 asyncIO 런이라는, 객체에 컴플리트라는 메소드를 불러주고 그 메소드가 종료되면 그 남아있는 텍스트가 있으면 수동으로 처리해주거나 그런 여러 가지 귀찮은 것들을 처리해줬는데 그런 것들을 해줄 수 있도록 라이브러리 한 겁니다.
이런 동기 코드에서 비동기코드 진입하는 최초 함수가 있고요.
이 태스크에서 다른 task를 만드는 것, 비동기적으로 스위칭이 되면 동시에 돌아가는 것처럼 보이는, 흐름을 맥락을 만드는 것을 asyncIO 크리에이트 task라는 함수를 부르면 원래 함수를 부른 태스크와 동시에 돌아가죠.
다른 함수를 동기적으로 하는 거죠, await이라는 건 이름에서 알 수 있듯 실행결과를 기다리는데 이건 비동기니까 나는 잠깐 멈춰있을게, 그 비동기 함수를 실행해줘, 그리고 함수가 끝나면 알려줘, 그 함수가 실행되는 동안 다른 할 일이 있으면 그 할일을 그사이에 실행해도 돼 그런 뜻입니다.
사실 이거 두 개만 있어도 모든 기능을 다 만들 수는 있는데 거기에 추가적으로 async 포, async 위드라는 다음 아이템을 가져오는 것 자체가 코루틴인 경우 문법적으로 지원하고 with라고 해서 파이선에서 어떤 블록에서 진입하기 전에 그 블록에 빠져나오면서 코드를 실행하고 어떤 이상한일이 발생해도 문법적으로 그 블록을 빠져나가는 시점에 항상 어떤 리소스 클린 업을 할 수 있도록 보장을 해주는 그런 문법 구조가 있는데요.
그 앞뒤 과정이 코루틴인 경우 처리할 수 있도록 어싱크 위드라는 문법이 제공됩니다.
그리고 파이선 3.6에서는 어싱크 제네레이터 개념이 있어서 예전에는 단일로 메소드로 손으로 다 구현을 했어야 했는데 어싱크 데프로 선언된 코루틴 함수 내 일부 명령을 넣음으로써 보다 쉽게 제네레이터를 구현할 수 있게 됐습니다.
그래서 보통 인터넷에 asyncIO 관련한 튜토리얼을 찾아보면 여기까지는 잘 설명해요. 아마 저보다 쉽게 알아듣기 쉽게 설명할 겁니다.
그런데 설명을 안 하는 부분이 캔슬레이션에 대해서는 자료를 잘못 본 것 같아요.
어떤 개념이냐, 아까 말씀드린 것처럼 코루틴이라는 것은 잠시 다른 일을 할 수 있는데 그 다른 일을 하는 누군가 나를 중단시킬 수 있는 거예요.
내가 어떤 task인데 내 자신의 task, 호출해준 task가 나를 취소하거나 다른 것이 취소할 수도 있어요. 스스로 할 수도 있습니다.
취소라는 건 뭐냐 하면 내가 더 이상 실행을 안 하고 지금 하던 일을 중단하고 빠져나가겠다는, 예외랑 굉장히 비슷한 개념이고요.
이건 어떤 말그대로 예외적인 것에서 발생하는 예외라기보다는 내가 의도한 예외라는 점에서 약간 개념적인 차이가 있습니다.
그래서 파이선에서도 asyncIO에서도 캔슬레이션에서도 예외처리 매커니즘을 통해서 표현하고 있습니다.
코루틴으로 어싱크 할 때 주의할 점은 모든 await 그다음에 async FOR 같은 경우에는 코루틴을 돌리면 아이템을 하나씩 꺼내 아이템마다 바디를 호출하잖아요. 그 바디와 다음 아이템 바디 실행 중간 간격들의 그다음에 async 위드에도 들어가는 순간 나가는 순간 모든 시점에 캔슬레이션이 아무 때나 발생할 수 있습니다.
이거를 항상 마음에 염두에 두셔야 해요.
그리고 그런 await가 없는 데프 함수도 정의할 수 있는데요.
두 번째처럼.
이거는 동기적으로 코루틴을 짝 돌리는 거죠, 이런 경우는 아무리 길어도 캔슬하는 순간 캔슬되지 않습니다. 우리가 보통 멀티스레드 프로그래밍을 하게 되면 운영체제 레벨에서 시그널을 날려서 스레드가 어떤 걸 수행 중이거나 시그너 핸들러를 강제 호출할 수 있잖아요.
이거는 코루틴을 이용해서 코퍼레이트, 협조적 멀티태스킹을 하는 방식이라 내가 아무리 밖에서 캔슬하고 싶어도 스위칭 자체를 하지 않으면 캔슬이 일어나지 않습니다. 이거는 아까 말씀드린 대로 asyncIO에서는 모든 라이브러리를 다 asyncIO에 포함되는 라이브러리를 포함된다는 말씀드린 것까지 같은 맥락이라고 보시면 됩니다.
태스크 또는 퓨처에 대한 참조를 가진 쪽에. 캔슬이라는 게 있습니다.
캔슬 메소드라고 보면 되고요. 그러면 끝날 것 같지만 사실은 이거를 하기까지 주의해야 할 여러 가지 디테일들이 나옵니다.
그래서 캔슬 메소드로 호출하면 되는데 이 퓨처라는 게 있고 task라는 개념이 있습니다. asyncIO를 써보시면. 아마여러분이 기존에 있는 라이브러리를 활용해서 async 한 프로그램을 앱을 만드는 입장에서는 퓨처라는 객체를 직접 다룰 일이 없을 겁니다. 대부분 task로 표현되고요.
두 개의 차이는 퓨처는 어떤 작업이 끝날 거다, 오래 걸리는 작업이 있고 비동기로 돌아가는 작업이 언젠가 끝나고 끝난 시점에 나에게 알림을 줘라고 하는 그 상태만 표현하는 객체고요.
태스크는 퓨처하고 동일한데 중간에 그 태스크가 여러 번 멈췄다 갈 수도 있다는 가정을 깔고 있는 거라고 보시면 됩니다.
그래서 퓨처 같은 경우는 그냥 퓨처를 취소하면 그 상태가 바로 취소가 되는 거고 task는 캔슬을 똑같이 할 수 있습니다. 인터페이스 호환이 되는데 캔슬하고 나서 그 task가 할일이 남아있을 수 있어요. 클린업을 하기 위해서 다른 코루틴을 부를 수도 있는 거죠.
그런 경우에는 이 태스크를 항상 await을 한 번 더 걸고 task가 종료처리를 할 수 있는 기회를 줘야 합니다.
이게 많이 빠트리는 실수 중 하나고요.
그리고 그 task가 캔슬레이션 에러를 내부적으로 캐치를 하느냐, 안 하느냐에 따라서 그 await 구문의 캔슬레이션 에러를 내가 잡느냐, 안 잡느냐 값도 달라집니다.
이런 식으로 체이닝이 되기 때문에 캔슬레이션 에러를 어떻게 처리를 하느냐에 따라서 내가 코루틴이나 태스크를 사용하는 방법 차이가 생기죠.
그리고 스스로 취소할 때는 자기가 asyncIO 스스로 취소를 하면 코루틴을 담고 있는 태스크가 스스로 취소가 되는 겁니다. 주의할 점은 asyncIO를 보시면 asyncIO 커렌트라는 게 제공됩니다.
이 태스크를 캔슬 할 수 있어요. 그런데 이렇게 캔슬하게 되면 상태는 캔슬드로 바뀌는데 캔슬드 에러가 발생하지 않습니다.
그래서 바깥에서 이 캔슬됐는지를 예외로 알 수가 없어요.
그런 문제가 또 생깁니다.
그래서 이 방법은 쓰면 안 되고요.
대표적으로 제가 처음 asyncIO를 썼을 때 겪은 문제들인데요.
여러분 파이선 코딩을 중급 이상을 하는 분들은 트라이 except 뒤에 아무 구문, 쓰지 말라는 말들을 들으셨을 거예요. 모든 예외를 굳이 잡고 싶으면 except exception하라는 게 있습니다.
베이스 exception이라는 게 있고요.
그리고 이 아래에 그냥 exception이 있습니다. 그래서 우리가 일반적으로 관철하는 ValueError, TypeError, 런타입 에러라든지 이런 라이브러리가 정의한 에러들은 보통 그냥 exception입니다. 그런데 일반 exception이 아닌 다른 종류가 있습니다.
현재 파이선에는 세 가지가 있는데 키보드, SystemExit 그리고 GeneratorExit가 있습니다.
키보드는 컨트롤 C를 눌렀을 때 발생하는 겁니다.
명시적으로 다른 거로 오버라이드를 하지 않았다면 기본적으로 파이선은 컨트롤 C를 누른 시점에 현재 프로그램의 프레임에 이 키보드인터럭디가 발생시킵니다.
SystemExit는 엑시트라는 메소드를 불렀을 때 발생하는 이벤트고요.
그다음에 GeneratorExit 같은 경우는 제네레이터가 돌다가 얘가 발생했을 때 바깥에서 중단시켰을 때 발생하는 그런 에러라고 보시면 되죠.
이 에러들을 특별하게 취급하는 이유는 이것들은 말하자면 프로그램의 종류라든지 어떤 맥락의 중단이라는 거를 표현하기 위한 예외 사항이에요.
말하자면 exception이라는 걸 말씀드렸듯 말 그대로 예외적인, 예측하지 않은 어떤, 내가 이 프로그램을 짤 때 기대하지 않았던 어떤 상태가 발생을 했을 때를 알아내기 위해서 우리가 exception이라는 걸 쓰는 건데 이것들은 어떻게 보면 특수한 의미를 가지고 있는 exception입니다.
내가 의도적으로 컨트롤 C를 눌러서 프로그램을 종료시키는 게 잘못된 게 내잖아요.
아니잖아요.
그런데 이 프로그램 입장에서는 갑자기 아닌 밤 중에 홍두깨처럼 갑자기 인터럭트가 들어온 건데 그런 거를 예외처리라는 매커니즘으로 표현한 것 뿐이지 사실 이 자체는 우리가 오류라고 얘기하는 그런 잘못된 상태를 이야기하는 게 아니라는 거죠.
그래서 파이선에서는 이 개념상 분리해놨습니다. 문제는 아까 asyncIO에서는 캔슬레이션하려면 캔슬드 에러를 발생시키잖아요.
캔슬드 에러는 베이스가 아닌 그냥 exception입니다.
그래서 이런 문제가 발생하는데 사실은 여러분이 비동기 코드를 짜실 때는 그냥 exception을 잡으면 큰일납니다.
왜냐하면 캔슬드 에러를 먹어버리거든요.
저렇게 하면.
캔슬드 에러를 먹으면 여러 가지 문제들이 생기게 되는데 뒤에서 설명을 해드리기로 하고 그래서 비동기 코드를 짤 때는 반드시 asyncIO.캔슬드 에러라는 걸 명시적으로 잡아야 합니다.
그래서 보통은 레이즈를 해야 하고요. 레이즈를 하면 최상위 코루틴을 타게 되어서 거기서 처리를 하게 되고 내가 태스크의 최상위 코루틴이다, 비동기 함수 있잖아요. 그 비동기 함수가 최상위 코루틴인데 거기서 호출하고 호출하고 타고 내가 캔슬레이션 처리했을 때 적절하게 처리하고 확실할 때는 리래이즈를 하지 않고 종료시키면 됩니다.
뭔가 복잡해지기 시작하죠?
그래서 이 문제 때문에 파이선 개발자들 사이에서도 많은 논의가 있었어요.
캔슬드 에러를 그러면 우리가 베이스 exception으로 만들면 어떠냐 이슈 제안이 있었는데요.
처음에는 다들 반대를 했어요. 왜냐하면 아시겠지만 exception의 베이스 클래스를 바꾼다는 것은 앞에서처럼 exception 구분에서 어떤 타입을 잡았냐에 따라서 갑자기 잡던 exception을 못 잡게 되는 상황이 있을 수 있잖아요. 이거는 asyncIO를 사용하는 모든 프로그램에 중대한 영향을 주는 문제입니다.
더군다나 이 이슈가 나온 게 파이선 3.6 전인데요. 3.4에 처음 이 asyncIO가 도입되고 나서, 이 API가 실험적으로 도입된 거라 바뀔 수 있다, 그래서 여러분이 인지하고 쓰셔야 한다고 했다가 3.6에서 스테블 API가 됐는데 캔슬드.
이슈 트래커를 여시면 아시겠지만 몇 가지 얘기가 오고 가다가 앤드류 스벨로프라는 async를 개발한 분이 여러 파이선 컨퍼런스를 다니면서 사람들에게 써본 경험이 어떠냐라고 하니 다들 공통적으로 하는 얘기가 캔슬드 에러를 자꾸 누군가 먹어버리더라, 그래서 여러 가지 문제가 생기더라는 얘기를 여러 군데에서 듣고 나서 마음을 바꾼 거죠.
이거는 베이스 exception으로 간다, 그래서 파이선 3.8에 릴리즈될 것 같은데 올해 말어.
여기부터는, 이 나머지 3개 exception은 파이선 언어 정리가 된, 그런데 유일하게 이 캔슬드 에러가 라이브러리에서 정의된 에러인데 베이스에 이제 포함되는, 중대한 차이가 있고요.
이런 것들 때문에 캔슬레이션이라는 게 도대체 뭐기에 복잡한 거였냐라고 하면 캔슬레이션이 일어날 때 어떤 일이 일어나는지 예제를 보여드리려고 합니다.
실제로는 아무 일도 하지 않는 슬립으로 그냥 시간 지연만 걸었어요.
중간 캔슬되면 캔슬드 찍고 그 캔슬드 에러를 래이즈업 해주고, 어쨌든 종료되면 클린 업을 한다, 이런 간단한 코루틴이 있습니다.
이거를 캔슬하는 방법이 몇 가지가 있는데요.
여기 앞에 1초가 걸리고 그러니까 이 태스크가 뭔가 어떤 일을 하는 데 1초가 걸리고 그다음에 그 태스크를 종료해서 클린업을 하는 데 1초가 걸리는 태스크입니다. 이거를 우리가 캔슬하면 이거를 크리에이트 태스크 실행하면 동시에 돈다고 하잖아요.
그러면 asyncIO.슬립을 await 거는 순간 이 코루틴이 진행하게 됩니다.
그러면 여기는 슬립1을 걸어서 멈춰있겠죠.
그러면 나는 0.1초 쉬었기 때문에 얘가 쉬는 동안 0.5초가 지나면 다음 코드가 실행됩니다.
캔슬을 하고 태스크가 클린업할 수 있으니까 무조건 태스크에 대해서는 await 하나 걸어두셔야 합니다. 그래서 만약에 이 태스크가 캔슬한 시점에 아무것도 안 하고 리턴할 수 있고 그러면 끝이 나고 뭔가 다른 일을 할 수 있죠.
그래서 캔슬하면 이 캔슬드"에러가 내부적으로 래이즈가 되고 그다음에 이 캔슬드 에러를 찍고 그다음에 빠져나갈 때 이 파이널리 블록이 실행되고 이 파이널리 블록에 슬립이 걸려 있습니다. 이 시점에 1초가 또 추가로 걸립니다.
그래서 이렇게 콘솔 로그상으로는 워킹을 하다가 중간 캔슬당해서 내부에서 인지하고 캔슬드라고 뜨고 그다음에 빠져나가기 전에 얘는 클린업을 한 거예요. 그래서 이 사이에 0.5초를 쉬고 이 사이에 1.5초를 쉬어서 실제로는 1.5초가 걸려서 마지막에 캔슬레이션 디텍티드라고 바깥에서 인지를 할 수 있게 됩니다.
이거를 굳이 내가 슬립, 캔슬하고 이렇게 하지 않고 타임아웃을 거는 방식으로 할 수 있습니다.
태스크를 걸어놓고 타임아웃을 주면 0.5초 이내 이 태스크가 완료 리턴하지 않으면 그 태스크를 캔슬하고 태스크가 종료할 수 있게 await을 자동으로 겁니다. 위와 똑같은 로직을 이런 식으로 짧게 표현할 수 있고 이것도 정확히 마찬가지로 0.5초가 걸리고 사이에 1.5초가 걸리는데 여기서는 에러가 바깥에서는 여기는 타임아웃으로 걸었잖아요.
그래서 캔슬드 에러가 아닌 바깥에서는 타임아웃 에러라고 잡히게 됩니다.
내부에서는 캔슬드 에러가 그대로. 이거는 상황에 따라서 내가 이거를 캔슬하는 조건 자체를 타임아웃으로 표현하고 싶으면 이런 API를 써서 할 수 있고요.
아니면 컨트롤 C처럼 강제로 내가 종료해야 하는 경우에는 캔슬을 그냥 시켜서 캔슬드 에러로 잡으면 됩니다.
이런 차이가 있고 여기서 흔히 사람들이 간과하기 쉬운 부분이 호출에 대해서 이거를 처리할 스케쥴링할 기회를 줘야 한다는 걸 빼먹는 경우가 많습니다.
그래서 asyncIO 복잡한 코드 많이 발생하는 일이 컨트롤 C 종르하면 뭔가 어떤 워닝이 막 떠요. 프로그램 종료는 되긴 하는데 워닝이 뜨면서 종료가 됩니다. 그런 이유 중 하나가 클린업을하는 코루틴이 실행할 기회를 못 얻고 강제종료가 되는 그런 원인이 뜨게 됩니다. 이런 부분을 잘 처리하는 게 굉장히 어려운 이슈고요.
그래서 그러면 asyncIO를 쓰기 위해서는 우리가 다양한 asyncIO 기반의 라이브러리를 써야 한다고 얘기를 했어요.
취소 불가능한 라이브러리가 있습니다. 여러 가지 이유가 있는데요.
제가 겪은 몇 가지 사례들을 얘기를 드리려고 합니다.
제가 어떤 커뮤니티 행사에 가서 제가 백엔스 에이아이를 하는데 계속 서버가 죽어서 봤더니 서버 로그에 무슨 aioPG라는 게 있는데 트랜직션이 끝나지 않았는데 취소할 수 없어요 에러가 뜨면서 connection 릴리즈가 안 되는 거예요.
그래서 실드라는 걸 감싸서 임시 해결을 했는데 실드라는 건 말하자면 캔슬레이션이 안 된 것처럼 흉내를 내주는 거예요.
그래서 그 안 실행되는 텍스트들을 실드 안에서는 바깥에 캔슬돼서 계속 실행이 돼요. 바깥에서만 캔슬드 에러가 잡힙니다. 이거를 써야 하는 이유가 몇 가지 있는데요.
예를 들면 앞에서처럼 데이터 베이스 트랜직션 중간 갑자기 캔슬되면 취소하는 게 맞고요.
트랜젝션을 계속 실행하는 게 맞을 수 있습니다.
여기서 aioPG에서 캔슬이 발생하면 웹 핸들러가 돌고 있는데 사용자가 커넥션가 끊기거나 하는 경우 핸들러가 돌고 있으면 캔슬을 해버립니다.
사용자가 요청을 보낸 거에 대해서 기록하기 위해서 트랜젝션을 하려고 했는데 그건 롤백이 계속 진행되어야 하는 트랜젝션인 경우 실드를 써서 보호를 해주면 취소가 되지 않고 돌아갈 수 있습니다.
그거를 도와주기 위한 라이브러리로 aiojobs가 있고 이거를 이용하게 되면 웹 핸들러를 실드로 감싼 것처럼 보호할 수 있습니다.
여기에 여전히 문제점이 뭐냐 하면 스트리밍처럼 굉장히 장시간 돌아가는 코드는 캔슬이 돼야 할 수가 있어요.
그러면 핸들러 안에 어떤 부분은 캔슬이 되면 안 되고 어떤 부분은 가능해야 하거든요.
그래서 이런 것들을 어떻게 처리할 것이냐는 문제가 발생합니다.
그다음에 redis를 쓰는 경우에도 여러 가지 문제가 있는데요.
복잡하게 말할 시간이 없으므로 넘어가고 뒷부분 슬라이드를 보여드리면 redis에서 퍼블리시 subscribe를 쓰게 되면 subscribe에서, 지금 현재 aio redis나 async에서는 subscribe 더 이상 하지 말고 중단해라는 걸 표현할 수 없어요.
그거를 하려면 그 커넥션를 통해서 subscribe를 명령 권해야 하는 처리가 잘 구현이 안 돼 있습니다.
그렇다 보니까 subscribe 커넥션은 계속 커넥션 풀을 먹게 돼요.
커넥션 풀이 소진되는 문제가 똑같이 발생할 수 있고 이런 거를 막기 위해서는 subscribe는 서버 인스턴스마다 한 개씩 해주고 그래서 얘가 로컬에서.
이 부분은 제가 asyncIO 튜토리얼에서 다뤘던 내용이나 더 궁금한 부분은 튜토리얼 자료, 홈페이지를 찾아보시면 되
겠습니다.
그다음에 이거는 엉뚱한 케이스인데요.
asyncIO 펑션하고 일반하고 구분했는데 그거를 구분하기 위해서 콜백이 코루틴이냐 아니냐에 따라 다르게 호출하는 걸 만든 적이 있습니다.
그런데 파이선에 펑툴스 펑션을 이용하면 어떤 세팅을 만들 수 있잖아요.
이거는 일반 함수로 감싸서 그런 건데 실제로는 코루틴을 await 해서 사용할 수 있어요. 내부적으로 동기 함수, 비동기 함수 리턴은 코루틴 객체고 그 비동기 함수는 코루틴이기 때문에 그대로 사용이 돼요. 그런데 타입상으로는 다른 타입이 되는 거죠, 그거를 해결하기 위한 게 제가 2년 전 발표한 aio 툴즈에 있는, 이런 것들을 빼먹어서 생기는 버그들이 있고요.
지금 시간이 초과가 된 것 같은데 이 뒷부분에 아까 얘기한 대로 구조적 프로그램 이야기가 있고 이거는 앞에서 이야기했으니 그림만 보여드리고 아까 얘기한 것처럼 캔슬을 찍거나 인터럭트 찍거나 할 때, 실드 태스크 경우에도 바깥에서는 캔슬 처리 되지만 실제로는 실행이 되거든요.
이런 예외들은 누가 잡느냐 그런 문제가 생깁니다, 얼마전에 나온 것 중 요새 IPV4 등 디폴로트 하는 케이스들이 많이 생기면서 예를 들어 하나의 커넥션에 접속하기 위해서, 그중 먼저 되는 거를 쓰겠다, 이런 exception이 존재합니다.
이런 것들을 표현하기 위해서 태스크 그룹이라는 걸 도입했고 그거를 통해서 어떤 스코프 내에서 스폰되는 모든 태스크를 한꺼번에 한다든지 취소됐을 때 다른 거를 한다든지, 이런 것들이 구현이 됐습니다.
여기 링크에 드린 것들을 보시면 대충 어떤 내용인지 아실 수 있습니다.
그래서 이런 라이브러리들을 보고서 asyncIO에서도 우리도 비슷한 기능이 필요하겠다 싶어서 구현된 것들이 있고요.
지금 현재 asyncIO에서 지원하는 스트럭티드 콘커런시 같은 경우는 이 태스크 그룹과 비슷한 역할을 합니다. 하지만 이거를 그대로 쓸 수 없는 이유가 있는데 예를 들면 태스크 안에서 다른 태스크를 하는 걸, 바깥에서 잡아내지 못 한다든진 이런 문제가 있어서 현재로써는 디폴트, asyncIO 쓰기로는 어려운 점이 있습니다.
그래서 이런 것들을 도입하자는 여러 시도가 있었지만 결론은 잘 안 되고 있고요.
이거는 asyncIO 내부를 거쳐야 하는 문제가 있어서, 그래서 몇몇 사람들이 우리도 다른 라이브러리 있는데 우리도 이거 구현합시다 해서 작년에, 작년 8월, 이거 만들어보니까 괜찮은 것 같아 했는데 이이게 릴리즈가 안 돼서 한 달전에 누가 댓글을 달았는데 파이선 3.8이 구현이 안 돼서, 이런 상태입니다.
그래서 3.8에서 변화가 생기는 부분은 많지 않은데 가장 중요한 부분은 캔슬드 에러가 exception이 된다, UDP 구현이 윈도우버전 구현이 되는 등 이런 차이점이 있습니다. 이 발표를 빨리 마무리하겠습니다.
그래서 모든 곳에 시작이 있으면 끝이 있죠.
그래서 코루틴이라는 것도 중간에 취소가 될 수 있는데 이 취소를 어떻게 표현하느냐, 그리고 취소 조건, 임의에 시점에 발생할 수 있는 상황들을 앱 개발자가 다 잡을 수 있느냐 이런 이슈가 있습니다. 이 asyncIO가 처음 만들어질 때는 그런 문제까지 미처 생각지 못한 부분이었고 몇년간 경험이 쌓이면서 다양한 제안들이 나오고 있는 상태입니다.
아마도 제가 매년 asyncIO가 쓸만해졌다고 했지만 실제로는 조금 더 있어야 더 쓸한해질 것 같다로 발표를 마치겠습니다. 시간이 늦었으니 질문은 따로 내려가서 받도록 하겠습니다. 감사합니다.
-(진행자) 40분 동안 꽉 찬 발표를 해주신 김준기님께 박수를 부탁드리고요. 저희는 5분 지연 돼서 10분 뒤에 다음 세션 진행하겠습니다. 감사합니다.