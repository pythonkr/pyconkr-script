https://youtu.be/_QNbWB8vJcU

-그러면 지금부터 멀티태스킹 온 DB 앤 장고라는 주제로 문석환 님께서 발표하시겠습니다. 큰 박수 부탁드리겠습니다.
-안녕하세요? 저는 멀티태스킹 환경을 상대하기 위한 DB의 특성, 그리고 DB를 상대하기 위한 장고에 대해서 얘기하는 현재 DB lock timeout 으로 매우 고생하고 있는 Peoplefund Repayment Processing System 개발자 문석환이라고 합니다.
기억하고 있는 분이 얼마나 있을지 모르겠지만 왼쪽에 있는 저런 환경의 싱글태스크였던 시스템이 있을 때가 있었습니다.
그런데 요즘은 저기 보이시는 굉장히 작은 기계조차도 멀티태스킹이 굉장히 기본적으로 지원을 하고 있죠.
이렇게 로컬 시스템에서도 손쉽게 멀티태스킹을 지원하고 있는데 이런 상황에서 웹서비스에서 멀티태스킹이 안 된다는 건 말이 안 되는 상황이겠죠.
이렇게 멀티태스킹 시스템에서 무언가를 작업을 할 때 발생하는 가장 잦은 현상 중에 하나가 바로 레이스 컨디션입니다.
레이스 컨디션은 무엇이냐 하면 여러 프로세스가 하나의 공유된 자원에 의존했을 때 레이스 컨디션이 발생한다고 하는데요. 옆에서 보듯이 아이스크림이 하나이고 사람이 5명이면 고생을 하겠죠. 웹서비스에서는 DB가 손쉬운 예예요.
손쉽게 lock timeout이라는 에러를 볼 수 있게 됩니다.
웹 서비스에서는 리퀘스트가 동시다발적으로 접근을 하고 그리고 그 리퀘스트들이 공유된 자원인 DB에 접속하면 lock timeout이 쉽게 발생하는데요. 동시다발적인 리퀘스트의 상관 관계는 로컬 디버깅만으로는 확인이 어려워요. 시나리오를 상정해서 로컬 테스트를 해 볼 수 있으나 동시다발적인 리퀘스트는 랜덤이라는 형태를 띄기 때문에 모든 시나리오를 테스트하는 게 어렵죠.
그러면 이것은 디버깅이 불가능하냐고 하면 우리가 이론, 많은 분이 싫어하는 이론을 통해서 눈버깅를 통해서 가능하게 됩니다.
따라서 이번 세션은 목적은 눈버깅을 위한 툴을 알려드리는 게 이번 세션의 목표입니다.
일단 공유된 자원, DBMS은 공유된 자원이고 DBMS이 동시다발적인 요청을 안정적으로 처리하기 위해서 특성이 뭔지 알아보고 그리고 이 특성들을 장고에서 어떻게 활용해서 우리가 레이스 컨디션을 어떻게 해결할 수 있는지 이번 세션에서 이야기해 보려 합니다.
이미 많은 분이 알고 계시겠지만 기억을 못할 수도 있으니 짧게 기본적인 내용을 짚고 넘어가려고 합니다. DBMS의 기본적인 개념인 transaction와 ACID의 특성인데요.
transaction은 기본적으로 여러 가지 작업들의 세트라고 생각하시면 됩니다.
DB 오퍼레이션의 기본적인 단위인데요. 옆에 그림에서 보시다시피 특정 밸런스에다가 읽고 작업을 하고 거기에 기록을 하는 이것을 하나의 묶음으로 묶어서 DB는 처리하게 되고 이런 묶음을 우리는 transaction이라고 부르게 됩니다.
이두 번째는 ACID인데요.
ACID이라는 특성은 네 가지 특성의 앞 글자를 따서 만든 특성인데요.
A는 Atomicity를 이야기합니다.
Atomicity는 transaction의 모든 작업들이 모두 다 반영이 되거나 혹은 하나라도 에러가 난다면 모두 반영되지 않고 원상복구되는 기본적인 특성을 이야기하고요.
그림에서처럼 transaction에다가 라이트 A와 B 두 가지 작업이 있다고 했을 때 하나라도 오류가 난다고 하면 모든 라이트가 일어나지 않고 모두 롤백이 되거나 만약에 라이트가 하나라도 일어난다면 다른 라이트도 무조건 일어나는 그러한 특성을 Atomicity라고 이야기합니다.
그래서 이런 특성을 지켜주게 되면 그 DB의 작업은 Atomic하다고 이야기합니다.
C는 Consistency를 이야기하는데요.
이는 미리 정의된 규칙에 의해서만 데이터 수정이 가능한 특성입니다.
예를 들어서 저희가 어떤 특정 콜럼에 들어갈 값을 DBMS에 이 컬럼에 넣을 값을 추가하려고 할 때 DBMS이 너는 넣을 수 없다는 에러를 넣는 것을 Consistency이라고 합니다.
세 번째 Isolation인데요.
Isolation은 어떤 특정 transaction에서 진행한 작업이 Q에게 보여지는 정도를 나타내는 특성입니다.
보통 Isolation은 레벨로 이야기하는데요. Isolation 레벨이 높으면 높을수록 T에서 변경한 데이터가 커밋을 하기 전까지는 다른 transaction에서 보여지지 않는 특성을 지니게 됩니다.
Isolation 레벨에 대해서 후반부에 설명을 할 건데요. 그것을 듣기 전에 우리가 기억해야 할 내용이 있다고 한다면 Isolation 레벨은 transaction 간의 특성을 이야기합니다. 이 한 가지만 기억을 하시면 되겠습니다.
마지막으로 D한 Duration인데요.
Duration는 결과적으로 하나의 transaction이 한 번이라도 반영이 됐다고 한다면 크래쉬가 됐든 어떤 문제가 발생이 됐든 그 데이터는 절대적으로 DB에 기록이 되어 있는 특성을 이야기합니다. DB에 대한 특성을 알아봤는데 무슨 문제가 발생할 수 있고 어떻게 해결할 수 있는지 제가 처음 이야기했던 lock timeout에 관련된 락이라는 말은 이야기 안 했잖아요. 락에 대해서도 이야기를 드리려고 합니다.
락을 이야기하기 전에 저희가 아까 얘기했던 멀티태스킹 환경에 대해서 이야기를 하면 저희가 보통 멀티태스킹이라고 한다는 것은 여러 작업들이 동시다발적으로 진행한다고 이야기합니다.
하지만 실제로는 싱글코어를 기준으로 이야기를 했을 때 한 시간대에 하나의 작업식밖에 할 수가 없는데요. 그래서 어떤 현상이 일어나느냐? 저 옆의 그림에서처럼 일상생활에서 쉽게 볼 수 있는 환경이죠. 여러 작업들이 한 CPU를 사용하기 위해서 한 줄로 기다리게 됩니다. 이를 DB의 작업과 한번 연관시켜서 이야기를 해 볼게요.
하나의 계좌에 동시에 입금과 출금이 발생하는 경우를 이야기해 보겠습니다.
왼쪽에는 입금 프로세스가 있고 우측에는 출금 프로세스가 있고요. 가운데에는 현재의 밸런스 DB의 기록을 보여주고 있어요. 찰나의 시간으로 입금이 먼저 들어왔다는 가정하에 입금 프로세스가 먼저 밸런스를 읽으려고 합니다. 밸런스에 기록되어 있는 1000원의 금액을 읽어오겠죠.
그러고 콘텐스트 스위치가 일어나면서 출금 프로세스가 일어났다고 가정할게요. 그러면 출금 역시 밸런스에서 값을 읽어옵니다. 그런데 DB에 기록되어 있는 밸런스의 값은 1000원이죠. 그리고 다시 컨텍스트 스위칭이 일어나서 입금 프로세스가 일어나는데 입금은 돈을 증가시키는 행위니까 1000원에다가 1000원을 더했다고 하고 2000원이 나와서 이것을 DB에 기록하겠죠. 그러면 행복하게 프로세스를 종료합니다.
그러면 입금이 프로세스가 종료되었으니까 이제는 출금 프로세스를 마무리하려고 해요. 그런데 출금에서 하는 게 아까 이미 리드를 했기 때문에 현재 밸런스는 1000원이라고 기억하고 있고 1000원을 뺐기 때문에 0원을 기록하게 되겠죠. 그렇게 되면서 밸런스에는 마지막으로 결과적으로 0원만 남게 되는 눈 뜨고 돈이 사라지는 마법을 경험하게 됩니다.
그러면 이 마법, 이 공명의 함정을 어떻게 해결할 수 있을까요?
그때 사용할 수 있는 게 바로 락인데요.
저희가 락을 사용해서 똑같은 프로세스를 진행한다면 어떤 시나리오가 나오는지 이 그림에서 볼 수 있어요.
아까 유사하게 입금이 먼저 실행이 되고요. 입겸은 밸런스 1000원을 읽어오게 됩니다. 컨텍스트 스위칭이 일어나면서 출금은 금액을 읽어오지 못하고 기다리게 됩니다.
그러면 다시 입금으로 프로세스가 넘어가서 입금은 아까와 같은 행동을 통해서 2000원 이 프로세스가 끝났을 때 출금 프로세스가 돌아가면서 락을 가지고 있는 사람이 없기 때문에 밸런스읽어서 2000원에서 1000원을 빼서 정확하게 1000원만 남기는 정확하게 행복한 시나리오를 남기게 됩니다.
이렇게 락을 이용하게 되면 더 데이터를 안정적으로 다룰 수 있게 됩니다.
이제 락에 대해서 그러면 조금 더 이야기를 해 볼게요.
DBMS에서는 기본적으로 두 가지 종류의 락이 있다고 이야기를 합니다.
첫 번째는 라이트 락인데요.
라이트 락은 말 그대로 DB에 기록할 때 쓰는 락이고요. 그다음에 이 락의 특성으로써 만약에 같은 로우에 되는 transaction이 접근을 하려고 한다면 라이트를 위해서든 리드를 위해서든 모두 다 블랙하게 됩니다.
그래서 하나의 transaction이 라이트 락을 넣었다고 한다면 다른 transaction이 리드를 하든 라이트를 하든 모두 기다리게 되는 현상이 발생합니다.
두 번째는 리드 락인데요. 얘는 라이트 락과는 다르게 다른 transaction이 라이트를 시도하게 되면 걔를 블럭하지만 리드를 시도하는 것은 허용합니다.
그래서 이런 두 가지 락 타입이 있고요.
추가적으로 이 데이터를 더 안정적으로 다루기 위해서 투 페이스 라킹 프로토컬이라는 프로토컬조차 DBMS에서는 정의하고 있습니다.
이 프로토컬은 무엇인지 설명을 해 드리면 첫 번째로 Expanding Phase라는 페이스가 있는데요. 이 상황은 락을 얻을 수는 있지만 놓을 수는 없는 상태를 이야기합니다.
두 번째는 Shrinking Phase인데요. Shrinking Phase는 락을 거꾸로 놓을 수는 있지만 얻을 수는 없는 상태를 이야기합니다.
그리고 DBMS는 이 데이터의 안정성을 지키기 위해서 transaction이 만약에 락이 필요하다고 한다면 이 두 가지 페이스 중에 하나는 무조건 속해야 하는 강제성을 가지고 있습니다.
이게 무슨 말이냐고 한다면 하나의 transaction이 락을 하나라도 놓게 된다면 자신이 그러고 나서 추가적으로 무언가를 얻으려고 한다고 하면 DBMS 형태로 프로토콜을 만들게 되는 겁니다.
일반적으로 transaction는 Expanding Phase로 시작을 해서 커밋 혹은 롤백을 하고 그다음에 Shrinking Phase를 돌입해서 락을 모두 다 놓게 됩니다.
그러면 락 되게 좋은 거네 우리 막 쓸까?
하면 되게 좋을 것 같은데 락도 사실 되게 조심스럽게 다뤄야 할 대상 중에 하나예요.
락의 단점에 대해서 이야기를 해 드리면 첫 번째로 락은 프로세스들이 병렬로 작업을 못하게 합니다. 아까 멀티태스킹이라고 했는데 정작 병렬로 하지 못하게 하는 현상을 해요. 길막을 하죠.
두 번째 단점은 데드락입니다.
데드락은 저 사진에서 보는 것과 같은 상황인데요. 첫 번째 차가 움직이기 위해서는 그 앞의 차가 움직여야 하고 그 차는 다른 차를 기다려야 하고 그 차는 첫 번째 차를 기다려야 하는 누구도 움직일 수 없는 상황, 이것을 데드락이라고 합니다. 락을 잘못쓰게 되면 데드락을 발생시키게 되고 DBMS는 에러를 내뿜게 되죠.
이렇게 락에 대해서 이야기했고 추가적으로 저희가 알아야 할 것 중에 하나가 Isolation 레벨인데요.
아까 이야기했다시피 Isolation 레벨은 transaction 간의 상호 작용 정도를 조정하는 레벨을 이야기하고 이 레벨을 조정하기 위해서 DBMS에 아까 이야기했던 락을 활용하게 됩니다.
이 Isolation 레벨을 이해하기 전에 저희가 리드 피노미나라고 하는 DBMS에서 발생할 수 있는 3가지 종류의 읽기 현상에 대해서 알아봐야 하는데요. 첫 번째는 더티 리드라고 합니다.
이것은 만약에 하나의 transaction... Q가 어떤 데이터를 변경을 했고 그다음에 얘는 아직 커밋을 하지 않았는데 다른 transaction이 걔가 변경한 데이터를 읽을 수 있는 현상을 더티리드라고 표현을 합니다. 다음 피노미나는 이것인데요.
이것은 하나의 쿼리를 두 번 시도했을 때 다른 결과값이 반환되는 것을 이야기합니다. 예를 들어서 특정 계좌에 기록된 잔액을 두 번 쿼리했는데 첫 번째는 1000원이 나왔고 두 번째는 2000원이 나오게 되는 현상을 돈 리피터블이라고 얘기합니다.
마지막은 팬텀이라고 이야기를 하는데요.
역시 같은 쿼리를 날렸는데 다른 로우들이 반환하는 현상입니다. 쿼리는 1000원을 조회해 줘라고 했는데 첫 번째와 두 번째 조회가 다른 계좌를 하는 것을...
차이점이 도대체 뭐지? 라는 생각을 하실 것 같아서 잠깐 비교를 해 드리면 논 리피터블 리드는 다른 값을 가지고 있는 같은 로우가 반환이 되는 거고요. 팬텀 리드는 같은 값을 가지고 있는 다른 로우가 반환이 되는
것입니다. Isolation 레벨은.
약간의 차이점이 존재할 수 있는 제가 이따가 장고의 락에 대해서 이야기하기 위한 기본적인 이야기만 하려고 합니다.
Isolation 레벨은 기본적으로 리드 피노미나를 허용하는 정도인데요. 이 표에서 어보실 수 있다시피 왼쪽에는 총 4가지 Isolation 레벨이 되어 있고 우측에는 허용되는 리드의 종류들, 그다음에 이를 허용하기 위해서 어떤 락들을 사용하는지에 대한 표로 정리를 해 봤어요.
첫 번째는 시리어라이저블인데요. 아까 얘기했던 모든 피노미너를 허용하지 않는 형태를 이야기합니다. 이를 위해서 리드락 라이트락 레인지락을 이야기합니다.
잠깐 레인지 락에 대해서 설명을 해 드리면 레인지 락은 예를 들어 하나의 로우를 리드든 라이트든 설명을 했을 때 주변의 로우까지 락을 거는 건데요.
테이블 단위로 아예 락을 다 걸어버리는 그런 방식로부터 이용해서 팬텀 리드를 막는 것으로 알고 있습니다.
그리고 최근에는 이것을 지원하는 DBMS도 별로 없고 특수한 상황에서 사용하기 때문에 이러한 데이터의 안정성이 멀티태스킹보다 중요한 시스템의 경우에는.
그다음으로 낮는 단계의 레벨이 리피터블 리드인데요. 팬텀은 가능하지만 다른 건 방지하고요.
리드와 라이드를 사용하게 됩니다.
그 다음 단계가 리드 커미티드.
가장 낮은 단계인 리드 언커미티드는 어떤 락도 사용하지 않아서 세 가지 피노미너 모두가 다 가능한 현상을 이야기하게 됩니다.
그러면 되게 많은 내용을 이야기했는데 머리에 더 들어갈 게 없을 것 같기는 하지만 이제 장고에 대해서 이야기를 해 볼게요.
삭제하거나 변경하는 바로 디비 쿼리가 발생하게 됩니다.
그러고 DB의 특성상 이렇게 쿼리를 진행하려면 각 스테이트먼트는 자동적으로 transaction를 씌어야만 진행을 할 수 있게 됩니다. 어떤 작업을 하던간에 바로 커밋이 되는 작업을 장고를 기본적으로 갖고 있습니다.
그리고 장고는 기본적으로 transaction을 시작하는 API를 제공하지 않아요. 만약에 컨트롤 하고 싶으면 거꾸로 오토 커밋을 꺼서 transaction을 발생시키지않는 방향밖에 없는 것으로 알고 있습니다.
다만 오토 커밋 모드를 사용하더라도 저희가 장고.db. transaction에 a[을 사용해서 여러 스테이먼트 셋에 대해서 Atomicity를 부분하게 돼요.
어떻게 보면 우리가 transaction을 컨트롤한다는 작업을 허용할 수 있게 해 줍니다.
Atomicity를 사용할 수 있는 방법은 두 가지가 있어요. 그냥 데코레이터를 이용하는 방법 그다음에 위드 스테이트먼트를 사용하는 방법 두 가지가 있습니다.
이 Atomic 펑션은 하나 이상을 사용할 수도 있는데요. 옆에 코드에서 보시다시피 첫 번째 아토믹을 걸어서 특정 프로세스를 실행하고 또 다른 프로세스를 진행하는 방식으로 아토믹을 사용할 수 있는데요.
이 어떻게 진행되는지 넘어가자면
바깥쪽 transaction이 시작되고요. 그다음에 안쪽 transaction이 시작하기 전에 세이브 포인트를 생성하게 됩니다. 그리고 밑에서 안쪽에 transaction에 관련된 작업들을 진행하게 되는데 만약에 내부에서 어떤 에러가 생하거나 transaction를 실패하면 롤백을 합니다.
그리고 마지막으로 바깥쪽 transaction에 관련된 작업을 모두 끝내게 되면 지금까지 작업한 모든 게 커밋을 하게 됩니다.
그래서 보시다시피 인아웃 프로세스는 모두 커밋이 되지 않는 특성을 가지고 있습니다.
장고는 서버에 설정된 DBMS의 Isolation을 기본적으로 사용하게 됩니다.
하지만 옵션이라는 설정을 사용해서 서버 설정을 오버라이트를 할 수 있게 돼요. 그리고 장고 1.11부터는 옵션에 아이솔레이션 레벨이라는 것을 명시적으로 해서 원한다면 변경을 할 수 있게 해 줍니다.
저희 시스템에서 기본적으로 쓰고 있는 게 디폴트로 디피터블 리드를 Isolation 레벨에서 사용하게 됩니다.
장고는 리드 커미티드를 권장하게 되죠. 이것은 사이드 노트로 말씀을 드리면 보통은 우리가 많이 사용하게 되는 다른 DB들은 리드 커미리트를 디폴트로 사용하게 되는데 오래전에 디폴트를 사용하기 때문에 이러한 차이점이 발생한다고 합니다.
그래서 주의사항이 발생합니다.
MYSQL에서 Isolation은 바이너리 로그, 저희가 서비스가 커지게 되면 당연히 슬레이브 DB를 활용하게 되는데요. 이 슬레이브 DB를 만들기 위한 게 바이너르 로그고 이거랑 밀접한 연관이 있습니다.
따라서 장고와 MYSQL의 Isolation의 레벨을 아까 권장한 대로 디폴트대로 설정해서 다르게 사용할 경우 우리가 생각한 락과 다르게 행동할 수 있게 되는데요.
예를 들어서 저희 MYSQL은 리피터블이 기본이고 장고는 리드를 기본으로 해서 설정하게 된다면 장고에서 행동하는 모든 작업은 리드처럼 작업을 하겠지만 실제로 바이너리 로그를 작성하는 MYSQL 단에서는 리피터블로 작동을 하기 때문에 특정 시점에서는 분명히 내가 한 것은 리드 커미티드라고 설정을 해 놨음에도 리피터블처럼 작동하는 현상이 발생하게 되겠죠.
아까 잠깐 이야기했는데 Isolation 레벨은 설정에 따라서 각각의 스테이트먼트들이 자동으로 락을 사용합니다.
하지만 장고에서 만약에 내가 임의로 락을 사용하고 싶다고 한다면 사용할 수 있게 지원할 수 있는 함수가 있는데요. 일단 첫째로 transaction Atomicity 안에 들어가 있어야 하고요. 내부에 있었을 때 셀렉트 포 업데이트라는 락을 사용해서 임의로 함수를 발생할 수 있습니다.
또다른 주의사항이 발생하는데 장고에서 쿼리를 할 때 셀렉 포 업데이트랑 사용하게 되면
따라서 어마무시한 대재앙을 발생할 수 있게 되는 주의해야 할 사항 중에 하나입니다.
또한 우리가 임의로 락을 걸기 때문에 발생할 수 있는 또다른 하나의 문제가 바로 데드락인데요. 이 데드락을 회피하기 위해서는 회사 내부에서 일종의 컨벤션으로써 만약에 특정 연관된 테이블들이 필요한 작업들이라고 한다면 이 모델들의 락을 가지고 오는 순서를 정해야만 이 데드락을 회피할 수 있습니다.
예를 들어서 저희 지금 T1 T2 T3이라는 모델들이 있다고 가정을 했을 때 예를 들어서 같이 시스템을 개발하는 사람들에게 우리 락을 얻기 위해서는 무조건 T1을 얻고 그다음에 T2, T3을 얻어야 한다고 순서를 명시해야 데드락을 피할 수 있게 돼요.
그래서 예제에서 보시다시피 T1 다음에 T2 T3 형태로 락을 얻는 형태로 구현을 하게 됩니다. 이 순서를 지키지 않으면 저희가 손쉽게 데드락을 볼 수 있게 됩니다.
그다음에 한 가지 더 유의사항을 얘기해 드리면 만약에 서비스가 너무 회사가 매우 잘됐다. 서비스가 커졌다는 상황이었을 때 너무 많은 데이터가 한번에 라이트하는 현상이 발생하게 된다면 저희가 장고에서 기본적으로 사용하는 PK가 바로 auto increment를 사용하게 되는데요. 이것을 동작하기 위해서는 다른 테이블이 있고 이 테이블에 락이 걸리기 때문에 기록이 늦어지는 현상을 발견하였됩니다.
이는 MYSQL를 기본으로 이야기하면 이노 DB의 auto increment의 옵션을 검색하면 방대한 자료를 볼 수 있는데 너무 방대해서 이번 세션에서는 스킵하도록 하겠습니다.
지금까지 저희가 DB에 대한 많은 특성을 이야기하고 이 특성을 우리가 어떻게 임의로 장고에 쓸 수 있는지 이야기를 했는데 그러면 이를 실제로 서비스에서 어떻게 사용할 수 있는지 이야기해 볼게요.
하지만 너무 많이 사용하게 될 경우실제 서비스에서는 제가 요즘 고생하고 있다시피 lock timeout을 쉽게 만나볼 수 있는데요.
사실 lock timeout을 피하는 가장 좋은 방법은 단순합니다.
그냥 프로세스들이 락을 들고 있는 시간을 최소화하면 됩니다. 락을 아예 사용하지 않으면 데이터 안정성이 위험하기 때문에 락을 사용하지 않을 수 없고 그렇다면 이 락타임아웃을 회피할 수 있는 방법은 그냥 프로세스들이 최소한의 시간으로 락을 가질 수 있게 고민해 보는 게 가장 좋은 방법입니다.
여기에서 우리가 주의해야 할 사항이 또 나오는데요. 아까 네스티드 오토믹을 이야기할 때 나왔는데 transaction은 바깥쪽 transaction이 끝나야 모든 작업이 커밋되고 아까 이야기했던 Shrinking Phase에 돌입하면서 그때서야 락을 놓게 됩니다.
따라서 저희가 락을 놓고 싶다고 한다면 현재 하고 있는 transaction만 끝내야 할 게 아니라 그 바깥에서 가지고 있는 transaction까지 모두 끝내야 하는데요. 이것을 잠시 예제로 보여드릴게요. 저희가 첫 번째 들어가게 되는 롱 프로세스 굉장히 오래 걸리는 프로세스라는 함수를 가지고 있고 아토믹을 걸고 시작을 하게 됩니다. 투자자들의 정보를 셀렉포업데이트로 가지고 오게 되고요.
상환 작업을 한다고 가정을 합니다. 이 작업은 무엇을 하느냐? 먼저 밸런스에 오브젝트를 들고 오게 되고요. 이 밸런드는 투자자의 계좌정보이기 때문에 이 상환말고도 굉장히 많은 곳에서 사용되고 있는 크리티컬 세션이고요. 이 밸런스를 이용해서 함수를 돌리게 됩니다.
이름에서 보다시피 여기에서 무슨 짓을 하는지 모르겠지만 밸런스를 라이트하는 작업을 하게 되겠죠. 이렇게 하게 되면 어떤 문제가 발생할 수 있느냐? 프로세스 상으로는 사람이 생각하기에는 명시적인 내용인 것 같은데 투자자 돌면서 상환 처리하고.. 명시적인 프로세스인 것 같은데 어떤 문제가 발생할 수 있냐 하면 첫 번째로 발생한 투자자 1번의 밸런스는 예를 들어서 우리가 300명이 있다고 한다면 300번째 투자자의 작업이 끝나기 전까지 락을 놓지 못하게 됩니다.
따라서 저희가 300명도 사실 많은 단위는 아닌데요. 몇천 명 몇만 명이 된다고 한다면 첫 번째 투자자는 모든 프로세스가 끝나기 전까지 락을 들고 있게 되고 투자자의 계정에 접근하려는 모든 프로세스는 lock timeout으로 죽어버리는 무시무시한 현상이 발생합니다.
이를 해결할 수 있는 방법이 아까 이야기했던 락을 걸고 있는 시간의 개선이에요.
그래서 지금 아까 왼쪽에 지금 보이고 있는 코드에서 우측 코드로 바꾸고 되면 가장 큰 차이점이 무엇이냐 하면 아까 얘기했던 크리티컬 세션이 밸런스를, 끝나는 가장 최후방 단에서 업데이트를 한다는 게 차이입니다.
그래서 아까 얘기했던 리페이먼트라는 프로세스는 밸런스를 작업하는 작업 외 마지막 가장 최후방단인 부분에서 각 코드의 윗 부분에서 업데이트 밸런스라는 것을 빼서 계좌 정보를 업데이트 하는 것을 transaction를 종료하는 것으로써 lock timeout을 회피하게 됩니다.
여기까지가 저의 설명이고요.
잠깐 광고를 한다면 저희 왼쪽 편에 가시면 저희 부스가 있어요. 현재 이번 파이콘에 와서 가장 크게 보고 있는 게 바로 딱 세 분만 채용하고 가는 게 저희 목표입니다.
1시가 안 됐는데 1시부터 저희가 채용과 관련된 패키지를 전달해 드려요. 어제 오셨던 분들은 보셨는지 모르겠지만 파이썬맛이라는 3분 채용 중이라는 패키지를 나누어드리고 있거든요. 한번씩 관심 가져주시고 방문해 주세요. 여기까지가 저의 발표고 질문을 받겠습니다.
-발표해 주셔서 감사합니다. 다시 한 번 큰 박수 부탁드립니다.
질의응답을 진행하겠습니다. 질의응답은 가운데 있는 마이크에 나와서 질문해 주시면 됩니다.
-안녕하십니까? 정말 좋은 내용 공유해 주셔서 감사한데 저도 비슷한 문제가 있어서 질문을 드리고자 하는데 지금 같은 문제가 발생했을 때 작은 단위로 쪼개는 게 어떻게 보면 방법이 될 수 있다고 하셨는데 auto increment 같은 경우에는 이미 충분히 작고 더 이상 쪼갤 수 없다고 저는 개인적으로 생각이 드는데 이런 부분에 대해서 문제가 발생한 게 있는지 또 어떻게 처리를 하셨는지 혹시 공유해 주실 수 있으면 감사하겠습니다.
-저희가 어쨌든 작업을 하다 보면 정말 방금 말씀하셨던 대로 프로세스 최소한의 단위로 쪼갰는데 처리가 오래 걸려서 안 되는 경우가 발생할 수 있는데요. 아직 실제로 적용하지 않았는데 고려하고 있는 방법 중에 하나가 뭐냐 하면 예를 들어서 제가 저희 예제로 얘기를 드리자면 300명의 투자자로 다하기 위해서 최소한으로 했는데도 오래 걸리면 프로세스에서 300명을 다하게 하는 게 아니라 관련작업은 다 끝내고 300명을 5명씩 쪼개서 프로세스를 만드는 방법인데요.
이게 이해가 되셨는지는 모르겠으나 한 번에 한 프로세스에서 300명을 처리하는 게 아니라 5명 처리하고 다시 5명 처리하고 300명될 때까지 돌면서 최대 5명까지만 해서 300명을 처리하는 방식으로 하면 락 걸리는 시간이 줄어들 것이고 여기에서 다만 조심할 것은 300명이 모두 반영되기 전까지 다른 프로세스 간의 데이터가 정합성이 안 맞는 형태를 방지할 수 있게 무언가 특수한 처리를 해 놔야 되겠죠.
예를 들면 저는 계좌에 돈을 기록한다고 한다면 일단 아까 300명짜리 한꺼번에 하는 프로세스에서는 일단 이 사람들에게 입금할 내역에 대한 테이블을 하나 만들어놓고 나서 그다음에 이 프로세스는 종료하게 되고 다른 프로세스를 실행시켜서 5명씩 돌면서 아까 기록했던 5명 가지고 와서 5명 기록하고 끝내고 다시 자기 차례가 오면 5명 가지고 와서 기록하고 끝내고 이렇게 작업하도록 만들어놓으면 아마 되지 않을까 생각하고 있습니다. 이해가 되셨나요?
-안녕하세요? 최준영이라고 합니다. 전에 예제에서 설명해 주셨던 예제에서 질문이 있는데요. 메스티드 transaction 아토믹에서는 가장 바깥에... 이거 말고 가장 전.
QNA.
-마지막 거요?
-QNA 바로 앞에 있던 거죠.
-그 네스티드 락에서는 가장 바깥에 있는 락이 끝나기 전에 커밋이 되지 않는다고 했는데요. 변경된 부분을 보니까 업데이트 밸런스 변경 후에 업데이트 밸런스도 아토믹 안에 있어서 결국에는 업데이트가 된 내용도 커밋이 안 되지 않을까 생각이 들거든요.
그러니까 저것조차도 transaction에 걸려 있기 때문에 모든 루프가 끝나야지 커밋이 되는 게 아닌가 생각이 들거든요.
-이거에 대해서 잠깐 다시 설명을 드리면 결과적으로 제가 여기에서 이야기하고 싶었던 것은 저희가 작업을 함에 있어서 밸런스라는 모델을 초반부부터 락을 잡게 되면 왼쪽에 있는 것과 같이 한 투자자의 밸런스를 초반부터 들게 있게 된다면 통 프로세스가 끝나기 전까지 많은 투자자들에게 굉장히 큰 영향이 오게 되는데 그렇기 때문에 저희가 밸런스에 작업하는 그런 업데이트 밸런스라는 함수를, 롱 프로세스와 관련된 가장 바깥쪽 transaction이라는 가정하에 모든 작업을 끝내놓고 나서 가장 최후방단에서 이 업데이트 밸런스를 작업을 해서 밸런스에 대한 락만 최소한의 시간으로 잡자는 게 사실 이 변경점의 차이점이거든요.
혹시 이해가 가시나요? 그러니까 결과적으로 밸런스가 반영되는 것은 말씀하셨다시피 저 transaction이 모두 끝나기 전까지 반영되지 않습니다.
밸런스에 대해서 락을 들고 있는 게 다른 프로세스에 영향을 주기 때문에 락을 들고 있는 시간을 최소화하자는 방향이 되는 거죠.
-추가 질문 없으시면 이것으로 세션을 모두 마치겠습니다. 발표해 주신 분께 다시 한 번 큰 박수 부탁드리겠습니다. 분실물 접수가 되었습니다. 신용카드 잃어버리신 분은 103호 앞에 중앙 데스크로 와 주시기 바랍니다.