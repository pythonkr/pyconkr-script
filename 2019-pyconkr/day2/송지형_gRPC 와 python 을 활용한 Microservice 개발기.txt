-(사회자) : 발표 일정이 1시 55분에서 2시로 딜레이 되었으니 이점 참고 부탁드
리겠습니다.
안녕하세요.
이번 시간에는 송지형 님께서 gRPC와 파이썬을 활용한 Microservice 개발이라
는 제목으로 40분간 발표하시겠습니다. 원활한 진행을 위해 질문은 발표가 끝난
후 진행하도록 하겠습니다. 그럼 큰 박수 부탁드리겠습니다.
-(송지형) : 안녕하세요.
gRPC와 파이썬을 활용한 Microservice 개발이라는 주제로 발표를 맡게 된 송지
형이라고 합니다. 식사 맛있게 하셨나요?!
저는 여기에 선다고 생각하니까 긴장이 되어서 밥을 안 먹고 물을 들이키니까 물
배가 차서 오히려 체할 것 같아요.
재미있는 진행이 될 수 있도록 노력하겠습니다.
오늘 콘텐츠는 이렇게 진행이 될 예정이에요. gRPC라고 하면 Microservice 아키
텍쳐랑 떼려야 뗄 수가 없어서 MSA를 소개를 드리고, gRPC가 고위주의 레퍼런
스가 많고 개발이 많아서 저는 파이썬 개발자입니다. 그래서 제가 gRPC를 파이
썬에서 쓸 때 어떤 점들을 느끼고 어떻게 사용했는지를 소개를 드리고요.
gRPC가 사용을 하다 보니까 실제로 적용을 하는 데 있어서 쉽지 않은 부분들이
있더라고요. 그래서 그런 것들을 경험들을 나눠드리고, 제가 gRPC를 저희 내부
개발팀에 적용을 하면서 프로그램도 직접 만들었거든요. 그거를 왜 굳이 만들었
는지에 대해서도 소개드리는 시간까지가 이번 시간을 마치게 될 것 같습니다.
저를 간단하게 소개드리면요. 저는 클라우드 엔지니어 쪽 위주로 커리어를 시작
했어요.
KT나 SK 쪽에서 계속 클라우드 관련된 거를 하다가 파이썬을 만나고, 클라우드
가 개발이랑 떼려야 뗄 수가 없거든요. 클라우드 플랫폼 쪽을 개발하다 보니까
지금은 메가존 클라우드라는 회사에서 클라우드 플랫폼을 개발하는 거를 담당하
고 있고 백엔드를 진행하고 있고요.
먼저 소개하기에 앞서서 제가 소개되어 있는 메가존 클라우드를 소개드릴게요.
메가존 클라우드, 들어보신 분 계신가요?! 감사합니다.
(웃음)
저도 메가존 클라우드에 소속된 지는 몇 달이 안 됐는데 여러 가지 기회가 있어
서 합류가 하게 되었고 소개를 드리면 국내 최대의 클라우드 MSP라는 사업자입
니다. 매니지먼트 서비스 프로바이드의 약자고요. 클라우드로 많이 기업들이 옮
겨가고 있는데 여기로 옮겨갈 때 어떠한 방식으로 옮겨갈 것인가, 설계구조를 컨
설팅 위주로 담당하고요.
실제로 구축을 할 때 도움이 필요하신 분들에게는 구축도 담당해드리고요.
그거 플러스 운영까지 담당해달라고 운영도 해드립니다. 클라우드하고 관련된
모든 사업을 총괄해서 맡고 있는 회사입니다.
처음 들어보신 분은 생소할 수 있는데 메가존 클라우드라는 회사의 규모는 거의
아시아에서 가장 큰 규모를 자랑하고 있어요.
자랑할 만하죠.

아시아에서 가장 강력한 특히 아마존 파트너사로 있고요. 고객사는 이정도 됩니
다. 엄청나죠. 이러한 성장성을 바탕으로 메가존 클라우드는 많은 투자자들을 받
고 있어요.
엄청나게 많은 고객사들을 클라우드로 옮기는 데 있어서 많은 도움을 드리고 있
는 회사가 클라우드를 이용하고 있는 수많은 고객들에게 가치 있는 뭔가를 전달
할 수 없을까? 에 대해서 시작한 거예요. 단순히 클라우드를 제공하고 구축하는
데 있어서 도움을 드리는 것뿐만 아니라 플랫폼 같은 거를 얹어서 새로운 가치들
을 추가해드리기를 원했습니다.
그래서 저희는 내부적으로는 메가존 클라우드에서 개발을 맡고 있고요. 새로운
플랫폼들을 개발하려고 여러 가지 시도를 하고 있습니다. 다양한 서비스들을 만
들고 있는데 이런 것들을 안정적이면서도 확장 가능한 플랫폼 형태로 만들고 싶
다는 생각이 들었어요.
여러 가지를 고민하던, 다양한 고민들을 했겠죠. 그중에서도 오늘 주제로 만든
게 MSA랑 gRPC입니다. 두 가지의 키워드에 대해서 이야기를 나눠보는 시간을
갖도록 하겠습니다.
먼저 Microservice 아키텍쳐에 대해서는 많은 분들이 들어보셨을 거예요. MGC
는 메가존 클라우드의 약자입니다. 뭐가 있는 게 아니에요. 새로운 플랫폼으로
제공해드리는 서비스들이 많아요. 클라우드 서비스를 어떻게 하면 관리를 잘하
고 어떻게 하면 고객이 한눈에 잘 볼 수 있을까와 같은 다양한 고민들을 하고 서
비스들을 하나씩 개발하고 있는데 이러한 것들이 어떻게 보면 밀결합된 형태가
아니라 하나의 마이크로 서비스 형태로 구현되기를 설계를 잡았습니다. 이렇게
해놔야지 앞으로 또 클라우드 서비스들이 아마존이나 구글이나 이런 데에서 주
도를 하고 있고, 그러면 서비스들이 어떻게 발전될지를 예측할 수 없어요. 새로
운 피쳐들이 나올 때마다 편하게 사용할 수 있는 거를 고민하려면 새롭게 피쳐를
추가해야 되는데 밀결합 형태보다는 이렇게 연결이 되어야만 저희도 대응하고
민첩하게 관리를 할 수 있다는 판단하기에 마이크로 서비스 형태의 클라우드 플
랫폼을 개발할 수밖에 없더라고요.
그러면 MSA란 뭘까? 생각을 하다가 제가 말하는 것보다는 공신력 있는 사람이
어떻게 MSA를 정의하고 있는지를 보면 좋겠지요.
저보다는 마틴 플로라는 영국의 유명한 분인데 거기서 MSA가 뭔지 정의를 내렸
나 봤더니, 죄송합니다.
Microservice 아키텍쳐 스타일은 하나의 어플리케이션을 작은 서비스 단위로 쪼
개는 개발 기법이라고 이야기를 하면서 관할 서비스들은 하나의 프로세스 형태
로 띠고 있고요. 그것들은 라이트 웨이트한 방식을 사용해서 주로 대부분 다 이
거를 사용하고 있죠. 그래서 통신하는 기법이라고 이야기를 하고 있어요.
저는 여기서 키워드로 잡은 게 스몰 서비스, 작은 단위로 쪼갠다.
그리고 라이트 웨이트, 간단한 방식으로 통신을 하기를 원한다, 이런 것들이 주
로 키워드로 잡을 수 있을 것 같습니다.
거기 말고도 Microservice 점 IO라는 곳이 있는데 여기서 어떠한 아키텍쳐 스타
일인지에 대한 설명들이 나오는데 거기서는 Microservice 아키텍쳐 스타일은 다
음과 같은 5가지 형태의 성격을 띠고 있는 것을 합해서 MSA라고 부른다고 이야
기를 했어요.
유지 보수가 잘 돼야 되고 느슨한 연결, 독립적인 배포가 가능해야 되고, 비즈니
스 기능 중심이고, 작은 팀 단위로 쪼개는 이 다섯 가지의 주 키워드로 잡았더라
고요.
이것들은 제가 사실 살짝 그림으로 표현을 해보려고 노력을 했습니다.

MSA가 어떤 스타일인지 보면 어떠한 큰 목적으로 하는 서비스는 어떠한 큰 서비
스죠. 그것들을 기능별로 쪼갭니다.
유저, 인벤토리, 시크릿 이런 식으로 기능별로 쪼개고요.
독립적인 형태로 최대한 느슨하게 연결을 합니다.
이렇게 해놔야지 어떻게 가능하냐.
하나의 독립적 형태로 움직이게 되면 각 기능별로 따로 따로 개발과 배포와 테스
트들을 따로 돌릴 수가 있어요.
이렇게 되면 좀 더 빠르게 진행할 수 있겠지요.
이렇게 되면 각 서비스마다 팀 단위로 쪼갤 수 있다는 장점이 있습니다.
서비스와 조직을 일치시킬 수 있기 때문에 좀 더 빠르게 서비스들을 개발하고,
민첩하게 갈 수가 있겠죠.
팀 단위로 작은 팀 단위로 소규모로 개발, 그 서비스를 담당하는 개발과 QA와 운
영을 엮어서 팀을 만들 수가 있겠지요.
서비스별로 독립되어 있기 때문에 독립된 형태로 확장이 가능합니다.
요즘 또 클라우드가 많이 나오고 있고 손쉽게 확장이 가능하죠. 그래서 이런 것
들을 예를 들면 어떤 서비스에서, 시크릿을 늘리고 싶으면 빠르게 확장이 가능하
겠지요.
서비스별로 완전히 독립된 형태로 움직이기 때문에 독립기술들을 적용이 가능합
니다.
말하기로는, 어떤 서비스는 자바로도 개발할 수 있고요. 어떤 서비스는 파이썬으
로도 개발할 수 있고, 어떤 거는 노드로도 개발할 수 있고 이런 식으로 독립된 형
태의 개발들을 원하는 방식대로 취할 수가 있는 거예요, 서비스 팀마다. 이런 장
점들이 있다고 MSA를 말하는 사람들이 이야기를 하죠.
또 하나의 가장 중요한 특징 중에 하나가 주로 API 통신을 합니다. 통일되어 있는
프로토콜을 사용해서 서비스들끼리 통신하죠. 그런데 아마 대부분은 RESTful 방
식을 이용하고요.
그런데 제가 여기서 말씀드리고자 하는 건 대부분 RESTful 방식이기 때문에 이
렇게 그림을 그렸고요.
무조건 장점이 있는 건 아니죠. 무조건 옳은 건 없는 것 같습니다. 하나의 장점을
취하면 반대편에는 분명히 따라 오는 단점들이 있죠. 많은 단점이 있지만 그중에
서도 하나를 여기서 주제로 꼽아보자면 이것만 있는 게 아니라 여러 가지가 있는
데, 단점들이. 여기서 하나 뽑을 수 있는 게 서비스가 네트워크를 통한 통신을 많
이 하죠. API이다 보니까. 통신 오버헤드가 증가합니다. 예전에는 통째로 만들어
서 하면 끝났는데 이거를 API 방식으로, 개발복잡도도 증가하고, 통신 오버헤드
가 증가하죠.
REST API 방식을 뜯어보면 1.2 기반을 주로 합니다. 그래서 다 플레이텍스트 기
반으로 헤더들이 존재하고 있고요.
메시지는 헬로라고 있는데 수많은 헤더들이 붙어 있습니다. Response에도 수많
은 헤더들이 있죠. 메시지를 하나 전송할 때도 오버헤드가 이렇게 많이 있다는
거예요. HTTP의 REST 방식이라고 하면 순차적으로 이렇게 보낼 수밖에 없습니
다. 보내는 대로 받고, 보내는 게 제대로 연결이 안 되거나 응답이 안 되면 딜레이
가 걸리는 이런 단점들이 많이 부각이 되기 시작했어요. MSA가 이렇게 통신하다
보니까 통신에서부터 걸리는 오버헤드들이 단점으로 부각이 되는 거죠.
장점으로 말했던 서비스별 다른 언어가 사용가능하다고 했는데, 진짜일까요? 제
가 겪어온 바로는 이게 사실 쉽지가 않죠. 서비스별로 다른 언어를 적용한다? 저
도 예전 회사에서 저는 주로 파이썬을 개발했으니까요.

MSA의 형태로 개발했지만 다른 언어로 적용하는 건 사실상 쉽지 않더라고요.
그래서 제가 회사를 옮기고 이런 프로젝트를 진행하려고 하다 보니까 당연히
MSA의 형태로 가야 될 것 같은데, 계속 그때까지는 Django 기반으로 개발했어
요. Django를 좋아합니다. 그런데 굳이 내가 왜 그런 것들을 했을까? 라는 생각
을, 의문점을 가지실 텐데, 저는 약간의 뭔가 새로운 MSA 형태로 바뀌고 이런 식
으로 방향이 가고 있는데 새로운 트렌드가 뭔지 그리고 여기서 왜 이런 것들이
발전했는지에 대한 궁금증이 있었어요. 그래서 합류하고 프로젝트가 새로 발동
이 되면서 기술들을 서치할 수 있는 시간들이 있었죠.
여기에 특화되어 있는 뭔가가 없을까?를 한참을 뒤지면서 생각해보다가 발견한
게 gRPC입니다. gRPC를 들어보셨는지는 잘 모르겠습니다.
gRPC를 살짝 소개를 드리면요. 이런 식으로 구글이랜다.. gRPC 점 IO에 가보면
이런 식으로 돼 있어요. 높은 성능의 범용적인 RPC 프로그램이라고 소개를 합니
다.
그렇다면 gRPC의 가장 큰 특징은 이렇게 통신 오버헤드를 최대한 줄이려고 하
는 게 목적이었어요.
거기에 특화되어 있는 프레임워크라고 보시면 됩니다.
굉장히 gRPC를 기반으로 해서 gRPC가 또 플러버블 하거든요. 원하는 기능을
갖다 붙일 수 있게끔 돼 있어요, Flask처럼요. gRPC는 구글이 개발한 RPC 기반
프레임워크입니다.
효율적인 통신 프로토콜 고민을 구글에서 하고 있었는데 무려 15년 전부터 구글
에서는 내부적으로 Stubby라는 프로젝트를 통해서 이것들을 시스템으로 내부적
으로 사용하고 있었는데 MSA의 형태가 유행을 하게 되고 컨테이너나 클라우드
가 발전을 하면서 MSA 형태가 빠른 형태로 발전하기 시작합니다.
그래서 각광을 받기 시작하고 사람들이 수많은 고민이 있다 보니 구글에서는 내
부적으로 사용하던 이것들을 외부로 공개하자고 해서 오픈소스로 발동을 시킨
것이 gRPC라고 합니다.
제가 사실 처음 gRPC라는 걸 들어봤던 거는 2, 3년 전이었던 것 같아요. 그때 저
는 게임사를 다녔는데 게임사가 엔씨 소프트라는 곳인데 그곳에서는 의외로 클
라우드 네이티브 컴퓨터 파운싱이라는 요즘에 주목을 받고 있는 오픈소스 재단
이죠.
여기서는 수많은 오픈소스들을 여기서 인큐베이팅합니다. 여기에 참가하는 회사
만 어마어마하고요. C&CF 쪽에 한국에서 가장 먼저 참여한 소프트가 엔씨소프
트예요. 저도 항상 검색하고 이런 게 있다고 찾아보다가 gRPC라는 걸 처음 들어
왔어요. 이런 게 있구나, 정도만 알고 직접 사용할 줄은 몰랐습니다. 회사를 옮기
고 새로운 것을 찾다 보니까 gRPC 이런 게 있었지? 이거를 써보자고 해서 한참
찾아보니까 이게 굉장히 관심도도 높아지고 있고 요즘에 많이 주목을 받고 있구
나, 라는 결론이 이르렀어요.
사실은 저도 그렇게 막 얼굴에서 보다시피 엄청 오래된 개발자는 아니거든요.
ᄒᄒ
그래서 RPC라는 개념을 저도 실제로 써보지는 않았어요. 이런 개념이 있구나,
정도만 알고 있었고 예전에는 거기서 처음 들었고 저는 주로 REST 기반으로 개
발을 했어서..
RPC가 뭔가? 이거 왜 다시 이렇게 꺼내들고 나온 건가? 하고 자세히 뜯어보니까
RPC가 뭔지 봤더니 이런 약자고요. 마치 여기서 실행하는 것처럼 하는 거예요.
Method를 하나 정의하는 거죠. 그리고 내부에 어떠한 방식으로 인해서 클라이언
트 쪽에서 굳이 REST로 URI를 정하지 않아도 마치 내가 외부에 있는 서버 쪽에

있는 Method를 콜하듯이 쓸 수 있는 거예요.
코드가 굉장히 간결해지는 거죠. 그리고 RESTful의 HTTP 규격도 필요 없어지고
Method와 이것만 전달을 하면 마치 내부적인 함수를 불러다 쓰는 것 같은 효과
를 주는 거죠.
마치 다른 서비스와 통신을 하지만 로컬에서 Method를 사용하는 것처럼 보이게
하는 기술이고 그게 RPC의 주요 특징입니다.
그렇다면 이것이 왜 다시 한 번 다시 나타났냐.
한번 생각을 해보니까 그림이라고 하면 제가 쳐다보다 보니까 1990년대에 유행
했던, 레트로가 유행하고 있는데 타미힐피거의 패션 잡지랑 2018년도의 타미힐
피거의 잡지에 있던 화보랑 거의 차이가 없죠. 유행은 돌고 도는 것 같아요.
유행이 돌고 돌기 때문에 다시 RPC가 튀어나왔냐고 생각하기에는 RPC의 장점
들이 조금 있었습니다. RPC가 어떠한 장점들을 가지고 있는지를 조금 더 깊게
살펴볼게요.
gRPC의 가장 큰 특징이라고 한다면 첫 번째로는 이 Protobuf를 꼽을 수 있을 것
같아요.
아마 써보신 분들은 Protobuf에 대해서 이해할 수밖에 없습니다. gRPC를 쓰려면
무조건 이거를 써야 되거든요. 그렇다면 Protobuf는 무엇인가 봤을 때 이거를 개
발한 것도 구글입니다. 구글이 설명한 것들을 제가 살짝 가지고 와봤더니 이렇게
설명하더라고요. Protobuf 플렉서블하고 효과적이고 통신 체계를, Protobuf이 정
의하는 방식인데 gRPC에서 Method를 하는 것처럼 뒷단에서 자동으로 한다고
했는데 뒷단에 이러한 것을 처리하는 거라고 보시면 될 것 같아요.
좀 더 작고 빠르고 심플하다고 이야기합니다.
이게 어떤 특징을 가지고 있냐를 내부적으로 조금 더 살펴보면 이런 식으로 돼
있어요. 서버 클라이언트가 메시지를 정의하는 역할을 Protobuf가 담당하고요.
실제 통신 시에는 이것들을 바이트 스트림으로 시리얼라이저시켜 버립니다. 그
래서 데이터를 인코딩해서 하고, 그러다 보니까 그것보다 좀 더 빠르고 작은 형
태라고 이야기를 하고요.
Protobuf도 가지고 가다 보니 Protobuf는 통신 메시지는 Protobuf가 담당을 하고
그 외의 구현 쪽은 각 언어에 맞게끔 하면 되게끔 독립되게 분리가 될 수가 있어
요.
Protobuf를 처음에 쓰시려면 어떻게 해야 되냐면 구글에서 정의하는 IDL이라는
랭귀지입니다.
Protobuf를 사용하기 위한 랭귀지를 배우셔서 그거로 작성을 하시고 그거를 각
언어에 맞게 빌드하는 과정을 거치셔야 돼요. 빌드하면 그 언어별로 사용할 수
있게끔 떨어집니다. 그런 것들을 이용을 해서 gRPC 서버를 파이썬으로도 구현
할 수 있고, 노드로도 구현할 수 있고 이런 식으로 되게 돼 있어요.
내부적으로 MSA의 형태에서 거의 대부분의 백엔드 서버들은 파이썬으로 개발
하고 있지만 이쪽은 노드로 하고 있어서 클라이언트는 노드로 개발하고 있죠.
Protobuf로 빌드를 하면 자동으로 코드가 생성이 됩니다.
통신 채널과 구현부가 분리가 돼서 서로 다른 언어로도 되고요.
또 다른 특징으로 하나를 꼽자면 HTTP2일 것 같아요.
gRPC랑 Protobuf랑은 독립적인 기술이죠. 하지만 이 gRPC가 이거를 통신할 때
HTTP2 기술을 이용을 하기 때문에 굉장히 많은 장점들을 가져갈 수가 있습니다.
이 HTTP2 기술을 간략하게 설명을 드리면 이거는 완전히 새로운 프로토콜은 아
니고요. 그동안에 REST로 이동했다가 이러했던 이유는 복잡해서 모르겠고 우리
가 친숙한 HTTP 기반으로 가자고 해서 간 거였거든요. 그런데 이 gRPC도 그 장

점을 그대로 취하려고 했던 건데 HTTP가 통신하기에는 오버헤드가 있으니까 이
거를 단순화 시켜서 경량화 되고 HTTP 기술을 새롭게 만든 게 2 기술입니다. 그
래서 1.0 기술을 그대로 쓰지만 문법이나 그런 거를 그대로 가져가지만 그거를
조금 더 퍼포먼스 위주로 살리려고 했던 게 HTTP2 기술입니다. 속도 향상을 위
해 이런 식으로 처리를 했어요, 2에서는.
이거에 대한 장점을 그대로 gRPC가 취할 수 있다는 거죠, 이거를 이용해서 통신
을 하니까요.
그래서 데이터를 얘네는 예전에는 HTTP 1.0대 기술에서는 이거를 반드시 리퀘
스트를 묶어서 보내고 받아서 했던 방식이라면 이거는 데이터 프레임이라고 해
서 프레임으로 나눠서 동시에 여러 개를 보낼 수 있어요, 1에서는 안 됐거든요.
동시에 보낼 수 있고 동시에 받을 수 있습니다.
예전에는 웹을 보시면 웹 사이트에서 서버 쪽에 요청을 하죠. 요청을 하고 받은
다음에 그 받은 거를 기반으로 해서 다시 그 안에 있는 예를 들면 자바 스크립트
파일이라든가, 아이콘 파일이라든가 이미지 파일을 다시 재요청을 하고 또 다시
받습니다.
이런 여러 가지의 스텝들을 거치게 되는데 2에서는 이것들을 다시 재전송하는
게 아니라 어차피 서버가 다 알고 있거든요. HTTP 파일을 가져갔고 그 안에 여러
가지 파일이 있다는 거를 기술하고 있기 때문에 서버가 푸쉬해서 넘기는 거예요.
헤더 자체도 줄여주죠.
여러 가지 기술들을 통해서 이런 사이트가 있더라고요.
봤더니 HTTP와 이것을 비교한 닷컴인데 HTTP와 피에스랑 비교한 게 아니라 내
부적인 상세한 설명을 보면 2.0을 기반으로 했기 때문에 빠르다고 합니다.
에스가 2.0 기반으로 설정돼서 속도가 빠르다.
그림에서는 몇 배 빠르게 돼 있죠. 저도 해보니까 굉장히 빠르더라고요.
그리고 커뮤니케이션을 할 때 양방향 스트리밍을 적용할 수가 있습니다.
서버와 클라이언트가 동시에 주고받을 수 있어요.
우리가 흔히 이야기하는 게 1번 기술이죠.
RPC라고 해서 하나를 주고 하나를 받는 형태가 아니라 클라이언트가 서버한테
요청을 하나만 보내더라도 서버가 클라이언트한테 굉장히 다수의 요청된 결과를
스트리밍 형태로 나눠서 보낼 수도 있고 반대가 될 수도 있고 양방향으로도 가능
합니다. 이러한 것들이 gRPC의 특징이라고 할 수 있을 것 같아요.
그러면 gRPC를 어떻게 파이썬에서 이용하냐? gRPC는 사이트에 가보시면 아시
겠지만 튜토리얼에 보면 굉장히 다양한 언어들을 지원해요. 그중에서도 저희는
파이썬이 짱이죠.
그렇죠? 다양한 언어 중에서도 저는 파이썬을 골랐습니다. 이거를 어떻게 쓰냐.
사용법을 간단하게 브리핑을 해서 설명을 드리면요.
먼저 Protobuf를 사용하셔야 돼요. Protobuf를 IDL를 이용해서 작성하시고 익혀
야 돼요. 어렵지는 않아요. IDL를 이용해서 작성하시고 파이썬에 맞게 빌드하시
고 빌드된 파일을 이용해서 gRPC의 파이썬으로 서버를 구현하시면 됩니다.
이거는 제가 내부적으로 짜고 있는 것들인데 일부로 발췌를 해온 건데 IDL로 정
의한 Protobuf입니다.
RPC라고 해서 이런 식으로 정의를 했죠. 그러면 클라이언트에서는 이거는
Method 형태로 바로 콜해서 쓸 수 있습니다. 예전에 HTTP로 방식으로 하면 이렇
게 해야 됐다면 이거는 마치 함수에서 그냥 갖다 쓰듯이 쓸 수 있고요.
Response도 이렇게 정의할 수가 있습니다.
오른쪽은 Response로 정의한 거고요.

이렇게 정의한 Protobuf를 파이썬에서 사용 가능하게 변환하는 작업이 있어야 되
는데 이런 식으로 툴을 지원해줘서 명령어 한방이면 이거를 유저 점 Protobuf을
하게 되면 피비2 라는 파일과 이렇게 파일로 나뉘어져요.
이 파일을 봤더니 피비 투 점 바이는 메시지 정의에 사용될 클래스들이 들어 있
어요. 그래서 까보면 바이럴의 형태로 떨어지는 게 아니라 읽을 수 있습니다. 까
보면 파이썬 파일이니까요.
클래스들이 자동으로 만들어져서 정의가 돼 있어요.
업데이트 Request 이런 것들이 정의가 돼 있고요.
이것들을 서버에서 구현을 하실 때 유저 피비 투 gRPC를 임포트 하시고 이것들
을 호출하셔서 사용하셔야 됩니다.
서버를 구현할 때 어떻게 하느냐.
실제 유저를 구현하실 때는 Protobuf를 통해 생성된 이 피비2 언더바 gRPC의 이
것을 자동으로 되게, 내가 유저라고 IDL를 통해서 정의하게 되면 이런 식으로 이
름이 자동으로 생성이 됩니다.
그것들을 서브 클래스로 가서 구현하시면 돼요.
실제 Method는 이런 식으로 구현하시고 서버를 띄울 때는 gRPC 점 서버라고 해
서 IDL를 통해서 생성되어 있는 유저 서비스 투라는 클래스가 있는데 그것들을
이용해서 띄우시면 됩니다. 자동으로 생성해 주고 저희는 사용을 하기만 하면 됩
니다. 서버를 띄우고요. 클라이언트 쪽에서는 gRPC 채널을 하나 생성하시고 스
톱이라고 돼 있죠. 유저 피비 투 gRPC 하고 유저 스톱 이런 것들을 클라이언트
쪽에서 선언을 하시고요.
그다음에 RPC 통신에 사용할 Method를 호출하시면 돼요. 아까 IDL에서 정의했
던 겟유저 이런 식으로 스톡에서 Method를 불러서 사용하시면 됩니다.
시작하면 그 메시지가 통신이 되고 있는 상황들을 볼 수가 있으실 거예요.
설명만 들어보면 굉장히 쉽죠, 그렇죠? 그런데 이게 끝일까요?
항상 현실은 어려운 것 같아요.
제가 직접 사용을 하다 보니까 Django랑 비교할 수밖에 없겠더라고요. 저는
Django를 사랑했으니까요.
ᄒᄒᄒᄒᄒ
gRPC는 가만히 보니까 MSA에 특화되어 있는 서비스 간 메시지 성능 향상에 집
중한 프레임워크라고 보시면 돼요. 통신에 집중되어 있는 특화된 프레임워크이
라고 보시면 됩니다. 그러다 보니까 Django를 쓰더라도 이런 다양한 기능들이 있
지요.
이런 기능 때문에 쓰는데.. 패턴 적용 가능하고 다양하고 기타 꿀기능이 가능한
데 이러한 것들이 gRPC는 하나도 없어요. 굉장히 그리워지더라고요.
Protobuf 관리가 생각보다 쉽지가 않아요. Protobuf가 어떻게 돼야 되냐면 빌드
해서 나온 파일들을 예를 들면 유저, 인벤토리, 빌링, 시크릿 그 서비스마다 내가
통신하고 싶은 상대편 서비스와 통신하려면 IDL를 통해서 작성된 Protobuf를 하
면 빌드가 떨어지는데 그거를 배포해야 되는데 배포하는 것도 일인 거예요.
Protobuf를 서버와 클라이언트가 모두 가지고 있어야 되는, 다 쪼개놨는데 개발
한 지 얼마 안 됐는데 5개, 6개 넘어가고 있거든요. 그런데 그거를 관리하고 배포
하는 게 쉽지가 않습니다.
테스트를 해야 되잖아요, 개발자들은. 개발자들은 내부에서 각자 다른 환경을,
저도 로컬에서 주로 개발하고 다른 분들은 서버에서 개발하고 이런 분들이 많이
계신데 이런 것들을 통합 환경으로 제공해 주는 게 없어요. 빌드하는 과정 자체
가 귀찮은 일이더라고요. 100개를 다 설치해야 되고 디펜더스 봐야 되고 빌드 수

행해야 되고 그래서 내부적으로 아예 gRPC를 잘 쓰기 위해 프레임워크을 하나
만들자고 된 거예요.
누가 보면 할 일이 없어 보이는데 이런 게 필요한 것 같아서 내부적으로 올리기
위해서 만들었습니다. 내부적으로 이렇게 나왔어요. API라는 것과 코어라는 것
과 서비스 세 개로 나눴고요.
그중에서도 API는 Protobuf를 관리하는 부분입니다.
API 내부, 저희가 소스를 바로 공개를 드릴 수는 없겠지만 이런 식으로 디렉터리
를 다 나눠놓고 이런 식으로 빌드를 해요.
패키지 쪽 폴더에는 Protobuf, 버퍼, 빌드를 위한 것들이 있고요.
프로토라는 디렉터리에 IDL 파일을 여기에 작성합니다.
그리고 빌드 디렉터리 안에 빌드할 수 있는 모든 거를 넣었어요. 한방에 할 수 있
게끔. 그리고 최종 버전은 디스트립에 떨어지게 했습니다.
그런 것들을 동작시키기 위한 것들을 체계화 시켜서 넣어놨고요.
그러면 Protobuf를 빌드하고 배포는 어떻게 하냐? 이렇게 했어요. 내부적으로
Makefile 을 만들었고 서버를 엮어서 간편하게 만들려고 노력했습니다. 하다 보
니까 이렇게 되더라고요.
개발자는 각자 개발 환경이 있겠지요. 거기에 다 깔려 있습니다. API라는 풀을 받
아서 소스를 받아서 프로토 디렉터리 안에다가 자기가 작성한 IDL을 넣습니다. 1
번이라고 써 있죠. 프로토콜을 작성합니다. 그리고 3번 필드 디렉터리 안에서
Make 파이썬을 치면 알아서 컨테이너가 올라와서 빌드를 알아서 하는 과정을 거
치게끔 만들어놨어요.
그래서 Makefile을 직접 작성하면서 내용을 보면 도커런을 하는 과정들이 보이시
죠.
빌드 점 파일에 보시면 이렇게 Protobuf을 빌드하는 내용들이 써 있습니다.
테스트를 하고 개발이 완료된 내용들은 서버 쪽으로 푸쉬를 하면 자동으로 이렇
게 되는데 거기에 파이썬 패키지 파일, 묶어서 바로 배포할 수 있게 만들어놓은
거죠. 젠킨스가 할 수 있게끔 만들어놨습니다. 이렇게 하니까 Protobuf를 빌드하
고 사용하기가 편해지더라고요.
코어랑 서비스 쪽을 살펴보면 여기는 프레임워크 이야기인 것 같아요. 저희의 목
적이 뭐였냐면 Django 같은 거를 만들어보려고 내부적으로 비즈니스적으로 프
레임워크에 종속되지 않도록 하고 모델 레이어를 최대한 분리를 시켜서 DB라던
가 다른 메시지들을, 만약에 gRPC가 망할 수 있잖아요. 망하면 저희는 gRPC로
개발했기 때문에 이 비즈니스 로직들이 gRPC에 최대한 종속적이지 않게끔 만드
는 게 목적이었어요.
이렇게 다 나왔습니다.
그것들을 받아서 쓰고 있는 API 영역들도 만들어놨고 서비스 레이어 등등 이런
개념을 저희가 내부적으로 프레임워크를 만들어놨어요.
API 쪽은 gRPC 관련된 메시지 처리를 다 API 라는 기능에서 다 처리하게, 라이
브러리에서 다 처리하게 만듭니다.
사실은 개발할 때 비즈니스 로직을 개발할 때는 gRPC에 대한 신경을 아예 쓰지
않도록 만들어놓은 거예요. 알아서 다 처리 되게, 그래서 앞단에 부르기만 하면
자동으로 처리되게 만들고요.
서비스 쪽은 진짜 실제로 비즈니스 로직 위주의 내용들이 들어가는데 거기에도
API를 만들도 보면 여러 가지 기능들이 필요하거든요. 이런 것들이 굉장히 많은
데 그런 것들을 다 데코레이트로 처리할 수 있게끔, 그래서 그것만 하면 자동으
로 밑에 파라미터가 체크가 된다던가, 그 사이에 이벤트룰러를 통해서 사이사이

에 들어가야 될 것들을 간단하게 넣을 수 있도록 만들어놨습니다.
매니저 친구는 DB나 다른 서비스를 연동할 때 데이터 핸들링이 가능하도록 만든
거고요.
최종적으로 gRPC도 또 다시 메시지를 만들어서 엮어서 또 다시 던져줘야 되는
데 그것도 귀찮아져서 인포라는 라이브러리에서 되게끔 짜놨어요.
죄송합니다...
비즈니스 로직에만 신경을 쓰게끔, 어떻게 보면 라이브러리를 만든 거죠. 개발속
도를 올려서 API를 찍어낼 수 있도록 계속 찍어낼 수 있도록 귀찮고 반복적인 작
업들은 라이브러리에서 처리하도록 만들어놨어요. 개발한지는 얼마 안 됐습니
다. 써보니까 나쁘지 않네, 라는 생각이 들더라고요. gRPC를 써보려고 하는데 패
턴이라든가 프레임워크도 전혀 없고 메시지 처리에만 집중돼 있다 보니까 gRPC
의 Django가 돼보면 어떨까 라는 생각이 들어서 써보다 괜찮으면 오픈을 할 생각
입니다.
오픈소스를 오픈했을 때도 안 쪽팔리게 짜고 있어요. 개발한지가 얼마 안 돼서
여기서 빵 공개했으면 좋겠지만 아직 준비가 안 됐어요.
원래는 제가 gRPC 쪽이랑 연결해서 어떻게 하면 배포를 할 수 있을까 했는데 수
정을 했고요. 서비스 구축이나 배포 같은 것들은 메가존 클라우드이다 보니까 클
라우드를 마음껏 쓸 수 있는데, 저희 팀에 또 스피네이커 장인이 있는데 개발한
것들을 배포하는 서비스 중에 하나인데 배포툴 중에 하나인데 스피네이커를 잘
사용하는 분이 있어서 잘 도입해서 쓰고 있고요. 이런 주제에 대해서 또 한 번 발
표를 할 수 있는 자리가 있었으면 좋을 것 같다는 생각이 들더라고요.
거의 종료가 된 것 같은데.. 시간이 살짝 남으니까 혹시나 궁금한 점이 있으시면
질문을 해 주셔도 될 것 같아요.
-(질문) : 질문 드려도 될까요?
-(송지형) : 시멘틱 버전이라면?
-(질문) : 버전을 올리거나 할 때.. 수정을 하실 때 버전 관리들을 어떻게 하시는
지.
-(송지형) : 버전 관리에 대한 부분도 중요한데 아직까지는 저희가 거기까지는 생
각을 못 했는데 중요한 주제라고 생각해서 아직 만들어진지 얼마 안 돼서 중요한
주제라고 생각하는데 내부적으로 고민 중에 있습니다. 그 부분에 대해서 이 자리
에서 설명드릴 만큼 경험이 많지가 않아서요... 그렇습니다.
-(질문) : 팀 내부에서 REST API 대신에 gRPC를 사용해서 Microservice를 하면
보통.. 여러 가지로 될 텐데.. 그럼에도 불구하고 왜 했는지..
-(송지형) : 방금 말씀하신 대로 gRPC를 사용하게 되면 통신이 불가능하잖아요.
그런데 gRPC에서 뭘 만들었냐면 컨테이너를 올리면 변환해 주는 친구가 다 있
어요. 외부랑 통신을 하거나 REST로 통신할 수 있도록 배포를 해서 RESTful를
받을 수 있게끔 하고 있습니다.
-(사회자) : 발표 시간이 종료되어서 세션을 마무리하도록 하겠습니다. 지금까지
발표해 주신 송지형 님께 큰 박수 부탁드리겠습니다.
-(박수)
혹시 질문이 있으신 분은 밖으로 나와서 질문해 주시면 감사하겠습니다.

