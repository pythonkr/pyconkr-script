https://youtu.be/94R6MnMPOJI

[발표자: 구영민]
-(사회자) 이제 마지막 시간입니다.
조금만 힘을 내주세요.
이번 시간 끝나고 103호에서 Lighting Talk가 진행될 예정입니다.
이게 뭔지 모르시는 분 계시나요?
Lighting Talk는 5분 동안 발표를 하는 거고요.
오늘 즉석 이 자리에서는 아니고 아침 9시부터 홈페이지를 통해서 받고 있습니다.
Lighting Talk는 거의 다 마무리 돼서 오늘은 신청을 못 하시고요. 마지막까지 남아서 Lighting Talk까지 즐기고 가셨으면 좋겠습니다.
2분 뒤에 시작을 하도록 하겠습니다.
진짜 마지막 시간입니다. 이번 시간에는 '테스트에 걸리는 시간 92% 줄이기' 주제로 구영민 님 발표해주시겠습니다.
큰 박수 부탁드립니다.
-(구영민) 안녕하세요. 저는 '테스트에 걸리는 시간 92% 줄이기'라는 주제로 발표를 하게 된 구영민입니다.
일단 4시 40분, 거의 마지막 시간인데 많은 분 와주셔서 감사하고요.
간단하게 말씀을 드리면 왜 테스트에 걸리는 시간이 92% 줄었냐?
그냥 기본적으로 말씀드리는 건 너무 비효율적으로 테스트를 짜고 있었다.
비효율적인 테스트를 효율적으로 바꾸는 과정에서 이것저것 사용한 팁에 대해서 설명을 드릴 예정입니다.
한 가지 퀴즈를 드리겠습니다.
여기 코드가 하나 있는데요. 이 테스트가 있는데 이 테스트는 100명의 사용자를 만드는 테스트입니다.
과연 몇 초가 걸릴까요?
데이터베이스 인서트 100번쯤 하니까 길어봤자 5초 걸리지 않을까 싶은데 20초가 걸렸습니다.
100명을 만드는데 20초가 걸리는 건 되게 이상한 일이잖아요.
이거에 대해서 왜 이렇게 되는지 봤는지 정답은 Django는 기본적으로 비밀번호를 저장할 때 해시처리를 합니다.
이게 늦어서 그런 거예요.
그래서 제가 첫 번째 말씀드릴 주제는 Password Hashing라는 주제입니다.
기본적으로 비밀번호를 어떻게 웹서비스에서 저장하는지에 대해서 설명을 하면요. 비번은 복호화하면 안 되도록 처리를 해서 저장을 하는데 보통은 해시 함수를 이용해서 저장합니다.
해시 함수는 입력된 값이 복호화가 안 되게 암호화를 하는 단방향 암호화라고 간략하게 설명을 드릴 수 있는데요.
해시 함수라는 건 되게 빠르게 처리가 돼야 되기 때문에 한 번만 하면 되게 빨라요.
그런데 해커가 비밀번호 테이블을 들고 와서 무차별적으로 때리면 금방 나오겠죠.
그래서 키 스트레칭라는 걸 보통 씁니다.
키 스트레칭이라는 건 어떤 거냐면 비밀번호가 맞는지 확인을 하는데 어느 정도 보통 0.2초 이상 걸리게 하는 거예요.
왜냐하면 유저가 로그인을 하는데 0.1초, 0.2초 크게 신경을 안 쓰거든요.
해시 함수를 계속 하는 걸 15만 번 정도 반복하면 0.2초 정도 걸리게 됩니다.
Django는 따로 지정을 안 하면 기본적으로 PBKDF2_SHA256 여기 알고리즘를 쓰는데 몰라도 됩니다. 웹서비스 보안을 늘리는 데는 좋은데 이게 테스트 시간을 늘리는데 일등공신을 합니다.
아까 100명에 20초 걸렸죠. 밑에 보시면 테스트가 하나 돌았는데 20초가 걸렸다고 나와 있는데요. 그래서 어떻게 하면 되느냐?
테스트 환경일 때에는 비밀번호 해싱 알고리즘을 빠른 거로 교체를 해서 사용을 하고 있어요.
예를 들어서 MD5PasswordHasher라는 게 있는데 이거는 10년, 20년 그 정도 전에 만들어져서 10년 전에 이건 위험하니까 쓰지말라고 많은 곳에서 쓰지 말라고 하는 알고리즘입니다. 그런데 저희는 테스트에서는 쓸 거예요.
왜냐하면 이게 빠르거든요.
그런데 이 설정을 프로덕션에서 사용을 하시면 안 됩니다. 되게 취약하기 때문에요.
그러면 설정을 변경하고, 다시 테스트를 하면 그냥 아무것도 하는 거 없이 그냥 이 설정만 추가를 하는 것 뿐인데 20초 걸리는 테스트가 0.034초 걸립니다.
이렇게 하면 저희 내부적으로는 10분 정도 줄어든 거 같아요.
두 번째로 말씀드릴 주제는 Mocking이라는 주제입니다.
혹시 Mocking 들어보신 분 계신가요? 아무도 없는 거로 하겠습니다.
Mocking이라는 건 기본적으로 가짜 객체인데요. 메소드 호출에 대해서 고정된 응답을 반환, 실제 객체처럼 동각하면서 파라미터 등 검증할 수 있는 객체입니다.
그런데 솔직히 이것만 봐서는 뭔지 모르실 거예요.
예를 들어서 말씀드릴게요.
보통 갑사들이 요청하면 다 해줘야 합니다. 대량으로 호출을 하는, 예를 들어서 이런 사례가 있다고 해봐요. 대량으로 외부 호출을 해야 하는데 1분에 10개 보내주세요. 우리는 로직을 짜는데 이게 정말로 잘 도는지 테스트를 해보는 거예요.
코드를 보시면 아시겠지만 어떤 거를 하고, 그다음에 time.sleep을 하는 겁니다.
이런 거는 운영 단계에서는 반드시 필요한 거예요. 왜냐하면 갑사가 요청했기 때문에, 그런데 테스트 환경에서는 이게 시간만 소요합니다.
TestCase를 작성해볼게요.
오른쪽은 이 로직에 10초를 잘 쉬는지 테스트를 하는 겁니다. 이 테스트를 돌려보면 통과합니다. 그런데 불필요하게 10초 정도 아무것도 안 하는 거예요.
그러면 time.sleep을 써볼까? Mocking을 써볼까? 그냥 테스트 하려는 함수 위에 mock 이거를 해서 어떤 함수를 Mocking 할지 정해주면 됩니다.
아까 이 테스트를 해보면 실패해요. 왜 실패하냐면 sleep으로 쉬어야 하는데 안 쉬는 거예요.
그런데 테스트가 즉시 완료되기는 해요.
여기서 한 가지 라이브러리를 소개를 하려고 합니다.
freezegun라는 게 있는데 이 라이브러리를 사용하면 시간이 흐르지 않고도 실제로 시간이 흐른 것처럼 처리를 할 수 있어요.
그래서 저희 회사는 시간을 많이 다루는 거예요. 그럴 때 freezegun 라이브러리를 많이 사용하고 있고요.
예시 코드를 보여드리는 이렇게 걸어버리면 이 함수에서는 2019년 1월 14일로 찍히게 되는 거예요.
그러면 아까 봤던 실패한 테스트 함수에 이렇게 freezegun이라는 라이브러리를 적용하면 아까 패치를 한 이거에 이 함수가 불렸을 때 어떤 동작을 하느냐? 이거를 지정할 수 있어요.
이거를 이렇게 해주면 아까 10초 걸렸던 테스트가 0.045만에 끝나고 실제 10초를 쉬는지 검증할 수 있습니다.
한 가지 꿀팁을 알려드리면 이 모킹한 객체가 그러니까 진짜로 time.sleep을 1번만 걸었어? 검증을 할 수 있는데 이렇게 여기 나온 것처럼 하면 정말로 이 함수가 잘 호출됐는지, 예상한 대로 호출됐는지 검증할 수 있습니다.
세 번째는 Transaction TestCase를 사용하지 말자는 겁니다.
처음부터 설명을 드릴게요.
테스트는 다른 테스트에 영향을 받으면 안 돼요.
이러면 2개의 테스트가 있는데 하나의 테스트에서 만든 객체를 두 번째 테스트에서 읽을 수 없어야 해요.
즉, 테스트 케이스에서 생성한 데이터를 삭제해야 하는데 Django에서는 DB 데이터를 삭제하는 똑같은 로직인데 다른 방법으로 구현을 했어요.
사용법 똑같은데 실제로 내부 동작이 좀 달라요. TestCase는 클래스랑 테스트 함수를 시작할 때 각각 Transaction으로 감싸게 됩니다.
그래서 클래스가 테스트를 시작할 때 한번 Transaction을 걸고요. 그다음에 Transaction 내부에 Transaction 세이브 포인트라고 하는데, 테스트가 끝나면 ROLLBACK을 합니다.
이런 식으로 TestCase를 상속받으면 이렇게 되는데요.
Transaction TestCase는 테스트가 끝날 때마다 TRUNCATE TABLE으로 데이터를 삭제하는데, 아까 클래스를 시작할 때 Transaction을 거는데 얘는 테스트가 끝날 때 그냥 모든 테이블에 대해서 데이터를 삭제하는 걸 날리는데, 과연 이 2개가 퍼포먼스 차이가 얼마나 나느냐 하면 이거는 저희 피플펀드 내부 시스템인데요.
테스트 환경은 230개 정도의 테이블이 있고요. 데이터베이스는 MySQL 5.7 환경에서 테스트를 했습니다. TestCase는 엄청 빨라요. 한 번 하는 거로는 정확하게 이게 몇 번 도는지 퍼포먼스 테스트가 안 돼요. 그래서 이거를 1000으로 나눠서 테스트를 했어데
Transaction TestCase는 한 번 하는데 1.7초 걸립니다.
이렇게 되면 TestCase는 전체 1600개를 돌릴 때 ROLLBACK에만 걸리는 건 0.9초잖아요. 이거는 무시할 수 있는데 Transaction TestCase는 ROLLBACK 하는데 46분 1초가 걸리는 거예요. 아까운 시간을 ROLLBACK하는데 쓰고 있는 겁니다.
거의 3000배 가까이 느리다고 판단을 해서 저희는 Transaction TestCase를 사용하는 모든 테스트를 날리고 TestCase로 다 이전 했습니다.
그런데 TestCase에서는 못 잡는 Transaction TestCase에서만 잡을 수 있는 몇 가지가 있습니다. 예를 들어서 데이터베이스에는 Lock이라는 개념이 있는데요. 이거는 Transaction 내부에서만 쓸 수 있어요.
이거를 Transaction 외부에서 쓰려면 이거는 Django가 잘못 썼어 하면서 에러를 뱉어요.
그런데 앞에서 말씀드렸는데 TestCase는 Transaction를 잡고 시작해요. 그 말은 로직 안에서 Transaction을 잡지 않고도 Lock을 잡아도 테스트가 통과한다는 얘기예요. 이런 부분에 유의를 해야 하고요.
저희는 개발 환경에서 충분하게 테스트를 하고 배포를 하고 있습니다.
또 하나는 Django에는 on_commit이라는 함수가 있어요.
예제로 말씀드리면 첫 번째 예제는 문자를 그냥 보내는데 중요한 문자예요. 에러가 나면서 당연히 ROLLBACK이 되겠죠. 만약에 이게 고객한테 가는 문자였다면 고객에게 2번, 3번 계속 가는 거예요.
그래서 Transaction on_commit 해서 커밋 될 때 실행을 하는 겁니다.
위의 3개는 방금 말씀을 드렸고요. 네 번째는 특히 한 가지 예시를 말씀드리면 저희도 굉장히 빈번하게 겪고 있는 실수인데요.
Transaction 내부에서 생성한 객체는 다른 프로세서에서 접근이 안되겠죠.
그런데 그 내부에서 Celery로 보냈어요. 그러면 Celery는 그 객체를 못 읽죠. 그러면 작업이 터지겠죠. 그럴 때 on_commit이라는 걸 사용하고 있고요.
on_commit이 어쨌든 Transaction이 성공했을 때 하는데 TestCase에서는 항상 Transaction이 ROLLBACK됩니다. 테스트가 어떤 일이 일어나도 어쨌든 ROLLBACK이에요. 그렇기 때문에 on_commit을 사용한 테스트는 이제 TestCase에서 안 도는 거예요.
그러면 어떻게 하느냐?
제가 찾아봤어요. Django 문서에서는 이거 결과 테스트하려면 Transaction TestCase 쓰래요. 절망적이잖아요.
물론 인터넷에는 굉장히 많은 좋으신 분이 계셔서 이런 코드를 공유를 해주셨어요.
이게 뭐냐면 Django 내부에서 Transaction이 원래 끝나면 자동으로 예약된 훅들을 전부 돌려요. 그런데 이거를 테스트 함수 내부에서 강제로 돌리는 겁니다.
이렇게 하면 TestCase 내부라도 on_commit이라는 걸 테스트 할 수 있는 거예요.
그런데 물론 Django 내부에서 방어로직이 있어요.
그 방어로직은 Variable Annotation라는 함수인데요. 이 함수를 Mocking을 해서 항상 나는 Transaction 외부에 있다고 바꿔버리면 되잖아요.
그렇게 해서 링크를 가보시면 아시겠지만 되게 길게 써 놓은 게 있는데요. 아무튼 이런 함수를 만들어서 쓰고 있고요.
이거를 쓰면 테스트 할 수 있습니다.
네 번째로 병렬 테스트입니다.
병렬이라고 하면 좀 혼란스러울 거 같아서 제가 2가지 예시를 준비했어요.
병렬 처리하는 단위가 TestCase가 되면 왼쪽이 되고, 병렬을 하는 단위가 전체 시트가 되면 오른쪽이 되는 거예요.
2개는 완전히 다른 쪽인데요.
이번에 제가 발표를 할 거는 왼쪽입니다.
만약에 혹시 Django 1.8 이하 사용하시는 분 계신가요?
없겠죠.
축하드립니다. 여러분은 공짜 점심을 얻었습니다.
Django 1.9 이상을 사용하면 별도의 설정 없이 바로 쓸 수 있어요.
그거는 테스트하는 데 Parallel이라는 인수를 붙이면 알아서 됩니다.
다 괜찮아요. 빠르게 도는데 이 예시를 하나 보여드릴게요.
이건 어떻게 깨질 거 같나요?
두 함수는 어쨌든 없는 거를 하니까 DoesNotExist가 뜨지 않을까 하면 틀렸습니다.
이상한 에러가 떠요. 이게 뜨는 것도 괜찮아요. 그런데 테스트가 강제로 꺼져요. 어떤 게 남아있든 상관없이 강제로 꺼집니다.
그런데 이거를 한글로 키만 좀 가져와봤어요.
테스트 도중 django.contrib.aut.models.User.DoesNotExist가 발생했는데 실패했대요. 병렬 옵션을 끄고 돌리면 올바르게 잘 나온대요. 그리고 죽어요.
그래서 제가 조금 파보았습니다.
Django 인터널로는 이게 어떻게 되어 있느냐?
Parallel 테스트가 어떻게 돼 있는지 찾아봤어요.
마스터에서 워커로 테스트를 할당합니다.
그러면 워커는 열심히 테스트를 돌리죠. 그러면 워커 프로세스에다가 테스트 결과를 누적을 하는데요.
누적을 한 다음에 마스터 프로세스는 워커 프로세스에 있는 events라는 객체를 폴링해서 가져오는 거예요.
이거는 그런데 프로세스 간 객체 공유가 맞죠.
그런데 Python에서 프로세서 간 공유를 하셔면 pickle을 사용합니다.
밑에 보면 에러가 있죠? 맨 끝 오른쪽에 에러가 있는데요. 이거는 예외 객체를 넣는 겁니다.
문제점은 보통 모델 밑에 DoesNotExist 이런 게 생기잖아요. 그런데 이거는 pickle이 안 돼요. pickle이 안 되는데 어떻게 해요?
그러면 병렬을 풀래요. 그런데 병렬 풀면 속도가 확 느려져요.
그리고 맨날 하기 귀찮아요.
그래서 찾아봤어요. 아, 이거 혹시 내가 Django에 할 수 있는 거 아니야?
누가 해놨더라고요. 2.1부터는 그냥 되더라고요. 축하드립니다.
제가 든 아이디어는 Django 2.1이나 1.11이나 똑같은 건데 2.1에서 패치한 건 1.11에 적용하면 잘 되지 않을까 생각이 들어서 해봤습니다.
간단하게 말씀드리면 Python 3.3에 추가된 __qualname__ 이거를 하면 동일하게 반영이 되는데요. 2.7을 아직도 사용하고 있다면 좀 유념을 해야 하겠습니다.
저희는 테스트 환경 내부에서만 이거를 쓰고 있고요. 운영이나 개발에서는 안 쓰고 있습니다.
다섯 번째로 말씀드릴 부분은 keepdb with..
Django 프로젝트가 작을 때는 아무런 문제가 없어요. 프로젝트가 작으면 아무리 비효율적이어도 빨리 끝나요. 그런데 이게 코드가 커지고 운영이 계속 되고, 테이블이 많아지면 마이그레이션이 엄청 느려져요.
그러면 테스트를 처음 돌릴 때마다 이거를 처음부터 만들면 엄청 느리잖아요.
그래서 Django에는 keepdb이라는 기능이 있습니다.
이거는 최초로 테스트 데이터를 만들기는 하지만 이거를 계속 재활용해요. 그래서 다음에 테스트를 돌릴 때는 새로 추가된 마이그레이션만 수행하고 그다음에 테스트를 돌립니다. 처음에는 5분이 걸리지만 그 이후에는 많이 줄겠죠.
여기서도 약간 CI에서 돌리려고 하니까 좀 문제가 생겨요.
이거는 왼쪽부터 시간순입니다. 처음에는 어떤 커밋을 해서 테스트를 돌렸는데 OK 놨어요.
다른 쪽에서 소스 코드 정리한다는 컬럼을 날렸어요. 마이그레이션을 만들었어요.
여기까지는 괜찮은데 다시 develop로 돌아오면 소스 코드는 적용이 안 됐는데 DB에서는 적용이 된는 거예요.
그렇다고 이거를 처음부터 돌리면 좀 그렇잖아요. 그래서 MySQL 덤프라는 스크립트를 앞에 추가했습니다.
아이디어는 이겁니다.
develop에 추가되는 소스 코드는 ROLLBACK이 안 돼요.
develop 기준으로 했구나, 이후에 적용한 마이그레이션만 수행해야지 하면서 Django는 잘 수행을 하거든요.
이런 식으로 하면 얼마나 퍼포먼스가 좋아졌느냐? 봤더니 5~10초 걸리게 됩니다. 처음부터 마이그레이션 하는 건 4~5분 걸리는데 5~10초 걸린다는 건 굉장히 시간이 절약된다는 거거든요.
그래서 이거를 저희는 사용하고 있고요.
두 번째는 Linter 아시죠?
다 좋은데 얘는 성능적으로 오버해드가 있어요.
저희가 되게 해비하게 테스트를 돌려서 그런지 모르겠는데 경험상 30% 정도 느려지더라고요. 가끔씩 무한루프도 주더라고요.
그래서 무한루프가 지금 현재 버전도 발생할지 모르겠지만 저희는 1년 반 전에 그거를 겪고 빼버렸습니다.
이게 아예 없애는 건 코드 퀄리티를 위해서 용납이 안 되고, 새벽에 돌리는 거 있그런 건 잠깐 느려도 상관없어요.
개발자가 자고 있기 때문에, 그런데 개발자가 깨 있을 때, 테스트가 끝날 때까지 기다리는 건 테스트가 어쨌든 최대한 빨리 끝나야 하기 때문에 이거 할 때는 꺼놓고, 필요할 때만 켜놓고 사용하고 있습니다.
그래서 얼마나 줄었는대요? 하면 저희는 원래 42~44분 걸렸는데 이게 3.5분으로 줄었어요. 진짜로 3분 30초로 줄어서 저희는 사용을 하고 있고요.
저는 테스트 시간을 줄이는 작업만 했어요. 그런데 이렇게 줄여두니까 개발팀 내부에서 변화가 나오기 시작해요.
전에는 저 이거 당장 배포해야 하는데, 안 하면 안 되는데 그러면 일단 당장 급하니까 테스트 통과하든 말든 배포해요. 그리고 깨지죠.
그런데 이제는 테스트가 빠르니까 바로 배포할게요 하면 테스트 얼마 안 걸리는데 테스트 돌리고 하는 게 어때요? 이런 식으로 바뀌었얶
이렇게 되니까 더 자주, 더 부담 없이 테스트를 돌릴 수 있게 됐습니다.
제 발표는 여기까지입니다.
질문을 받기 전에 한 가지 홍보를 하자면 저희가 파이콘에 참여를 하면서 한 가지 목표가 있는데 여기 계신 분들 중에서 좋으신 분들을 채용하고자 하는 게 있습니다.
저희가 채용을 하고 있고 궁금하시면 피플펀드 부스 있으니까 거기 가서 상담도 받으실 수 있고요.
감사합니다.
-(사회자) 지금까지 피나는 노력으로 시간을 엄청나게 단축시켜주신 개발자분께 다시 한번 큰 박수 부탁드립니다.
시간이 조금 남았습니다. 질의응답 해주시는 분에게는 후원 도서를 선물로 드리겠습니다. 질문 있으신 분들은 앞으로 나와서 해주시기 바랍니다.
-(플로어) 키노트 보면 DB에 대한 테스트만 나와 있는데 레지스트에 대한 부분은 없나요?
-(구영민) 레지스트를 사용하는 TestCase에서는 그거를 그냥 테스트 끝나고 비우게 처리를 해놨습니다.
-(플로어) 테스트 커버리지 측면에서 어느 정도 되고 있는지 그런 자료는 없나요?
-(구영민) 노코멘트 하겠습니다.
-(사회자) 질문하신 분들은 가지 마시고 앞으로 나와 주세요.
-(플로어) 테스트 빠르게 할 수 있었던 이유가 실제 프로덕션에서 하는 몇 가지를 우회해서 쓰고 있기 때문에 빨라지고 있잖아요.
혹시 그 친구들 때문에 에러가 난 케이스가 있거나 아니면 그거 방지하기 위한 대책이 있는지 궁금합니다.
-(구영민) 없지는 않은데 그냥 그런 경우에는 직접 센트리 들어가서 보고 있습니다.
어쩔 수 없는 거 같아요, 그런 거는.
-(플로어) 지금 예시 보여준 게 ROLLBACK 예시를 많이 보여주셨는데요. 실제로 테스트 했던 것 중 인상에 남는 게 있나요?
-(구영민) ROLLBACK에 대한 거 얘기하시는 건가요?
-(플로어) 지금 강의 외에 실제로 작업하면서 인상 깊은 사례가 있었는지요.
-(구영민) Django 기능으로 만들어진 기능 테스트 해봐야 해? 이런 게 있는데 이건 버전업 하면서 감사를 느꼈습니다. 이런 것도 해야 돼? 하는 부분은 정말 큰 변화가 있을 때 정말 잘 돌아가? 확인할 수 있는 지표라고 생각을 해서 최대한 할 수 있는 부분은 하고 있습니다.
-(플로어) 안녕하세요. Django로 사용하고 TestCase가 꽤 큰 거 보니까 꽤 큰 프로젝트를 운영하는 거 같은데요. 그러면 TestCase는 기능 추가를 할 때 TestCase는 누가 만드나요? 개발자 본인이 만드는지, 아니면 팀 내에서 같이 만드는 경우가 많나요?
-(구영민) 페어프로그래밍이랑 다른 거 같은데 저희는 최대한 개발자 본인이 만들고 있는데 테스트가 없는 경우에는 그 코드를 클린업이나 수정을 하면서 테스트를 만드는 경우도 있습니다.
-(플로어) 그러면 기능이 추가될 때는 개발자 본인이 그냥 혼자 TestCase를 만드는 건가요?
-(구영민) TestCase를 만드는 사람이 동일인인지 물어보시는 건가요? 각자입니다. 기능을 만들고 테스트를 짤 때도 있지만 테스트를 짜고 기능을 만들 때도 있습니다.
-(사회자) 5시 20분까지였더라고요. 가시더라도 밖에서 조금만 더 기다려주시고 Lighting Talk 가시면 되겠습니다.
지금까지 발표를 해주신 구영민 님께 큰 박수 부탁드립니다.
감사합니다.