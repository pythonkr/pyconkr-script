파이콘 코리아 2019
에이유디 사회적협동조합에서 문자통역을 제공하고 있습니다.
...
...
...
...
...
...
...
에이유디 사회적협동조합에서 문자통역을 제공하고 있습니다.
문자통역이란 청각장애인에게 소리를 문자로 통역하여 제공하는 사회 서비스입니다.
-잠시만 기다려주십시오.
...
...
...
...
...
...
...
현재 화면 공유 테스트 중입니다.
잠시만 기다려 주시기 바랍니다.
-안녕하세요?
언제나 프로젝터는 이슈가 발생합니다. 기다리시느라 심심하시죠? 그래서 지루함을 달래기 위해서 QNA를 뒤에 한다는 선입견을 빼고 ^^
QNA를 한번 앞에서 진행해 보겠습니다.
발표 전에 발표자한테 이런 게 궁금하다!
선착순 2명 받겠습니다. 앞으로 나와주세요!
선착순 2명 받겠습니다.
한 분 나오십니다.
-네.
-그냥 가벼운 질문입니다. 지금이 어떤 상황이고 무엇 때문에 문제가 됐는지 대략 몇 분 정도 걸릴지 그게 궁금합니다.
-노트북에 HDMI 연결을 하려고 그랬는데 우연치 않게 연결이 안 돼서요, 그래서 다른 노트북을 가지고 와서 연결을 시도하고 있는 중입니다.
-진짜 DSL에 대해서 여쭤 볼게요. DSL 구성하실 때 시스템 규모나 프로젝트 크기나 이런 것들은 어떻게 고려를 하셨는지 아니면 어떤 상황에서 적합한지 설명해 줄 수 있을까요?
- DSL 사용하기 적합한 환경에 대하여 질문을 하신 건지 다시 여쭤봐도 될까요?
DSL 같은 경우에는 막 쓰면 굉장히 안 좋죠. 프로젝트에. 메타 프로그래밍은 20년 차 이상 안 되면 하면 안 된다는 게, 잘 쓰면 좋은 경우도 많이 있죠.
라이브러리 같은 경우는 많이 사용하고 있는 경우도 있고요. 실제 프로젝트에서 그것을 사용한다면 굉장히 작은 규모로 구성하면 충분히 큰 힘을 발휘할 수 있다고 생각합니다.
-감사합니다.
-지금 혹시 질문해 주신 두 분 앞으로 나와 주실 수 있나요?
책을 이분께서 랜덤으로가 아니라 고르실 수 있게 해 드리겠습니다.
그래도 여전히 해결이 안 되면 한 분을 더 받아도 되겠죠? 네! 앞에 나와서 해 주실 수 있나요?
-안녕하세요? 도메인 스페식이 뭔지 간략하게.
-도메인 스페이식하다는 말은 도메인은 문제의 도메인을 이야기하는 거고 그러니까 게임은 게임 도메인이 있는 거고 금융 도메인이 있겠죠. 거기에 맞게 맞추어진 언어라고 생각하시면 될 것 같습니다.
그러니까 표현력이 조금 더 작아요. 일반 제너럴한 언어보다는.
-해결이 되셨나요? 만족스러웠나요? 감사합니다. 그러면 뒤에 가시면 스태프가 책 고를 수 있게 안내하겠습니다.
지금 갔다 오셔도 돼요. 아직 해결이 안 됐거든요.
이럴 경우에는 발표자도 당황하고 저도 당황하고 여러분도 당황하는.
모두가 한 마음으로 화면이 나오기를...
한번... 해 주고 슬라이드.
나왔습니다.
박수! 박수 쳐주세요.
제가 빠르게 해결해 드리겠습니다.
몇 분 지연됐죠?
소중한 이름이니까요.
(짝짝짝짝짝짝)
-한 12분 정도 늦었지만 언제나 사고는 날 수 있는 거죠.
일단 Python 으로 만든 DSL이라는 주제로 발표하게 된 Las입니다.
저는 라스라고 하고요. 함수형 프로그래밍을 굉장히 좋아합니다. 작년에도 이 주제로 발표했는데요. 그래서 스칼라나 다른 언어들을 좋아합니다. 그다음에 아직 고등학교를 다니고 있고 그리고 블로그랑 트위터를 운영하고 있습니다.
이 발표의 목적은 DSL이 무엇인지 여러분에게 분석드리는 내용이 아니라 DSL이 있다는 것을 소개하고 이렇게 재미있는 것도 있고요. 이렇게 할 수도 있구나라고 소개하는 것이 목적입니다.
그리고 여기 계신 분 중에 3분 이상 집에 돌아가서 DSL을 만들어본다면 저는 굉장히 기쁠 것 같아요.
여러분들은 회사에서 프로그래밍을 하고 계신가요? Python으로 프로그래밍을 하고 계시는가요?
아, 이러면 안 되는데요.
그러면 한번 생각을 해 봅시다. 우리는 왜 프로그램을 만들까요? 바로 어떤 문제를 해결하기 위해서 프로그램을 만듭니다.
예를 들어 PPT를 발표를 쉽게 할 수 있도록 도와주지만 이번에는 아니었던 것 같고 구글은 웹에서 질 좋은 검색을 도와주죠. 번역기는 번역을 해 주고. 이런 문제를 해결하기 위해서 우리는 프로그램을 만듭니다.
우리는 이러한 문제의 분야를 도메인이라고 정의하죠.
그러니까 어떠한 분야의 도메인의 문제를 해결해 주는 게 우리가 만드는 프로그램입니다.
그리고 이러한 DSL은 저희가 도메인 문제를 해결하는 데 도움을 줍니다. DSL이 뭔지 알아보겠습니다.
이 발표의 주제이기도 한 DSL은.
특화된 컴퓨터 언어입니다.
마틴은 다음과 같이 DSL를 정의하고 있습니다.
DSL은 특정 도메인에 초점을 맞춘 표현력이 제한된 컴퓨터 프로그래밍 언어라고 정의하고 있습니다.
그래서 두 가지를 알 수 있는데 첫 번째는 컴퓨터 프로그래밍 언어라는 거예요.
세상에는 다양한 언어가 있습니다. 한국어, 영어, C나 자바 같은 언어도 있죠. 그러나 이런 일반적인 언어가 아니라 컴퓨터 프로그래밍 언어라는 것입니다.
당연해 보이나요? 나중에 소개해 드릴, 영어와 굉장히 유사한 DSL도 있습니다.
그리고 프로그래밍 언어이기 때문에 문법과 사용법이 존재합니다.
그리고 두 번째는 도메인에 초점을 맞추었다는 것입니다. 아까 이야기했던 저의 목표를 기억하시나요? 우리는 프로그래밍을 통해서 도메인의 문제를 해결하고 싶습니다.
그렇기 때문에 도메인에 맞추어진 언어를 사용하면 이점이 있겠죠. 그런데 제한된 표현력을 가진 언어가 이점이 될 수 있을까요?
A를 할 수 있는 언어가 있고 ABC를 할 수 있는 언어가 있다면 후자 좋지 않을까요?
Functional Programming in Scala 저자로 유명한 루나는 이렇게 얘기합니다. 한 수준의 제약은 다른 수준에서의 자유와 힘으로 이어진다.
GOTO가 있습니다. C언어로 코딩할 때는 프로그래머들이 GOTO를 많이 사용했습니다. 강력하게 편리했죠. 그러나 많이 사용해서 디버깅 하기 어려웠고 그다음에 스파게티처럼 얽힌 언어가 만들어졌죠.
그래서 쓰지 말자는 제안을 했고 절차적 프로그래밍이라는 패러다임이 만들어집니다.
그리고 이 패러다임은 아직도 많이 쓰이고 있죠.
그렇기 때문에 특정 수준에서 제약을 건다면 DSL은 다른 수준에서의 자유와 힘을 얻을 수 있습니다.
그래서 DSL은 언제 사용할까요? DSL는 사용할 수 있는 곳은 많이 있습니다. 그리고 사실 우리 주위에서도 많이 사용하고 있습니다.
가장 익숙하실 사용법은 아마 설정파일일 건데요. 예시를 보면서 진행해 보도록 하겠습니다. 이런 것을 많이 보셨을 것이라고 생각합니다.
도커 파일을 하나 가지고 왔는데요. 아마 Python 개발에 도커를 사용하고 있는 분이 있다면 굉장히 익숙한 코드일 겁니다.
사실 도커 파일도 DSL입니다. 이런 식의 이미지를 만드는 도커 파일을 사용하고 있는 거죠.
그리고 도커가 아니더라도 Gradle나 SBT 같은 게 대표적인 DSL입니다. 그런 것들이 저희의 프로젝트의 모듈을 나누는 것을 도와주죠.
그리고 HTML나 마크다운도 DSL이라고 할 수 있겠습니다.
그래서 DSL를 쓰면 뭐가 좋을까요? 도커가 DSL인 건 알았는데? 일단 DSL 사용하면 코드를 보면 어떤 도메인 로직이 동작하는지 더 명확하게 이해할 수 있습니다.
도메인을 잘 알고 있다면. 그리고 잘못된 사용방법을 제한할 수 있죠.
실용주의 프로그래머라는 책에서는 DSL의 한 챕터를 소비하여 이렇게 이야기합니다.
언어의 한계가 곧 자기 세계의 한계다. 그러니 다른 언어를 사용하면 같은 동작을 하더라도 다른 방법으로 문제를 해결할 수 있다.
그러니 도메인에 꼭 맞는 언어를 만들어서 사용한다면 명료하고 풍부하게 표현할 수 있습니다.
그리고 이런 팁을 주죠. 문제 도메입에 가깝게 프로그래밍하라.
누구나 공감할 만한 이야기일 것입니다.
그리고 도메인 설계하고 있는 분이라면 다들 DSL 한번쯤 만들어 봤을 거고요.
그리고 DSL 사용하면 도메인에 맞는 예쁘고 마법과 같은 코드가 만들어지죠.
그리고 DSL 사용하면 커뮤니케이션 하는 데 도움이 됩니다.
한 가지 예를 들어볼게요. 여러분은 삼각형으로 직각 삼각형을 출력하는 프로그램을 만든다고 해 봅시다.
그리고 프로그램을 일주일 배운 사람이 그 코드에 대해 설명하면 어떻게 할까요?
I는 0부터 1 증가시키면서 이렇게 설명하실 건가요? 아니면.
그런데 이번 발표에서 이야기할 DSL은 모든 DSL를 포함하고 있지 않습니다. 이번에 이야기할 주제는 이 DSL 임베디드 DSL입니다.
임베디드 DSL은 다른죠.
DSL은 도메인에 특화된 모든 언어를 포함하지만 이 DSL은 특정 언어 위에서 동작하는 DSL을 이야기합니다. 여기에서 특정언어 돌아가는 언어를 포스트 언어라고 부르죠.
그래서 이 DSL을 사용하면 어떤 장점이 있을까요?
포스트 랭귀지가 있다면 어떤 게 좋을까
요?
프로그래밍 언어를 만든다면 어떻게 해야 할까요? 컴파일이나 파스는 만들어야 할 거고 파일 읽는 것도 필요할 거예요.
AST도 정의해야 할 거고요. 언어를 만든다는 것은 너무나 많은 비용이 듭니다.
그렇기 때문에 이런 요소들을 호스팅 언어에 맡기게 되죠. 그래서 더 편하게 만들 수 있는 DSL이 임베디드 DSL입니다.
그리고 호스팅 언어 안에서 동작하기 때문에 다른 호스팅 언어와 연동하기 쉽습니다. 여기까지만 보면 감이 안 올 텐데 실제 예를 보면서 이야기하도록 하겠습니다. Python 활용 예시를 몇 가지 볼 건데요.
일단 DAG를 만드는 코드를 생각해 보겠습니다. DAG 다들 아시나요? 모르는 분이 많을 것 같은데요. DAG은 방향이 있고 순환하지 않는 그래프의 일종입니다.
머신러닝이나 플록체인에서 많이 사용하고 있죠.
우리는 1+2+3 을 표현하고 계산하는 그래프를 만들고 싶습니다. 저런 식으로 구현이 가능하다고 나오더라고요. 그런데 이 코드는 복잡해질 수 있습니다. 계산하는 식이 조금만 복잡해 져도 저런 식으로 읽기 힘들어집니다.
1노드를 원에 저장하고 1, 2가 담긴 노드는 투에 저장하고 그다음에 넘버 모델로 2와 3 노드를 곱하고 그다음에 그 결과를 1노드에 더하고 그것을 4에 더하고 뭔가 굉장히 코드도 길어졌죠. 그리고 계산식에 주석이 없다면 알아보기도 힘들 거예요.
만약에 코딩을 일주일 배운 사람이 이 코드를 본다면 어떤 계산을 하는지 알기 힘들 겁니다. 그래서 이 것을 EDSL를 통해서 같은 것을 구현해 보았습니다.
일단 코드를 보시면 노드가 사라지고 컨스턴트라는 게 생겼죠. 그다음에 AddNode MulNode 노드가 사라지고 알기 쉬워줬습니다.
그래서 이 DSL을 사용할 수 있습니다. 이러한 DSL은 Python 파일 내부에서 동작하며 실제로 실행도 됩니다.
여기에서 눈치채신 분도 있을 건데요. 제가 사용한 DSL은 산수 프로입니다.
방금 보셨던 코드는 Tensorflow이며 라이브러리입니다.
즉 Tensorflow는 DSL의 성질을 가지고 있다고 얘기할 수 있어요.
그래서 Python의 사용법뿐만 아니라 Tensorflow의 사용법도 알아야지 Tensorflow를 잘 사용할 수 있습니다.
Tensorflow 만의 사용법 문법이 있으니까요. 다른 예시를 볼까요?
Python에는 맵이라는 함수가 있습니다. 그리고 맵은 다른 함수를 받죠.
간단한 함수를 사용하는 경우에는 괜찮은 점이 있습니다. 함수를 따로 정의하기는 귀찮고 Python에서의 람다는 예쁘지 않죠. 그래서 저런 식의 맵을 꺼리는 분도 많을 것 같습니다.
그래서 두 번째 줄에 있는 코드와 같이 람다를 정의해 줄 수 있는 DSL도 있습니다.
저 방식은 스칼라라는 언어에서 람다를 사용하는 방법과 굉장히 유사한데요. DSL 배웠고 아는 사람이라든가 스칼라를 사용해 봤다면 저 언더바가 들어간 함수가 어떤 노드인지 바로 알 것 같습니다.
사실 이 아이디어는 이 프로젝트에서 시작이 되었는데 한국어 번역도 되고 있습니다. 저도 하고 있는데 Python에서는 지원을 안 하더라고요.
특정 DSL은 특정 문제를 해결하기 위한 것입니다. 파이썬 문법을 확장시켜줄 수 있죠. 그러면 이 DSL은 어떻게 만들 수 있을까요? DSL은 언어이기 때문에 문법 사용방법이 있어야 합니다. 그리고 호스팅 언어 Python 위에서 돌아가야 하기 때문에 기존의 Python 언어를 사용해서 DSL 사용법을 만들어야 합니다. 즉 파이썬 자체를 바꿀 수 없다는 거죠.
그래서 정해진 규칙 안에서 DSL을 만들게 됩니다.
Python의 문법을 바꾼다면 어떻게 해야 할까요? 파이썬 문법을 바꾸는 것은 굉장히 어려워 보이는데요?
Python은 다행히도 언어의 문법을 쉽게 바꿀 수 있도록 구현되어 있습니다.
그러면 어떻게 하는지 고민해 볼까요?
아까 만들었던 DAG 코드입니다.
노드라는 것에 1 담고 원에 저장하고 노드에 1을 넣고 투에 저장하고 있습니다. 두 개를 더했더니 3이 나오고 싶죠. 어떻게 해야 할까요? 이런 방식은 어떻게 구현할 수 있을까요?
다들 아시겠지만 오퍼레이터 오버로딩입니다.
연산적 로딩이라고 하는데요. 오버로딩은 연산자들을 새롭게 다시 만드는 것을 이야기합니다. 그래서 숫자가 아닌 객체들을 더하거나 뺄 수도 있죠. 구체적인 것은 보면서 이야기하겠습니다. 이런 식으로 방금 봤던 DSL을 구현할 수 있는데요. 노드라는 클래스가 있고 그다음에 데이터를 담죠. 그다음에 더블 언어 스코어 언더 바였어요.
그다음에 애드를 통해서 저런 식으로 덧셈을 재정의할 수 있습니다.
그래서 이런 식으로 플러스연산자를 재정의한다면 아까 봤던 것처럼 객체끼리 더할 수 있습니다.
연산자를 재정의하면 이런 식의 재미있는 것도 응용이 가능한데요. FP라든가 스칼라를 사용해 보신 분이라면 이해하실 수 있을 것이라고 생각합니다.
맷처라는 함수가 있고 실행시켜주는 그런 타입맷처입니다. 그래서 아래의 레프트라는 타입에 인자가 들어오게 되면 그냥 출력을 하게 되고 그다음에 라이트라는 타입에 인자가 들어오게 되면 0를 반환하죠.
as라든left라든가 언더바도 함수입니다. 그리고 Python에서는 보지 못했던 왼쪽 화살표. 있는 것을 보실 수 있죠.
사실 이것은 간단한 트릭인데 대소 비교하는 그 연산자와 플러스 연산자를 활용해서 만든 것입니다.
즉 1은 마이너스3보다 작다고 생각하시면 됩니다.
그다음으로 오른쪽에 있는 언더바를 만든 함수 저런 것들은 어떻게 만들 수 있을까요? 전에 봤었던 람다의 개량 버전이죠.
저런 것을 위해서 파이썬이 마련된 게 바로 매직 메소드입니다. 매직 메소드를 사용하면 객체의 여러 가지 행동을 재정의할 수 있습니다. 매직 메소드에는 여러 가지 들이 있는데 연산자를 재정의하는 것도 매직 메소드의 하나이고 그다음에 인덱스를 참조하는 경우 문자열을 반환하는 경우 함수 등을 호칭하는 경우 등 다양한 경우를 재정의할 수 있습니다. 연산자 오버로딩이 있는...
타입을 맞출 필요가 없기 때문에 예를 들어서 플러스 라든가 마이너스를 했는데 아예 전혀 다른 객체가 나올 수 있다는 것이죠.
매직 메소드의 하나인 getAttribute을 이용하면 이런 식으로 특정 요소를 불러왔을 때 저 메소드가 실행이 됩니다.
여기에 보시면 클래스 I를 만들었고 GET ATT라는 메소드를 실행하죠. 그다음에 어펜드를 하게 됩니다. 그리고 자기자신에게 돌려주죠. 저런 식으로 하면 이게 마음에 안 드는데...
어쨌든 이런 식으로 사용할 수 있는데요. i.love.you 이런 식으로 사용이 가능해요 그다음에 워드리스트를 출력하면 아이러브유가 다 워드리스트에 들어있죠. 이런 식으로 어떤 요소를 가지고 오는 그런 것도 전부 다 재정할 수 있습니다.
저런 오버라이트를 해서
다른 DSL에 접목시킨 Flask는 이런 식으로 구축할 수 있습니다. 이것은 Flask 예제를 긁어온 것이고요. Flask 앱을 만들고 그다음에 앱을 라우터하는 방식으로 구현을 하죠.
그다음에 HELLO라는 함수에 저 앱을 라우트 하게 됩니다.
그래서 저 요청이 들어왔다면 저 라우트 되어 있는 아래에 있는 Hello이라는 함수가 나오고 리턴 값이 화면이 나오게 되되죠.
우리는 Hello라는 함수를 괄호치고 싶은 거죠. 그러면 decorator를 사용하면 됩니다. decorator라는 것은 책에 소개된 패턴인데요.
이름 그대로 기존에 있던 어떤 것을 꾸며주는 패턴이에요. 파이썬은 decorator을 문법으로 지원해서 함수를 꾸며줄 수 있습니다. 그리고 눈치챈 분들도 있겠지만 위험도는 그럭저럭이에요. 앞으로 위험도가 많이 나오기 때문에 붙여보았습니다. 바로 이런 식인데요.
decorator라는 함수를 구현하고 그다음에 거기 내부에서 함수를 반환시켜줍니다. 그다음에 함수 위에 decorator라는 것을 감싸고 그래서 함수를 마지막에 실행시키면 decorator 1이 함수를 decorator 해 주는 부분에서 실행이 되고 decorator 2는 저 함수를 실행시킨 부분에서 실행이 되고 그다음에 exec_function은 가장 마지막에 실행이 됩니다.
저런 식으로 순서가 실제 함수를 호출한다고 하더라도 이런 식으로 괄호시킬 수 있는데 이런 식으로 하는 것들이 싸닉이라든가 여러 가지 있습니다.
그리고 저 decorator를 사용했을 때 돌려주는 리턴 값은 함수가 아니거나 객체거나 다른 함수의 값이어도 됩니다.
일단 decorator 오퍼레이터 오버로딩을 봤는데요. 이제 DSL를 본격적으로 만들어보도록 하겠습니다. 마법같은 일을 만들게 되는 거죠.
DSL를 만드는 데 활용할 수 있는 것은 메타 프로그래밍이 있습니다. 메타 프로그래밍은 프로그래밍을 만드는 프로그래밍입니다. 즉 파이썬 코드를 만들고 실행시키기도 하죠.
Python은 충분히 동적인 언어지만 이것을 사용하면 더 자유롭게 여러 가지를 만들 수 있습니다.
루비 같은 언어에서는 메타 프로그래밍을 쉽게 할 수 있고 Python에서도 충분히 시도할 만하죠. 물론 큰 프로젝트에서 많이 한다면 굉장히 힘들어지겠지만요.
그래서 우리는 좀 더 강력한 DSL을 만들어보죠.
코드를 한번 볼까요? 이게 저희가 원하는 DSL인데요. import DSL 하고 굉장히 중요한 유저 아이디가 있나 보죠. 그것을 로그를 찍고 싶습니다. 디버그 용도로 찍고 싶나 봐요. 오른쪽에 보니까 타임스탬프도 찍고 싶습니다. 어떻게 해야 할까요?
어떻게 import 하나만 해서 저런 것을 다 할 수 있을까요? 원래는 프롬 뭐뭐 임포트 해서 가져와야 하잖아요.
메타 프로그래밍 할 때는 exec이라는 함수를 사용합니다. 그리고 위험도는 매우 위험합니다. 많이 쓰면 안 돼요. exec는 문자열로 된 파이썬 코드를 실행시켜줍니다. 함수를 선언하도록 하거나 변수의 값을 변형시키는 것도 가능하죠.
문자열이기 때문에 변수 이름을 여러 가지 바꿀 수 있고 함수 이름을 바꿀 수 있습니다. 그리고 비슷한 이름의 변수를 여러 개 만들 수 있죠. 이런 식으로 굉장히 조금 안 좋은 예시지만 밸류 1 2 3 4 5 6 7 8 9 저런 것을 만들고 프린트할 수도 있습니다.
변수 이름이 정해지지 않은 DSL이나 특정 패턴이 반복되는 게 있다면 이런 식으로 사용하게 된다면 굉장히 좋은 이점이 나오게 됩니다.
이런 식인데요.
파인드 바이에 파인드 바이 에이지 원 원을 한다면 한 가지만 가져온다는 얘기겠죠. 그다음에 파인드 컨테인 네임 앤 오더드 바이 에이지 저런 식으로 한다면 네임이라든가 에이지가 없는 곳에서는 사용할 수 없겠죠. 그러니까 저것을 import 할 때 동적으로 바꿔서 네임이 아니라 성별이라든지 아니면 나이라든지 여러 가지로 바꿀 수도 있습니다.
그래서 저런 좀 더 유연한 여러 가지 다양한 함수들을 정의할 수 있죠. 함수끼리 합칠 수 있고요. 그런데 리턴값이 없습니다.
exec은 실행한다면 무조건 런이 나오기 때문에 저런 결과값을 받아볼 수 있습니다. 그렇기 때문에 결과값을 받아보고 싶을 때는 저 eval을 사용합니다. 함수를 사용하면 단순하게 코드를 실행시키는 것이 아니라 그것을 실행시킨 결과를 리턴을 해 주게 됩니다. 그렇기 때문에 조금 더 복잡한 계산이나 할당을 하고 싶을 때 사용하죠.
exe와 이 리벌레이션을 비교하는 함수인데요. 비슷하지만 리턴이 된다는 것과 리턴이 안 된다는 것의 차이가 있습니다. 그런데 여기에서 궁금해지죠. 과연 저 프린트는 어디에서 가져오고 exec 펑션은 어디에서 저장될까요? 다른 변수들을 어떻게 접근할 수 있을까요? 그 궁금증을 globals이라는 함수에서 해결할 수 있습니다.
globals은 Python에 있는 함수인데요. 잠깐 물 좀 마시고 할게요.
globals는 Python에 있는 함수인데요. 현재 접근할 수 있는 모든 상태들을 저장해 둔 딕셔너리죠. globals은 각각 모듈마다 달라집니다. 각각 파일마다 달라지고요. 그렇기 때문에 DSL 실행한 globals 함수의 결과와 달라집니다.
다른 파일의 globals을 그렇게 어렵지 않습니다. 그러나 함수에서 실행시킨 경우에 조금 애매해집니다.
DSL 모듈에서 exec 함수를 이용해 globals를 실행시키는 함수를 만들고 그 함수를 메인에서 실행시킨다고 하면 그 글로벌가 메인에서 실행했다고 하더라도 반환되지 않습니다.
Python은 콘텍스트가 나누어져 있기 때문인데요. 그곳의 globals가 절대로 실행시키지않습니다. 아무리 해도 안 되더라고요. 그렇기 때문에 다른 좀 더 강력한 방법을 사용해서 바꿀 수도 있습니다.
그런데 이 globals는 여러 가지 재미있는 점이 많이 있습니다.
globals는 함수 매체를 찾아낼 수도 있고 그다음에 이런 식으로 할 수 있는데요.
저 f라는 함수를 선언했죠. 그다음에 함수의 globals를 가져올 수 있고 그다음에 아래 globals 함수로 가져온 globals와 동일하게 됩니다.
그다음에 저기에 딕셔너리이기 때문에 그냥 저런 파이콘이라는 아이템을 추가하고 아래 프린트를 한다면 저 파이콘이라는 변수가 생성된 것과 마찬가지입니다.
그런데 globals를 얻는 게 힘들어지면 어떻게 해야 할까요? 저희는 처음 봤던 import만 해서 룩을 남기는 DSL를 만들고 싶은 거잖아요.
여기에는 함수를 넘겨주기도 싫고 저 globals를 명시적으로 넘겨주기도 굉장히 싫습니다. 그렇다고 프롬을 변이해서 가져 오는 건 꺼림칙하고 뭔지 모를 exec를 실행시키는 것도 꺼림찍하죠. 그렇기 때문에 예쁘게 만들 수 있는 방법이 있습니다.
바로 builtins를 재정의하는 것입니다. 이것은 굉장히 위험한 일인데요. 웬만해서는 하면 안 됩니다.
프린트라든가 그런 함수들은 트루라든가 람다라든가 def라는 게 아니죠. 그냥 처음에 기본값이 저장된 세팅된 함수들일 뿐입니다. 그러니까 바꿀 수 있죠. 그런데 지금까지 알고 있는 지식으로는 아무리 바꾼다고 해도 globals가 다르기 때문에 다른 파일까지 영향력이 가지 않습니다.
import화 하지 않는 이상요.
그거랑 globals를 직접 바꾸지 않는 이상 영향이 가지 않죠. 그러나 방법이 있는데 그 방법이 바로 builtins입니다.
그런 기본값이 있는 함수들은 미리 정의한 함수들은 builtins에 정의되어 있습니다. 코드를 한번 보시죠. builtins는 파이썬의 기본에 포함되어 있지 않기 때문에 import를 해 줘야 하고 그다음에 프린트 함수를 복사해 놓겠습니다. 그다음에 builtins의 프린트를 저런 식으로 바꾸고 그다음에 builtins에 파이콘을 추가합니다. 그리고 프린트를 실행하게 되면 원래 있던 알던 프린트가 아니라 builtins에 있는 프린트가 실행되게 됩니다. 여기에서 강력한 점은 이 builtins가 단순한 한 부분에서 적용이 되는 것이 아니라 모든 부분에서 적용이 된다는 것입니다.
그러니까 저 코드를 실행한 이후에 모든 프린트는 저것으로 바뀌고 모든 영역에 파이콘이라는 변수가 생기게 되는 것입니다. 이런 식으로 import만 해 주게 되면 저것을 실행해서 여러 가지 추가할 수 있습니다.
딱 저희가 원했던 모양이죠.
사실 여기에는 재미있는 점이 있는데 프린트를 복사해 두지 않고 실행하면 프린트가 자기는 자신을 호출하기 때문에 재귀함수가 걸려서 터지게 됩니다.
그런데 다른 이용자들이 정의한 함수나 모듈을 건드릴 수는 없어요. 새로운 것을 재정의하고 추가할 뿐이죠. 그러면 어떻게 해야 할까요? 저런 것을 하려면? 특정 타입의 인스턴스들을 다른 타입으로 바꾸려면 어떻게 해야 할까요?
그래서 준비한 게 있습니다.
바로 가비지 컬렉터입니다.
가비지 컬렉터 GC는 가비지 컬렉터의 약자입니다. 모든 객체를 담당하고 해체하는 역할을 담당하고 있죠. 다른 모듈에서 살아있고 정의된 모든 객체의 인스턴스가 가비지 컬렉터 안에 있습니다.
그런 것들을 globals 가지고 오기 안성맞춤이죠. 그리고 모든 모델에 globals을 가지고 올 수 있죠. 이 GC를 이용해서요.
그래서 정의되어 있는 모든 함수를 얻을 수 있고 그다음에 굉장히 재미있는 친구이기 때문에 한번 관심을 가져주시면 좋을 것 같습니다. 그러나 GC는 알기 어려울 수 있어요. 왜냐하면 파이썬은 실행시키자마자 4000개가 넘는 게 GC 안에 저장이 되어 있거든요. GC를 사용하는 예시를 보겠습니다.
GC는 약자로 GC로 import 할 수 있고요. 그다음에 F 함수를 선언합니다. 그다음에 GC의 겟 오프젝트라는 메소드를 통해서 GC의 리스트를 가지고 올 수 있습니다.
그러니까 저희가 인스턴스화 되어 있는 모든 것들을 다 가지고 올 수 있다는 것이죠. 그다음에 저기에서 함수 타입인 것을 빼내어 활용할 수 있습니다. 그러면 펑션 리스트에는 사용할 수 있는 모든 종류의 함수가 저장되어 있는 것이죠.
그래서 저것을 어떻게 잘 하면 굉장히 멋진 마법 같은 일이 발생하게 됩니다.
그리고 다른 방법으로는 굉장히 강력한 AST를 재정의하는 방법이 있습니다.
AST는 추상 트리인데요. 컴파일라든가 수업을 받으셨던 분들은 다 들어봤을 것입니다.
언어의 문법 자체를 하는 거죠. 그래서 파이썬에서는 이 방식자체를 바꿔버릴 수 있습니다.
그러나 AST를 바꾼다고 해서 재정의한다고 해서 기존의 파이썬의 AST이 바뀌지 않습니다.
AST를 재정의하는 것은 시간 관계상 제외하도록 하겠습니다. 왜냐하면 굉장히 한정적으로 쓰이고 강력하기는 하지만 저희가 원하는 DSL에는 크게 필요가 없었거든요.
그런데 이런 DSL를 사용하면 다 좋을까요? 컴퓨터 사이언쓰 쪽에서 굉장히 유명한 격언이 있죠. 은총알은 없다.
뭔가는 문제가 있습니다. 이 DSL이. 어떤 걸까요? 일단 이해하기 어렵습니다. 도메인에 대한 지식이 없다면 그 코드가 굉장히 난해하고 왜 되는지 전혀 모를 것입니다. 그리고 DSL를 만들고 유지보수를 해야 하는 비용이 있죠.
라이브러리를 가지고 와서 써도 개발이 어려운데 개발을 위한 DSL를 만들어야 한다니... 그리고 도메인 지식과 별개로 DSL를 사용하는 문법도 배워야 합니다.
그리고 저런 구현이 어떤 것을 의미하고 이 DSL에는 어떤 문법이 있는지도 알아야 하죠. 메타 프로그래밍은 프로그램을 해킹하는 것에 가깝습니다. 그렇기 때문에 굉장히 권해서는 안 될 짓을 많이 하죠. 그래서 이런 문제가 있는데.
결국 DSL에 대해서 공부하는 수밖에 없습니다.
Tensorflow 쓰는 방법도 여러 가지고 직접 맞는 DSL 쓰는 방법도 공부해야 하고 라이브러리도 공부해야 하고 굉장히 공부해야 하는 것이 많아보이죠.
사실 DSL은 그냥 하나의 라이브러리라고 생각한다면 굉장히 편하게 될 것입니다.
라이브러리 공부하잖아요. Tensorflow 공부하고 장고 공부하고 Flask 공부하잖아요. 어떻게 하는지 공부하지 않으셨습니까?
그렇다면 DSL 하나의 라이브러리라고 생각하고 공부하면 그게 그렇게 크게 문제될 건 없겠죠. 그리고 많은 라이브러리들이 DSL를 사용하고 있습니다.
그래서 저는 이 DSL을 이용해서 함수형 프로그래밍을 하는 프로젝트를 많이 진행했는데요. 이것을 소개하고 싶었지만 이제 발표가 늦어져서 생략을 할게요. 테스트 커버리지가 100%고 굉장히 재미있는 방금봤던 타임맷처라든가 칼라같은 람다가 포함되어 있는 프로젝트입니다.
여기까지 어떻게 대충 만드는지 설명을 끝냈는데 사실은 여러분들은 모두 DSL를 만들어보셨을 것입니다.
내가 DSL를 만들어본 적 없어. 저거 모르겠고 메타 프로그래밍 해 본 적도 없고 가비지 콜렉터는 뭐냐고 하는 분이 있을 텐데요. 사실 대부분 만들어 보셨을 겁니다.
한 가지 예시를 보면 로그인 하는 것이 있습니다. 그래서 로그인 한 다음에 패스워드랑 아이디를 입력하죠. DSL 같지 않나요?
안 같으신가요?
처음에 얘기했던 도형을 작도하는 프로그램을 예시를 들어보죠. 어떤 프로그래밍 언어가 있다면 가장 좋을까요? 질문을 바꿔 보겠습니다. 전화를 걸어서 친구에게 이 도형을 똑같이 그려달라고 한다면 어떻게 얘기하겠습니까? 별을 하나 찍어서 넘어가고 별 하나 찍고 다음 줄 별 3개 찍고 다음 줄 이런 식으로 설명하실 겁니까?
이 방식은 비효율적 같죠? 설명에서 한 번이라도 실수하면 어떤 에러가 날지 모르고 별이 이상하게 찍힐 수 있죠. 그렇기 때문에 효율적으로 전달해 줄 수 있는 방법이 있습니다. 그런 것들이 DSL입니다.
우리는 이등변 삼각형을 찍을 거야. 그래서 높이는 어떤 것이고 그다음에 대각선은 어떤 길이야라고 찍어줘라고 부탁하는 것과 같죠.
그리고 마지막으로 오늘의 명언 하나를 소개하고 마치겠습니다.
워드 커닝험이 한 이야기인데.
새로운 언어를 만들어내는 것외에는 프로그래밍하는 게 없다.
모두 DSL를 만들어내고 있던 것입니다.
발표는 이만 마치고 QNA를 진행하도록 하겠습니다.
(박수)