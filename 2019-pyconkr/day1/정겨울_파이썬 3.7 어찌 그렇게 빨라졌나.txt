@정겨울 님 강연 내용@
-시작하도록 하겠습니다. 안녕하세요? 이번 시간에는 정겨울 님께서 파이썬 3.7어찌 그렇게 빨라졌나라는 제목으로 45분간 발표해주시겠습니다. 원활한 발표를 위해 질의응답은 발표 후 시간이 남으면 진행하도록 하겠습니다. 그럼 큰 박수 부탁드리겠습니다.
-감사합니다. 저는 이 주제가 약간은 좋아할 사람만 좋아하는 주제라고 생각했는데 꽤 생각보다 많은 분이 발표를 들으러 와주셔서 정말 감사합니다. 이게 사실 저도 이런 주제로 발표할 생각은 없었어요. 그냥 저는 파이썬이 새 버전이 릴리즈될 때마다 뭐가 달라졌지? 어떤 게 달라졌는지 릴리즈될 때마다 챙겨보곤 하는데 오늘 주제가 파이썬 3.7이 빨라진 이유예요. 3.7 이전에도 퍼포먼스 임프루브먼트나 옵티마이제이션 항목도 존재했습니다. 자잘한 개선이 있었고 3.6에서도 싱크 IO의 타이핑 모드를 빠르게 다시 재구현했다, 이런 식의 언급만 있었는데 파이썬 3.7에 들어와서는 옵티마이제이션 콕 집어서 릴리즈했습니다. 중대한 퍼포먼스 임프루브먼트가 있었다. 괄목할 만한 여러 가지 성능 개선이 있었다.
옵티마이제이션 항목을 디테일하게 적어놨으니까 그런 식으로 릴리즈 노트에 적었는데요. 1년 전에 3.7이 릴리즈돼도 빨라졌네 정도만 생각했습니다. 파이썬을 어떻게 사용하는지에 대한 발표를 해도 파이썬 3.7을 소개하면서 가장 빠른 런타임 정도로 소개했고 파이썬 3.7이 지금까지 나온 파이썬 버전 중에서 가장 빠르구나 정도만 인식했습니다. 저도 이번에 기회가 되기 전에 왜 빠른지 살펴보려고 했어요. 옵티마이제이션 항목을 보면 이런 식으로 써져 있는데 bpo가 낯설더라고요. 여기서는 이슈 샵 2334. 벅스 파이선.org. 알기는 알겠는데 낯선 환경이 펼쳐져 있는 거예요. 한 이슈의 이슈 페이지거든요.
거기서 봤을 때 처음에 봤을 때 당황스러웠어요. 뭔지도 모르겠고 나한테 익숙한 화면은 이런 화면인데 PR에 익숙한데 이메일로 패치를 보내서 패치를 적용하는 형태로 개발이 진행됐더라고요. 어떤 패치가 있는지 코드라도 보자 했는데 리뷰 툴이 이렇게 생겼더라고요. 패치 셋 버전이 존재하고 어떤 파일이 변경됐는지 보이고 여기서 저는 손절했습니다. 나는 볼 수 없다. 참고로 2017년 2월부터 C파이썬 개발은 BPO로 사용하는데 PEP가 승인돼서 마이그레이션 진행 중입니다. 저한테는 다행인 소식이면서도 파이콘 발표를 준비할 때는 좋지만은 않은데 파이콘이 기회가 돼서 모르는 거 발표하면 어떻게 네가 공부하겠지? 발표하게 되겠지? 이런 생각이 있었어요.
나는 분명히 파이콘 발표 지원할 때는 각이 보인다. 나 좀 써 봤고 그냥 보면 알 수 있지 않을까 했는데 준비를 하면 할수록 발표 주제 바꿀 수 있나 물어볼까? 임시 보관함에 아직도 들어가 있어요. 그 상태를 지나가서 어느 정도 준비를 하다 보니까 그래도 여러분께 말씀드릴 정도 준비는 됐는데 그래도 이 발표에서 말씀드릴 것과 말하지 않을 내용을 구분하고 싶었어요. 저도 C를 잘 모르기 때문에 새롭게 성능 개선하면서 OP코드가 추가됐는데 씨코드 라인 바이 라인으로 보자거나 C로 파이썬으로 짜 있던 걸 C로 다시 짰어요. 2000줄이 넘는 걸 따라가 보자. 이런 건 오늘 제가 주로 말씀드리고 싶은 내용은 아니고요.
오늘 말씀드리고 싶은 내용은 이런 성능 개선을 대체어떻게 이루어냈을까. C로 다시 짠 것도 있겠지만 성능 개선이 안 짜도 이루어진 부분이 많아요. 아이디어가 어떻게 적용됐는지. 더 알고 싶은데 했을 때 어떤 부분부터 보면 될지. 그리고 몇몇 C코드는 아주 어렵지는 않더라고요. 저는 뱅크샐러드에서 일하고 있는 정겨울이고 오늘 말씀드릴 토픽은 11가지 정도예요. 여러 가지 토픽을 함께 보면서 파이썬 3.7이 어떻게 해서 빨라졌는지 보고자 합니다. 먼저 파이썬의 기본 메서드를 호출하는 게 빨라졌다고 명시돼 있어요. 여기서는 릴리즈노트 수치까지는 적혀 있지 않고 되게 빨라졌다고만 나오는데 클래스 있는 여러 메소드를 최적화했다. 어떻게 최적화했냐. 여기서 표준 라이브러리 같은 것들을 콜렉션즈나 여기에 속한 인서트나 로테이트 메서드, 겟아이템, 그런 거나 리플레이스, 이런 것이 호출할 때 빨라졌다는 내용이고요.
여기서 주목할 만한 건. 사실 그냥 우리가 파이썬 컨벤션 그럴 때 쓰는 선언 컨벤션이에요. 특정 컨벤션에 맞춰서 파이썬의 함수를 선언하면 성능상 이득이 생긴다는 내용이고 기존에는 메서드 다른 컨벤션을 사용하면서 원래는 파이썬의 티풀에서 넘어오면서 성능 향상이 있었습니다. 이거에 대해서 깊게 알고 싶다면 관련 이슈를 참고하면 되고요. 이것도 매뉴얼에 적혀 있습니다. 각각의 컨벤션이 어떤 걸 의미하는지. 메서드 패스트콜이라는 걸 바꾸는 건 포지셔널 아규먼트 개념이 3.7에 도입됩니다. 이 메서드 패스트콜은 쓰면 빠른 대신 키워드 아규먼트를 쓸 수 없게 됩니다. 예를 들면 우리가 스트링에 시그니처 함수를 봤을 때 인자가 선언돼 있는데 우리가 흔히 하듯이 밑처럼 이걸 키워드 아규먼트로 넘길 수 없어요.
어떤 식으로 저한테 컨벤션이 바꿨냐면 예전에는 빨간색으로 선언된 컨벤션이 함수 시그니처 쪽이 바뀌면서 넘어가는 개체 타입도 바뀌고 성능 향상이 일어났고 아먼트 클리닉이라는 개념이 나오게 돼요. C코드로 파이썬을 개발할 때 시그니처 종류가 많고 방금도 봤듯이 컨벤션이 많고 이런 걸 변환하거나 생성하는 데 도움을 받자 한 도구가 아규먼트 클리닉이고요. 이런 식으로 선언해둔 다음에 이 도구를 돌리면 이것에 맞는 함수 시그니처가 생성됩니다. 컨벤션을 따르던 함수를 다양한 메서드가 30% 정도까지 빨라졌다는 게 이 토픽의 주된 내용입니다.
그리고 파이썬 시작 시간이라고 표현했는데요. 시작 시간이 감소했습니다. 리눅스에서는 10% 정도 빨라졌고 이 개선에 있어서 주로 두 가지 아이디어가 주요했는데 하나는 abc 모듈을 C로 다시 짰더니 빨라졌다. 특정 함수를 임포트해서 썼는데 임포트하지 말고 복사해서 사용했더니 빨라졌다는 게 주된 내용입니다. 여기서는 깊게 다루지는 않겠습니다. C로 다시 짠 abc 모듈. 제가 처음에 토픽을 파 보려고 시작했을 때 이거 볼까 했는데 너무 크더라고요. 그리고 내용도 파이썬 코드로 돼 있던 모듈을 C코드로 바꿔 쓴 거예요. 제 생각에는 너무 당연한데? 파이썬으로 짜 있는 걸 C로 짜면 빨라지지.
여기서는 이게 어떻게 정확히 구현이 바뀌었는지는 생략하고 다만 여기서 제가 주목하고 싶었던 건 PR이 한 달간 진행됐어요. 결국에는 머지가 됐는데 파이썬 코어 디벨로퍼들이 300개 넘는 리뷰를 줬고 2000줄이 넘는 변경이 있었는데 그들은 포기하지 않고 파이썬의 성능 개선을 위해서 힘써주고 있다는 사실을 알게 됐고 그러면서도 지칠 법도 한데 지속 가능한 유지보수를 추가하더라고요. 파이썬 생태계, 코어 디벨로프먼트 생태계가 동작하고 있구나 인식했고 두 번째로 말씀드린 게 사이트 모듈에서 사이트 모듈은 인터프리터를 실행할 때 자동으로 임포트되는 거예요. 다른 서브파티 패키지들이 설치돼 있는 경로를 찾고 패스에 추가하는 모듈인데 여기서 시스 컨피그를 임포트해서 사용하고 있었는데 임포트하는 데 무겁다 보니까 시작 시간에서 느리게 하는 범인이었는데 개선에서는 거기서 사용하는 특정 함수들을 임포트해서 쓰지 말고 복사해서 사이트 모듈 안에서 가져다 쓰다.
그럼 느려지지 않을 거야 시도했는데 유지보수 우려가 발생했습니다. 두 모듈 사이에서 암묵적인 관계가 발생하고 어느 하나를 수정했을 때 하나를 수정하지 않으면 이게 서로 버전이 맞지 않는 미스매치가 일어나죠. 개발자들이 논의한 끝에 모듈을 C로 다시 작성하거나 오래되고 큰 모듈에서 필요한 부분만 추상적으로 분리하는 건 너무 큰 작업이니까 네 말대로 필요한 부분만 가져오고 유지보수에서 잊지 않기 위해서 양쪽 모두 주석을 달아줌으로써 누락되는 걸 방지하자 하고. 실제 PR를 보면 이런 식으로 네가 만약에 이 모듈고칠 때는 다른 모듈도 잊지 말고 고치라고 명시해서 해결했습니다.
그리고 또 빨라졌던 부분이 우리가 클래스 인스턴트 메서드 20% 빨라졌다는 내용이에요. 단순히 이게 어떤 특정 함수 호출에 대해서 새로운 OP 코드를 추가했더니 빠르게 됐다는 내용이고 이게 굳이 OP코드를 추가하지 않고 기존 사용하던 걸 최적화하거나 바꾸면 되지 않을까 했는데 많은 부분에서 성능이 하락해서 그건 받아들여지지 않았습니다.
여기서 이 개선 내용을 크게 파지는 않고 만약에 더 알고 싶다면 패치셋을 직접 한번 보면 어떻게 이 OP코드가 구현됐고 어떻게 식으로 동작하는지 알 수 있고 TMI로는 논의를 진행하면서 그동안 스타트윗으로 사용하는 함수가 오른쪽 형태보다 느렸는데 이거로 우리가 빨라질 수 있는 가능성을 찾았다고 좋아했는데요. 오른쪽이 오히려 개체를 다시 생성하니까 느리지 않나 하고 생각했는데 실제로 돌려보니까 오른쪽 형태가 더 빠르더라고요. 아직 적용되지 않아서 여전히 아래 같은 형태가 더 빠르긴 한데 나중에는 이게 더 개선될 수 있기를 기대합니다.
어신크 쪽 토픽을 말씀드릴 건데 쉬어가는 시간이에요. 그동안 C로 짰다 OP 코드 추가했다 그런 내용을 말씀드렸는데 간단한 아이디어로도 성능을 향상할 수 있다는 걸 보여드리고자 합니다.
그래서 이 개선의 내용은 어신크IO에 언제 빨라졌냐면 딜레이 아규먼트로 음수를 넘겼을 때 빨라졌다는 내용이에요. 어신크IO 어떤 때 음수를 넘겨야 하나 감이 안 오는데 딱 한 줄이 바뀌었어요. 처음에는 0으로 넘어오면 슬립 0이라는 걸 기다려서 리턴한다는데 음수면 여기 걸리지 않고 퓨처도 만들고 루프에다 스케줄링도 하고 그랬는데 이걸 변경한 내용이에요. 단순히 옐드밖에 없는. 리턴되는 형태인데 처음에는 원래 음수가 넘어오면 여기서 걸리지 않았고 루프를 가져온 다음에 퓨처를 만들고 퓨처에다 루프 스켈링하고 PR로 인해서 생략하고 패스로 음수일 때는 리턴해라는 식으로 변경한 내용입니다.
그래서 작은 PR은 당일날 제안되고 PR 올라와 2시간 만에 머지 된 아이디어로도 성능 개선을 보여줄 수 있다는 PR입니다.
이벤트 루프 쪽에서 되게 큰 성능 개선이 있었어요. C로 다시 짜기는 짰는데 얼마나 빨라졌냐면 15배나 빨라졌다는 게 주된 내용이고 앞서 말씀드린 바와 같이 파이썬으로 짜 있던 코드를 C로 짰더니 4배 빨라졌다. 그다음에 갭 러닝 루프의 로직을 개선했더니 4배 빨라졌다. 그때 어떤 아이디어를 적용했냐면 캐싱을 사용했는데 캐싱으로 개선된 건 미미하고 OS 겟 PID로 개선했고 이게 성능 향상의 80% 요인이라고 말합니다.
그래서 이게 C로 다시 짠 내용 웬만하면 넘어가려고 했는데 이건 간단한 코드 변경이라서 한번 보여드리고자 합니다. 그래서 처음에는 겟 이벤트루 프가 간단하게 짜 있고 이게 있으면 그 루프를 반영하고 없으면 이벤트 루프 폴리시에서 하나 가져와서 반환해라는 4줄짜리 함수고 C코드로 짜면 장황해집니다. 아까 봤듯이 겟 러닝 루프 가져오는 것도 거기서 끝나는 게 아니라 체크하고 그다음에 노 아규먼트로 겟 이벤트 루프 가져왔는데 레퍼런스 카운트를 감소시키고 최종적으로 반환하고 이런 코드인데 여기서 주된 내용은 겟피아이디를 써서 개선됐다는 내용이에요. 파이썬 OS 모듈 안에 있는 함수를 호출하고 거기서 인티저인지 비교한 다음에 이런 식으로 왜 굳이 파이썬 겟피아이디 써야 하지? 시스템 함수 호출하면 되잖아. 이것 때문에 4배가 빨라졌다는 내용입니다.
보통 UV 루프를 같이 쓰곤 하는데 이 변경 사항은 기존 UV 루프로도 속도가 빨라질 수 없었던 부분을 개선한 사항입니다. 이벤트 루프 자체에 대한 부분을 개선했다면 PR은 그거로도 API를 제공하지 않아서. 기존에는 겟 이벤트 루프 폴리시를 자체적으로 정의하면서 그 이외 부분은 건드리지 못했는데 나머지 내용도 빨라졌다는 내용입니다. 어신켜 IO 쪽에서 게더라는 함수가 있는데 계속 어신크만 얘기 나오는 것 같은데 딱 하나만 남았으니까 기다려주시고요. 어신크IO 계도함수가 15% 빨라졌다는 내용입니다.
여러 가지 함수를 동시에 실행할 때 사용하는 함수입니다. 예를 들면 약간 적당히 가져온 건데요. 뭔가 마이크로 서비스 환경에서 다른 서비스를 호출할 때 그다음 거 호출하고 리턴값 받아온 다음에 호출하면 동시에 실행되는 게 아니라 정렬적으로 실행되는데 한번에 가져오고 싶다고 해서 동시적으로 돌릴 수 있는 게 어신크IO 입니다. 파셜을 사용했던 부분이 있는데 이 부분을 제거했다. 게더 펑션의 내용 안에서 이 부분은 제거했더니 15% 정도 빨라졌다는 내용이고요.
기존 펑션 툴즈 파셜을 어떻게 제거했냐면 읽기 쉽게 쳐낼 건 쳐내고 주요 로직만 남긴 뼈대 내용이에요. 왼쪽이 비포, 오른쪽이 애프터인데 기존에는 마지막에서 펑션툴즈의 파셜을 사용해서 몇 번째 콜백인지 기록한 다음에 매 콜백이 끝날 때마다 리졸트를 가져와서 클로저로 된 리졸트에다 넣어주고 이제 모든 퓨처가 실행이 끝났으면 이프 문으로 검사해서 리졸트를 셋한 콜백을 넘겨줬다면 오른쪽으로 변경했을 때는 왜 굳이 하나하나 끝날 때마다 결과를 넘겨줘야 하지? 다 끝날 때까지 기다리고 끝났는지 검사한 다음에 끝났을 때만 로직 실행하면 되는 거 아니야? 개선한 게 오른쪽 내용입니다. 이프 문 위에는 몇 개나 끝났는지 카운트를 증가시키는 로직밖에 없어요. 진짜 로직은 네가 넘겨줬던 함수가 끝났어, 이 리졸트를 넘겨줄게 하는 내용은 그때 실행되게 변경한 거고요.
그래서 게더 함수가 빨라졌다는 게 2편 내용입니다. 앞서 말씀드렸듯이 이게 어신크IO 쪽 마지막 토픽인데요. 1.17배 빨라졌는데 이프문의 순서를 바꿔서 성능이 빨라졌다는 내용입니다. 그래서 이 개선의 주된 내용은 인슈어 퓨처는 인자로 넘어온 값이 퓨처가 아니면 퓨처로 변환하는 그런 로직을 담고 있는 함수입니다. 거기서 몇 가지 검사를 처음에 몇 가지 검사를 하는데요. 먼저 이프 퓨처 함수로 퓨처인지 검사하고 코르틴즈, 코르틴인지 검사합니다. 그런데 PR을 올린 저자는 인슈어퓨처 대부분 게더함수 안에서 실행되는데 이때 이미 런 언틸 컴플리트나 게더에는 코루틴 함수가 넘어오는 게 더 많아. 코루틴을 먼저 검사하면 성능이 빨라지지 않을까 생각하고 실제로 해봤더니 성능이 빨라졌다는 거고요.
약간 TMI로는 원래 우리가 어신크 하는 함수를 선호는 이런 식으로 함수 시그니처를 정의하는데 코루틴을 생성하는 함수가 되는 겁니다. 아까 예제에서 보여드렸듯이 딜리트, 이런 함수들이 실제로는 함수를 실행했을 때 코루틴이 생성돼서 게더함수로 넘어갔고 퓨처보다는 코루틴 자체를 넘길 일이 더 많으니까 이렇게 이프문의 순서를 바꿨고 성능이 향상됐다는 게 주된 내용입니다. 그리고 우리가 리니지 노트에 봤을 때 어킨스 IO 쪽도 되게 많은 큰 성능 개선이 있었다고 서술돼 있는지 마찬가지로 타이핑 모듈 쪽에서도 되게 많은 성능 개선이 있었다고 적혀 있습니다.
그래서 보면 이제 PEP 560 7배 빨라졌고. 그래서 어떤 점이 변경됐냐면 타이핑에서 제네릭 형식을 더 잘 지원하기 위해서 특수 메서드를 추가했다는 게 주된 내용입니다. PEP 484 때 우리가 구현해서 빠르게 만들었으면 될걸 지금 와서 고쳤냐. 그래서 제네릭의 T를 넘기거나 우리가 흔히 사용하는 식으로 여러 가지 트릭을 사용할 수밖에 없었습니다. 이걸 코드를 봤을 때 우리가 딕셔너리에서 사용하는 메서드를 오버라이드하면 되는 거 아닐까 생각했는데 실제로는 메서드는 클래스에서는 동작하지 않았습니다. 이걸 구현하기 위해서는 여러 가지 트릭들을 쓸 수밖에 없는데요. 이제 그 484가 엑셉트되고 사용된 지 많은 시간이 흘렀고 이제 이 제한을 풀 때가 왔다 해서 제네릭 형식 지원을 위해서.
이런 클래스 겟 아이템이라는 게 추가됐는데 너무 긴 diff로 나와 있기 때문에 생략하고 알고 싶다면 이 PR을 봐주시고 이게 거의 제네릭 타입 때문이었는데 이 제한을 해제해서 개선시켰더니 임포트 빨라졌고 클래스 생성도 빨라졌다. 여기서 유일한 브레이킹 체인지가 발생하는데 기존 사용자가 임의로 던더클래스 겟 아이템 메소드를 내가 마음대로 사용하고 있었을 때 버전업하면 브레이킹 체인지 발생하고 이미 던더메소드는 경고 없이 깨질 수 있다고 우리가 적어놨기 때문에 이 부분은 고려 안 해도 될 것 같다고 합니다. 우리가 파이썬 코드를 짜서 사용하더라도 던더메소드를 임의로 구현해서 사용하는 건 최대한 없도록 사용하는 게 안전하게 사용하는 방법이고.
리스트 정렬 쪽에서도 45~75% 성능 개선이 이루어졌습니다. 정확히 말하자면 정렬 알고리즘의 세부 내용이 바뀌기는 했겠죠. 주된 방식이 바뀐 건 아니고 적용된 아이디어는 리스트 정렬할 때 우리가 정렬할 때마다 두 엘리먼트 타입 검사하는데 그러지 말고 대부분 값이 리스트에 동일한 값이 넘어온다고 하는 게 주된 아이디어예요. 값 비교할 때 미리 프리체크 스테이지를 둬서 타입을 검사해두자는 거예요. 그래서 여러 가지 가정들을 세우고 프리체크 스테이지를 만들었습니다. 기존 사용하던 게 세이프 오브젝트 컴페어. 여러 가지 타입이 한 리스트 안에 있다고 가정한 거고 안전해서 다른 것을 검사해봤는데도 다 실패해서 틀렸으면 폴백으로 디폴트 사용하는 게 세이브 오브젝트 컴페어입니다. 우리가 성능 향상을 가져올 수 있는 가정은 리스트 오브젝트가 같은 타입이라고 하는 것, 같은 라틴 문자열이야. 여러 가지 가정들을 세워뒀고요.
그래서 이런 가정들을 검증하고 만약에 맞았다면 비용이 비싼 안정성 검사를 우회하는 최적화된 전용 함수를 사용하자, 컴페어 함수로 사용하자는 게 주된 내용입니다. 코드를 보면 실제로 이 앞단에서는 여러 가지 체킹들을 합니다. 그래서 리스트를 돌면서 타입을 체크한다거나 플래그들을 껐다 켰다든가 그런 일을 하고 있는데 여기서는 생략하고 그래서 당연히 들 수 있는 의문이 아주 최악의 경우 그럼 이런 가정을 검사하느라 오히려 느려질 수 있지 않나 하는 우려가 있을 수 있고 그 내용도 맞습니다. 최악의 경우에는 기본 동작이 세이프 오브젝트 컴페어로 넘어갈 때까지 15% 느려지기는 하지만 대부분의 경우에서는 웬만해서는 리스트 안에는 다 비슷한 똑같은 타입들이 들어 있으니까 성능 개선은 좋다 그리고 조금 늘어나는 게 아니고 75%까지 늘어지니까 엑셉될 만하다 해서 적용됐습니다.
딕셔너리 복사 쪽에서도 간단한데 큰 성능 개선이 있었어요. 카피 사용할 때 5.5배 빨라졌다라고 돼 있고 이 개선의 주된 내용은 원래 기존 우리가 딕트 카피 할 때 키 밸류를 하나하나 넣어주던 게 기존인데 우리 그러지 말고 기존 딕트 밸류 영역의 메모리를 통째로 복사해서 파이썬은 이제 레퍼런스 카운팅 방식으로 동작하니까 그건 메모리 복사한 다음에 나중에 쫙 돌면서 증가시켜줄 건 증가시켜주자는 게 주된 아이디어고요.
다만 이런 아이디어를 적용할 때 리뷰어는 이거 딕트 카피 잘 사용 안 하는데 유지보수 힘들지 않을까 했는데 저자는 내가 50만 줄 이상 프로젝트에서도 딕트카피를 활발히 쓰고 이것도 성능이 조금 향상되는 게 아니고 크게 향상되는데 충분히 의미있다고 설명합니다. 딕트카피가 빨라졌다는 내용입니다. 마지막으로 11번째 토픽으로는 정규표현식도 빨라졌어요. 케이스 인센서티브 매칭. 우리가 기존 케이스 인센서티브 모드에서는 모든 문자를 몇 가지 최적화를 비활성화해서 사용했습니다. 그런데 이 저자가 한번 살펴보니까 이거 모든 문자가 케이스가 있는 것도 아니고 오로지 2700개 정도 만이 로어 어퍼 케이스가 구분돼 있는데 모든 문자열에 대해서 로어 케이스를 만들고 최적화 비활성화하는 건 우리 손으로 성능을 느리게 하는 거 아닌가 해서 제한을 뒀고 아스키 모드에서는 2700개까지 갈 것도 없이 50여 개 글자만 케이스 구분이 있다 보니까 성능 향상이 비약적으로 된 내용입니다.
그래서 하여튼 이런 식으로 정규표현식도 빨라졌다는 게 이 토픽의 내용이고 끝나기 전에 그래서 어떤 내용 때문에 파이썬 3.7이 빠르다고 하는지 알겠어. 진짜 빨라진 거 맞아? 라고 의문이 들 수 있습니다. 제가 소개해드린 11가지 토픽 중 이걸 다 짬뽕시켜서 성능 비교를 하는 건 의미가 없을 것 같고요. 이중에서 적당히 어울릴 만한 메소드 호출 어신크IO 쪽에서 루프 가져와서 실행하고 우리가 흔하게 사용하는 타이핑모드 정리하는 거 벤치마크를 돌려봤습니다. 그래서 약간은 억지스러울 수 있어요. 이걸 리모트 콜 생각하고 이런 식으로 다양한 어찌 보면 사용할 법한 코드를 3.6과 3.7에서 돌려봤을 때 얼마나 빨라졌나 봤을 때 파이퍼프라는 거로 벤치마킹했고요.
3.7에서는 반절로 줄었다. 절대적인 값이 중요하지 않고 비율로 봤을 때 얼마나 줄었냐 보면 40% 넘게 준 걸 볼 수 있습니다. 그래서 우리가 파이썬 3.7 빨라진 게 맞네라고 생각할 수 있고 제가 끝으로 드리고 싶은 말은 파이썬 3.7 저는 추천합니다. 특히 코드 베이스가 어신크 비동기 쪽으로 많이 이루어져 있다면 3.7 추천하고 파이썬이 느리다고 말이 많은데 저도 동감합니다. 파이썬은 느려요. 하지만 저는 신경쓰지 않고 사용하고 있고 이 링크가 현재 눌려지지 않는데 발표자료 공개했으니까 궁금한 분들은 토픽에 관한 글을 읽어보길 추천합니다. 파이썬 퍼포먼스 임프루브먼트의 특정 코어 디벨로퍼 분들이 되게 많은 기여를 해줬어요. 이분들에게 감사하고 그래서 여러분이 기존 파이썬 3.7? 그래, 그나마 빠르구나 생각했다면 이 발표를 통해서 이래서 빠르구나를 알고 가시는 기회가 되길 바랍니다. 감사합니다.
-발표해주신 정겨울 님 감사합니다. 지금부터 질의응답 시간을 가지겠습니다. 궁금한 점이 있으신 분은 가운데 마련된 스탠딩마이크 앞에서 질문해주시면 됩니다. 원활한 질의응답을 위해서 질문은 1, 2개 정도로 해주시기 바랍니다. 그래야 강연자분도 기억하기 쉽습니다. 세 분 정도만 질문 받겠습니다. 앞쪽 스탠딩마이크로 나와주시기 바랍니다. 참고로 질문해주시는 분께는 도서를 상품으로 드리겠습니다.
-질문 드릴게요. 벤치마킹 자료만 있는데 실제 API나 실제 구현하는 운영상황에서는 사용한 케이스는 없는 건가요?
-일단 저희가 프로덕션에서 3.6 3.7 비교하지는 않았는데 제 생각에는 프로덕션에 사용하는 로직을 반영했고 벤치마크 결과가 3.7이 빨라졌다는 걸 보여주고 있으니까 프로덕션에서도 충분히 유의미하지 않을까 생각하고 있습니다.
-더 질문하실 분 안 계십니까? 발표가 질문 사항이 없으므로 발표 시간을 종료하겠습니다. 세션을 마무리하도록 하겠습니다. 지금까지 발표해주신 정겨울 님께 큰 박수 부탁드리겠습니다. 아까 질문하신 분 가셨나요? 질문하신 분 책 선물 드리겠습니다. 지금부터 15분간 쉬는 시간을 갖겠습니다.