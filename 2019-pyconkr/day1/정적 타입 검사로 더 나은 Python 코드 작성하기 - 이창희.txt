https://youtu.be/KWjGj_0lPro

[발표자: 이창희]
-(사회자) 이제 첫 번째 세션을 시작하겠습니다.
안녕하세요. 이번 시간에는 정적 타입 검사로 더 나은 Python 코드 작성하기라는 주제로 이창희 님 발표해주시겠습니다.
박수 부탁드립니다.
-(이창희) 안녕하세요.
먼저 간단하게 제 소개를 하자면 저는 순천향대학교에서 컴퓨터소프트웨어공학을 전공하다 휴학하고 넥슨코리아에서 백엔드 개발자로 하다가 그만두고 지금 피플펀드 컴퍼니에서 개발하고 있습니다.
Python을 싫어하는 사람은 왜 싫어할까요?
크게 속도가 느려서, 혹은 탭으로 구분하는 게 싫어서, 아니면 Global Interpreter Lock 때문에 좋지 않아서, 이런 이유를 찾았습니다.
그리고 동적 타입 언어라서 싫어한다는 분도 있었습니다. 도대체 동적 타입 언어가 뭐길래 사람들은 싫어할까요?
동적 타입 언어가 있으면 반대로 정적 타입 언어도 있겠죠.
언어는 크게 2가지로 나눌 수 있습니다.
간단하게 두 타입의 차이점을 소개하자면 정적 타입은 컴파일 할 때 객체의 타입이 정해집니다. 이후에 다른 타입으로 바꾸지 못하기 때문에 컴파일 타입 오류를 알 수 있고 그때 수정할 수 있습니다.
반대로 동적 타입 언어는 타입 실행 시 결정됩니다. 객체 타입이 런타임에 동적으로 변경될 수 있기 때문에 유연하다는 장점이 있지만 실행 시 예상치 못한 버그를 만날 수 있습니다.
일반적으로 자동 프로젝트라면 프로젝트에 관여하는 개발자도 적고, 버그도 비교적 적지만 프로젝트가 커질수록 개발자도 많아지고 그만큼 버그도 더 많이 발생할 것입니다.
만약에 이 프로젝트를 동적 타입 언어로 작성했다면 여러분은 프로젝트에서 한 객체를 보고 이 객체가 어떤 타입인지 곧바로 유출할 수 있나요?
객체가 나중에 다른 값이 대입될 수 있기 때문에 바로 유추하기 힘들 것입니다.
그래서 몇몇 동적 타입 언어는 정적 타입 검사기를 도입했습니다.
정적 타입 언어의 코드를 정적 타입 언어처럼 타입 검사해서 테스트나 실행 전에 버그를 발견할 수 있습니다.
결과적으로 정적 타입 검사기를 사용해서 얻는 이득은 크게 2가지입니다.
코드의 가독성이 올라가고 타입으로 발생하고 있는 버그를 예방해줍니다.
오늘 이 세션은 버그 예방에 중점을 해서 얘기를 했습니다.
To Type or Not to Type 이 논문의 연구진은 일정 기준을 만족한 자바스크립트 검사기 등 타입스크립트를 적용했을 때 실제로 버그를 얼마나 예방할 수 있을지 연구했습니다.
전체 버그 중 15%는 미리 예방할 수 있다는 걸 찾아낼 수 있었습니다.
15% 정도의 버그를 미리 예방할 수 있다면 한 번 도입하는 게 괜찮지 않을까요?
그런데 앞에서 연구한 논문은 자바스크립트를 대상으로 했습니다. 그렇다면 Python에서는 어떻게 할까요?
Python은 계속 발전하면서 Python 객체에 탭을 줄 수 있는 힌팅을 계속 추가했는데 펑션, 타입.
이 발표에서 보여드리는 코드는 모두 Python 3.6 이상에서 작성되었습니다.
본격적으로 시작을 하겠습니다.
먼저 가장 기본적인 타이 힌팅입니다. 일반적인 코드와 좀 다른 점이 보이시나요?
변수, 이름 뒤에 콜론, 그리고 타입을 줘서 이 변수가 어떤 타입이라는 걸 나타냅니다.
함수의 미터 타입은 화살표, 그리고 타입을 줘서 이 함수가 결과적으로 어떤 타입을 변환한다는 걸 나타낼 수 있습니다.
Python의 기본 타입이 아니더라도 사용자가 직접 만든 클래스나 파일을 직접 타이핑해줄 수 있습니다.
만약에 저희가 조금 더 타입을 엄밀하게 정의하려면 예를 들어서 string만 담는 리스트를 표현하고 싶다면 이렇게 하면 되지 않을까요?
실제로 이렇게 하면 오류가 발생합니다.
왜냐하면 저기 있는 리스트는 Python의 기본적인 타입이고, 이렇게 하면 오류가 발생하게 됩니다.
만약에 더 나아가서 문자열과 실수 부울 순서, 문자열 키와 바이트 값을 가지는 딕셔너리, 아니면 제네릭 함수와 클래스.
실제로 저희가 코드를 짤 때 자주 사용하는 게 이건데 이런 건 어떻게 표현할까요?
Python 3.5에 추가된 타이핑이라는 모듈을 사용해서 이 문제를 해결할 수 있습니다.
타이핑 모듈에 있는 딕셔너리 등 사용해서 , string만 하는 거와 혹은 string 키를 가지고 값을 넣는 딕셔너리는 이렇게 적용할 수 있습니다.
만약에 여러 개의 값을 담고 싶다면 어떻게 해야 할까요?
예를 들어서 리스트 안에 string과 int를 모두 담을 수 있는 리스트는 이렇게 하면 될 거 같지만 오류가 발생합니다.
오류를 읽어보면 타입 인자가 2개가 들어왔다고 알려주고 있죠.
그래서 저희는 타이핑에 있는 Union 타입을 사용해서 여러 개의 타입을 묶어줄 수 있습니다.
이렇게 하면 string과 int 모두 담을 수 있는 리스트가 됩니다.
다른 정적 타입 언어에서 볼 수 있는 Nullable 타입은 이렇게 적용할 수 있습니다.
조금 더 간단하게 Optional 타입을 사용하면 방금 전과 똑같은 타입을 만들 수 있습니다.
만약에 같은 타입을 여러 번 사용하게 된다면 어떻게 될까요?
이렇게 코드도 짧고 타입이 간단하다면 별로 문제가 되지 않지만 더 복잡한 타입일 경우 매번 그 타입을 적어주기는 너무 고통스럽죠.
이런 경우에는 NewType이라는 타이핑 모듈에 있는 함수를 사용하면 간단하게 사용자 정의 타입을 정의할 수 있습니다.
아까보다 훨씬 깔끔한 코드가 됐어요.
이 예제는 더 타입을 인자로 하는, Sequence한 타입들, 리스트나 string 같은, 제네릭 함수를 구현한 것인데요. 저기 있는 타입에 선언한 T가 제네릭을 나타냅니다.
예를 들어서 first 함수에 인자 S에 넣으면 반환 값은 인터저가 됩니다.
입력받는 타입마저 제한하고 싶다면 타입 변수 선언할 때 허용하는 타입을 인자로 해주면 됩니다.
이 경우는 int, 플롯 값으로 이루어진 Sequence 데이터만 인자로 갖게 됩니다.
이 예제는 간단한 제네릭 클래스를 나타냅니다.
함수를 위한 타이핑 Callable, Callable의 첫 번째 인자는 값으로 받은 함수의 파라미터의 타입의 목록이고 두 번째는 값으로 받은 함수의 반환 타입입니다.
이렇게 해서 함수를 입력받고 f를 사용해서 대신 함수를 호출할 수 있습니다.
기존 함수처럼 크게 다르지 않게 그냥 일반적으로 사용하면 됩니다. 지금까지 여러 예제를 알아봤는데요. 만약에 이렇게 명시된 타입과 들어온 타입의 값이 다른 경우는 어떻게 될까요?
Python으로 그냥 이 코드를 실행하면 아주 잘 작동합니다.
왜 잘 될까요? 우리는 분명히 변수 A는 인티드라고 선언했는데요.
사실 기본적으로 타이핑 모듈은 타입 변수가 어떤 타입일 것이라고 타입을 알려주기만 하지 실제로 이거를 제한하거나 하지 않습니다.
그래서 mypy라는 정적 타입를 붙여줘야 실제로 결과를 얻을 수 있습니다.
설치한 다음에는 mypy 정적 타입 파일을 검사할 항목이나 인자를 넘겨주면 됩니다. 하나의 Python 코드만 검사하고 싶을 때는 이렇게, 여기에 하나의 폴더를 더 추가해서 하나의 파일과 하나의 폴더 통째로 검사하고 싶으면 이렇게 여러 개 넣어주면 됩니다.
아까 보여드린 잘못된 코드를 mypy를 통해 테스트 해보면 타입 관련 오류를 잘 잡아주는 걸 볼 수 있습니다.
string 리스트에 다른 타입의 데이터가 있다고 오류를 띄우고요.
이렇게 예상치 못한 버그 예방할 수 있습니다.
이 코드는 mypy가 실제로 어떻게 처리를 할까요?
잘 될 거 같나요?
사실 이 코드는 오류입니다.
왜냐하면 mypy는 가장 처음 개입된 값의 타입을 그 객체의 타입으로 보기 때문에 변수 X의 타입은 int가 되고 그 뒤에 string이 들어왔기 때문에 이 코드를 오류를 내뿜게 됩니다. 기존의 Python처럼 객체가 여러 동적인 타입을 받고 싶다고 할 때는 타이핑에 있는 Any 타입이라고 타이핑해줘야 합니다. 이렇게 하면 기존 Python의 객체처럼 동작하게 됩니다.
mypy는 기본적으로 많은 부분에 대해서 느슨하게 검사를 해주고, 사용자가 세부적으로 어떤 부분에 대해서 엄격하게 검사하고, 어떤 부분은 느슨하게 검사할지 설정하게 합니다. 그래서 기본적으로 int랑, string이랑 비교를 하거나 그런 경우에는 실제로 오류를 띄워주지 않기 때문에 여러분이 직접 파일 만들어서 해야 하고요.
오늘 이 발표가 좀 살짝 빨리 끝났는데 사실 이 발표는 여러분에게 mypy가 할 수 있는 세세한 부분을 짚어주기보다는 이런 게 있고, 이렇게 사용할 수 있고, 쓰면 이런 부분이 좋다는 목적으로 발표를 해서 좀 더 자세한 부분은 mypy 도움말과 문서를 보시면서 각자 프로젝트에 맞는 설정을 찾아 검사를 하시면 더 좋을 것 같습니다.
직접 써보시면 실제로 하나도 어렵지 않습니다.
아까 간단한 mypy 예제를 보여드렸는데, mypy는 빔, 이맥스 등 다른 언어의 린터처럼 지원해줍니다. 그래서 mypy 레파지토리 여기에 가시면 좀 더 자세한 자료가 있으니까 확인해보시면 좋을 거 같습니다.
오늘 발표는 여기까지입니다. 들어주셔서 감사합니다.
-(사회자) 이제 Q&A를 하겠습니다. 혹시 질문 있으신 분은 앞에 스탠딩 마이크로 오셔서 용기 있게 질문해주시면 감사하겠습니다.
-(플로어) 안녕하세요. 발표 잘 들었습니다. 정적 검사 툴을 직접 회사에서 업무에서 사용하고 있는지, 그리고 그거를 프로젝트나 개발팀 전체로 사용하고 있고, 그리고 이거를 사용했었을 때 실제 어떻게 도움을 얻고 있는지 알고 싶습니다.
-(이창희) 일단 저희 회사가 Python 3.4에서 3.6으로 올라온 지 얼마 안 돼서 전체적으로 적용은 안 되었는데 점차적으로 하나씩 적용할 예정입니다.
-(플로어) 그러면 개인적으로 사용하는 건 개인적으로 봤을 때 어떤 도움이 많이 됐는지 알고 싶습니다.
-(이창희) 저는 개인적으로 Python이나 자바스크립트를 이용해서 프로젝트를 많이 하는데 이 두 언어의 공통점은 둘 다 동적 타입이잖아요. 그래서 실제로 제가 프로젝트의 사이즈가 커지면 이 변수에 뭘 담았는지, 혹은 이 변수가 무슨 타입인지 이름만 보고 유추하기 힘든 경우가 생기더라고요.
그리고 처음에는 분명히 int로였는데 다른 함수에 끝단에 string으로 들어와서 비교하는 데 오류가 생기는 경우가 많아서 mypy나 타입스크립트를 활용해서 사용했습니다.
-(플로어) 혹시 string 형식의 리스트에서 문자열에 대입하는 슬라이드로 이동을 해주실 수 있나요? 그거에 관해서 질문을 드리고 싶은 부분이 있습니다.
저는 타입스크립트로 동적 타입을 접했는데 Python에서는 명시된 타입을 우선 적으로 비교를 하는 게 아니라 값을 비교하는 거 같은데 타입스크립트와 다르게 좀 더 강하게 하는 옵션이 있을까요?
-(이창희) mypy 설정에 보면 좀 더 강하게 하는 게 있는데 여러 가지 플랫을 더 주면 타입스크립트처럼 사용할 수 있습니다.
-(플로어) 배열을 넣었을 때 타입 에러가 나는 예외적인 경우가 있나요?
-(이창희) mypy에서도 기본적으로 None 값은 예외적으로 처리를 해주기 때문에 사실 그렇게 신경쓸 만한 요소는 안 되는데요. 방금 전에 질문하신 것처럼 그 None 값마저 좀 더 강력하게 처리할 수 있는 게 있는데..
-(플로어) 제가 질문하고 싶은 건 순수 Python 3로 돌렸을 때 왜 오류가 나는지 궁금한 겁니다.
-(이창희) 이 부분은 발표 끝나고 따로 답변을 드리도록 하겠습니다.
-(플로어) 저는 방금 질문해주신 분과 같은 부분을 다른 관점에서 질문을 드리고 싶습니다.
지금 mypy 발표 자료를 듣고 이해한 건 mypy가 실행 전에 타입에 대한 검사 목적으로 사용하는 거라고 이해를 했는데 실제로 이거를 런타임으로 돌렸을 때 이런 타입 검사가 이루어지지 않는다고 했는데 이게 맞는지 질문을 드리고 싶고요.
-(이창희) 네.
-(플로어) 객체가 잘못 사용되는 일이 없도록 일부 어떤 행동을 할 때 들어온 인자에 대한 타입 검사를 런타임에서 검사하면 되도록 구현을 하는 편인데... 
-(이창희) 현재 Python에서 검사를 하는 부분은 얘기하신 거 외에는 따로 없습니다.
-(플로어) 그런 사용할 수 있는 라이브러리도 아직 만들어진 건 없는 거네요?
-(이창희) 네.
-(플로어) 발표 잘 들었습니다. 저도 mypy에 대해서 들어보기만 했는데 실제로 실행해본 건 발표를 통해서 처음 봤거든요. 굉장히 흥미롭기는 한데 타입스크립트 경험도 있어서, 문법은 좀 익숙한 면이 있어요.
이질감은 딱히 없는데 사실 mypy를 서비스에 도입한다고 했을 때, 우리가 서비스를 배포하고 그 단계 어느 지점에 들어가야 하잖아요. 개발자 로컬에는 당연히 들어가야겠고, 어쨌든 전체적으로 팀원의 합의를 얻으려면 Python을 오래 했던 사람들 입장에서는 좀 꺼려할 수도 있을 거라고 생각을 하거든요.
그런 부분은 어떤 식으로 해결을 하셨나요?
-(이창희) 실제로 저희 회사에서는 당연히 도입하는 게 맞다는 입장이고 실제로 이거를 적용한다고 해서 저희가 타입을 좀 더 명시해주는 귀찮은 부분 빼고는 서비스 속도나 그런 영향이 하나도 없기 때문에 다들 좀 더 쉽게 적용을 진행할 수 있었던 거 같습니다.
-(플로어) 이런 경험도 있나요? 예상치 못한 컴파일 상의 에러를 잡아서 뭔가 서로 정말 도입하기를 잘했다 하는 이런 사례가 있나요?
-(이창희) 사실 저희가 도입하고 나서 그런 걸 잡은 적은 없는데 오히려 도입하기 전에 버그가 생겨서 도입해야겠다고 마음먹은 의견이 나온 적이 있어서 저희 회사는 긍정적으로 이거를 도입하자는 거 같습니다.
-(사회자) 그러면 이상으로 Q&A를 마치고 지금까지 발표해주신 이창희 님께 큰 박수 부탁드립니다. 질문해주신 분은 책 나눠드릴 테니까 앞으로 나와 주시고요.
지금 2층에서 굿즈 배포 하고 있으니까 아직 안 받으신 분들은 가셔서 받으시기 바랍니다.