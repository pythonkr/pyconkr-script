           <PYCON KOREA 2019>
               [피알앤디컴퍼니]

-안녕하세요? 저는 샐러리의 핵심과 커스터마이제이션 발표를 하게 된 피알앤디컴퍼니의 이지훈이라고 합니다. 
(박수)

저희 피알앤디컴퍼니는 헤이딜러라는 서비스를 운영하고 있고요. 헤이딜러는 고객이 차량을 등록하면 경매를 진행을 해서 딜러를 선택하고 거래까지 할 수 있는 모바일 앱이고 웹도 있습니다. 
저희는 일단 스타트업이고 제가 2017년도 당시에 팀에 합류를 했는데 그때에 비해서 거래량 기준으로 8배 정도 성장하고 있고 성장하는 속도도 계속 빨라지고 있습니다. 
저희 백앤드 팀은 주로 파이썬을 주언어로 사용하고요. 그중에서도 장고라든지 샐러리 같은 라이브러리를 사용하고 있고요. 
그중에서도 오늘 말씀드릴 내용은 샐러리인데 왜 샐러리를 하게 됐냐 하면 샐러리가 접근성은 좋은데 쓰다 보면 예상치 못한 작동들이 있더라고요. 그래서 저희가 했던 삽질들을 좀 공유하면 이 삽질들을 안 해보신 분들은 조금 더 빠르게 개발을 하실 수 있을 것 같아서 공유를 드리려고 합니다. 

일단 내용은 샐러리에 대한 간단한 소개 내용이고요. 그리고 안정적으로 완료하기, 효율적으로 처리하기, 그리고 배포와 커스터마이제이션에 대한 내용입니다. 

일단 샐러리는 메시지 전달을 기본으로 한 비동기 태스크큐이고요. 여기서 작업은 메시지로 표현이 되고 클라이언트는 작업을 요청하고 워커는 작업을 수행합니다. 그리고 브로커는 이 둘 사이에 메시지를 전달하는 매개체 역할을 하고요. 
클라이언트와 워커가 이런 구조에서는 각각 스케일이 가능하기 때문에 클라이언트는 불필요하게 무거운 작업을 하지 않아도 되고 워커는 필요에 따라 확장이 가능하게 됩니다. 

샐러리는 이런 프로토콜을 염두에 두고 만들어졌는데 핵심 아이디어 중에 하나는 최소한 한 번은 전달된다. 메시지를 보낼 때 최소한 한 번은 전달된다는 게 핵심 아이디어 중에 하나고요. 
간단하게 이 프로토콜에 대해서 설명을 하자면 프로듀서는 메시지를 생산을 하고요. 브로커에 보내고 브로커는 컨펌, 확인을 합니다. 그리고 브로커는 다시 컨수머에게 메시지를 전달하게 되는데 컨수머가 다시 브로커에 인정을 하게 되고요. 무언가를 알려준다, 이런 내용인데 이런 식으로 해서 좀 안정적으로 메시지를 전달할 수 있게 합니다. 

그리고 실패하는 케이스에 대해서 어떤 식으로 처리되는지 예시를 들자면 메시지를 브로커에서 컨수머로 보냈는데 컨수머가 메시지에 대한 처리를 완료하고 인정을 완료하지 못하면 브로커 같은 경우에는 이 메시지가 제대로 처리됐는지 알 수 없기 때문에 컨수머에게 다시 보내게 됩니다. 
그렇기 때문에 여기에서는 메시지에 대한 처리를 아이뎀포텐트하게 해야 하고요. 
아이뎀포텐트란 여러 번 실행해도 같은 결과가 나올 때 말할 수 있고요. 수학에서는 함수를 여러 번 호출한 것과 한번 호출한 게 같은 리턴을 한다. 그때 f가 아이뎀포텐트한 함수라고 할 수 있는데 프로그램에서는 어떤 시스템 상태에서 오퍼레이션을 여러 번 적용해도 그 시스템은 같은 상태가 된다, 한번 적용한 것과 그게 그 오퍼레이션이 아이뎀포텐트하다고 할 수 있습니다. 

실생활 예시로 간단하게는 엘리베이터를 잡을 때 저희가 내려가기 버튼을 누르면 한번 누르나 여러 번 누르나 불이 켜져있잖아요. 그런 것과 같은 거고요. 
그래서 아이뎀포텐스를 지켜줘야 AMQP 기반으로 메시지를 처리할 때 안정적으로 처리할 수 있게 됩니다. 

그리고 샐러리를 저희가 이용하는 이유에 대해서 간단하게 말씀을 드리자면 저희는, 저희 팀에서는 일단 파이썬을 주 언어로 하기 때문에 샐러리를 사용하고요. 풍부한 기능을 제공합니다. 타임리미팅이나 스케줄링이나 모니터링이나 오토스케일링, 이것 외에도 이게 있나 싶은 기능은 거의 다 있고요. 찾아보면 있더라고요. 
그리고 좋은 인터페이스를 제공하고요. 샐러리에 컨트리뷰션 가이드라인을 보면 API의 형태가 리더빌리티나 컨벤션이나 퍼포먼스보다 중요하다고 말을 하거든요. 
그래서 일단 뭐 좋은 인터페이스라는 게 명확한 기준이 있는 건 아니지만 좋은 인터페이스를 제공하려고 노력하고 있고요. 그리고 쉬운 장고형 라이브러리로 시작을 해서 인터베이션이 쉽습니다. 

기본 사용예제인데요. 이런 샐러리 앱을 리포트 해서 앱을 생성한 후에 데코레이터를 사용해서 기본적인 파이썬 함수를 태스크로 만들 수 있습니다. 그러면 이 파이썬 함수가 태스크가 됐을 때 그냥 파이썬 함수처럼 사용을 할 수도 있지만 에드 점 딜레이 이런 식으로 하면 비동기적으로 처리도 가능하고요. 
그리고 어플라이 어싱크, 이런 함수를 호출을 하게 되면 실행이 언제 될지에 대해서 명시적으로 설정을 해서 실행도 가능하고 그리고 콜백처럼 다른 태스크를 실행도 가능합니다. 

일단 샐러리는 기본적인 API는 아까 말씀드렸다시피 간단한데요. 잘 이용하려면 이해해야 될 부분들이 있거든요. 그 부분에 대해서 말씀을 드리겠습니다. 
일단 Late.Ack인데요. 중요한 태스크가 실행이 되지 않는 경우가 있을 수 있습니다. 그게 어떤 경우냐 하면 샐러리 워커가 Ack를 하는 시점과 관련이 되어 있는데 Ack는 기본적으로 워커가 태스크를 실행하기 직전에 실행이 됩니다. 
그래서 실패되는 케이스를 보면 실행을 하기 위해서 Ack를 하면 큐에서 제거가 되고 실제로 실행을 하다가 워커크래시가 발생을 하면 이미 큐에서는 제거가 됐기 때문에 이거를 다시 실행할 방법이 없는 거죠. 그런데 Late.Ack를 인에이블 하게 되면 태스크 실행이 완료됐을 때 Ack를 하게 됩니다. 그래서 실행 시 실패를 하더라도 아직은 큐에 있는 안정성이 확보가 되고요. 
이때 중복으로 실행될 수 있기 때문에 태스크가 아이덴포텐트하게 작성되어야 합니다. 

그리고 본인인증 문자가 오지 않아요, 이런 에러가 있었는데 원인을 살펴봤을 때 저희가 외부 것을 사용하는데 이게 간헐적으로 실패를 했습니다. 그래서 통제할 수 없을지 저희는 리트라이를 사용하고 있고요. 이런 식으로 태스크를 정의해서 바인드트루라고 하면 셀프가 아규멘트로 들어오는데 이렇게 하면 리트라이를 실행하게 됩니다. 
최근 버전에서는 이 인터페이스도 되게 간단해져서 이런 식으로 태스크를 정의할 당시에 아큐먼트로 넘겨주면 깔끔하게 정의가 되고요. 
이때 주의할 점은 아토미시티를 지켜주셔야 한다는 거고 아까 말씀드렸듯이 저희는 예상 가능한 것에 대해서만 적용을 하고 있습니다. 

브로커백앤드, 그러니까 새벽에 푸시가 계속 오는 오류가 한번 있었는데요. 이 경우에는 저희가 래디스도 브로커로 사용했었는데 비지블리티 타임아웃이라는 옵션이 있는 걸 모르고 사용했었습니다. 전달 후 일정 시간 내로 Ack 되지 않으면 다른 워커에 태스크를 다시 전달하는 기능인데요. 
예를 들면 어떤 태스크를 비지빌리티 타이머보다 더 나중에 실행을 하게 되면 워커는 이거를 계속 갖고 있지만 브로커 같은 경우에는 이게 없어졌다고 보고 다시 실행을 하게 되는 그런 로직이 실행이 되는 거죠. 
해결책으로는 비지빌리티 타임아웃을 늘리는 게 일단 가장 간단한 해결책일 거고 태스크 작성 시에 고려하기도 해결책이 될 거고요. 

효율적으로 처리하는 방법에 대한 이야기를 할 건데요. 워커가 기본적으로 자신이 처리할 수 있는 만큼 처리하는 구조이기 때문에 처리하는 속도가 쌓이는 속도보다 조금 작더라도 큰 문제는 되지 않습니다. 그런데 이게 지속이 되면 브로커에 불필요한 로드가 가게 되고 실제로 필요한 작업이 진행이 되지 않을 수도 있죠. 
이런 일을 막기 위해서 가장 쉽게 할 수 있는 일은 태스크에 타임리밋을 거는 겁니다. 그래서 태스크가 일정 시간 이상 실행되면 종료시키는 로직이고요. 
글로벌하게 하나를 설정해놓으면 실수로 빼먹어도 안정적으로 실행을 할 수가 있습니다. 
그리고 태스크가 일정 빈도 이상 실행되지 못하도록 설정할 수도 있고요. 이 얘기는 조금 더 나중에 진행을 할 건데요. 간단하게 이렇게 실행할 수 있습니다. 

그리고 기본적으로 콘커런시를 이용을 해야 하고요. 이런 식으로 샐러리를 실행을 할 때 P옵션을 어떤 워커 풀에서 실행을 할 때 설정할 수 있습니다. 그리고 C옵션은 콘커런시를 설정할 수 있죠. 
워커풀은 결국 구현에 대한 옵션이고 이런 솔로 등등의 옵션들을 줄 수 있습니다. 
조금 더 자세히 나중에 설명을 할 거고요. 

그리고 이 워커와 일단 무관하게 프리패치라는 기능이 이게 헷갈리는데 이 부분을 이해를 하고 넘어가려고 합니다. 프리패치 리밋은 샐러리 문서에서는 이런 식으로 안 나와 있기는 한데 Ack 되지 않은 메시지의 개수를 워커가 얼마나 가지고 있을 수 있느냐에 대한 개념입니다. 그래서 워커 프리패치 멀티플라이어라는 거를 설정을 할 수가 있는데 이게 그러면 이 멀티플라이어 곱하기 콘커런시가 프리패치 리밋으로 설정이 되게 됩니다. 
그리고 약간 직관적이지 않을 수도 있는데 워커 프리패치 멀티플라이어를 영어로 설정하게 되면 이것에 대해서 명확히 설정하지 않아서 리밋을 걸지 않고 메모리와 효율성을 고려하지 않고 작업을 실행하게 되는 결과가 있습니다. 
그래서 이 부분에 대해서 조금 더 예시를 들어 설명을 하자면 콘커런시가 2인 워커가 있고 1인 워커가 있고 큐에 메시지가 쌓여있다고 생각을 해봅시다. 
이때 워커 프리패치 멀티플라이어를 1로 설정하게 되면 메시지를 받으면 이 태스크를 실행하기 직전에 처음 태스크들은 Ack를 하겠죠. 그러면, 그리고 이 프리패치 리밋이 그때 적용이 됩니다. 이 Ack된 메시지를 제외하고. 
그래서 왼쪽 워커 같은 경우에는 두 개의 콘커런시가 2이고 멀티플라이어가 1이니까 두 개의 프리패치 메시지를 가지고 있고요. 프리패치하고 있고요. 
그리고 오른쪽 워커 같은 경우에는 하나의 메시지를 프리패치 하게 됩니다. 
네, 그렇고요. 

그래서 이 태스크를 어떻게 쓸 수 있냐 하면, 이 옵션을 긴 태스크에 대해서는 이렇게 실행을 할 수 있고요. 워커 프리패치 멀티플라이어를 1로 설정을 하면 긴 태스크 위에 짧은 태스크들이 쌓여서 그 짧은 태스크들이 불필요하게 실행되는 일을 막을 수 있습니다. 그래서 워커 프리패치 멀티플라이어를 1로 설정하실 수 있고요. 그리고 엑스레이트 트루를 설정하게 되면 이런 식으로 실행 중인 태스크만 프리패치 하게 됩니다. 
그리고 짧은 태스크들의 경우 워커프리패치 멀티플라이어에 따라 프리패치를 하는데도 결국 네트워크를 타기 때문에 워커 프리패치 멀티플라이어를 높여 주면 더 태스크를 빠르게 실행할 수 있습니다. 
그래서 이 옵션을 적극적으로 활용하시려면 길고 짧은 태스크를 구분하여서 워커를 지정하실 수 있고요. 

그리고 아까 말씀드렸던 프리포크 워커풀에 대해서 자세하게 설명을 드리자면 멀티 프로세싱으로 구현이 되어 있고 콘커런시n으로 실행한다면 한 개의 마스터와 n개의 차일드로 실행이 됩니다. 
여기서 오페어 옵션이라고 있는데 이 마스터에서 차일드 프로세스로 태스크를 전달할 때 기본적으로는 파이퍼포머가 허용하는 만큼을 전달하게 되는데 이 옵션을 주면 실행할 경우에만 메시지를 전달하게 됩니다. 
그래서 긴 작업과... 아, 그리고 프리패치 리밋과 오페어 옵션이 헷갈릴 수 있는데 프리패치 리밋은 브로커에서 워커로 가는, 분배하는 로직을 통제하는 거고요. 오페어 같은 경우는 마스터에서 차일드 프로세스로 메시지를 분배하는 로직을 컨트롤합니다. 
긴 작업과 짧은 작업법이 섞여있을 때는 이 오페어 옵션을 주게 되면 성능향상과 예상가능한 동작을 기대할 수 있고요. 

실생활 예시로 한줄서기로 하게 되면, 예를 들면 화장실이나 표를 살 때 그러면 줄이 더 빨리 줄어들게 되는 것과 같은 원리입니다. 

그리고 지이벤트와 이벤틀렛 같은 경우에는 이렇게 하면 더 빠르게 실행하실 수 있고요. 그리고 쓰레드 기반으로 구현이 되어 있고, 그리고 콘커런시는 이제 몇백 개, 1,000개, 이런 식으로도 설정이 가능합니다. 뭐 프리포크는 CPU 개수에 따라서 어느 정도 설정이 되기 때문에 그 정도로 많이 설정이 되지는 못하고요. 
그래서 앞에 말씀드렸던 부분들을 조금 고려를 하셔서 워커 옵션 같은 거를 주실 수 있는 걸 고려를 하셔서 작업의 성질에 따라 적절하게 다르게 처리하셔야 합니다. 
그래서 메모리를 많이 필요하는 작업이라면 그런 것도 고려하시고 작업의 중요도라든지 작업이 수행되는 시간, 그리고 아까 말했던 프리패치와 관련이 있겠죠. 그리고 실행의 빈도, 이런 것들을 고려를 하셔서 큐를 잘 나누고 그리고 작업을 잘 분배하시면 됩니다. 
그리고 이제 배포하기에 대한 내용인데요. 저희 같은 경우에는 데모나이제이션을 일단 기본적으로 할 수 있고 저희는 슈퍼바이저딜을 이용해서 배포를 했습니다. 
그리고 원래 처음에는 가장 심플하게는 스케일링업 하는 구조로 구현을 했었고요. 그리고 지금은 차근차근 컨테이너라이즈 하고 스케일링아웃 할 수 있도록 바꿔가고 있는데요. 
그때 있었던 이슈 중에 하나가 저희가 웨이트리밋을 사용하는데 이 옵션이 워커별로 관리가 된다는 거를 그때 알게 됐습니다. 그래서 워커별로 관리가 된다는 건 뭐 1분에 60개의 태스크를 실행하도록 제한을 해놨는데 워커를 두 개를 띄우게 되면 120개가 1분에 실행되는 현상이 발생하는 거죠. 
그래서 저희가 이거를 커스텀하기 위해서 코드를 좀 살펴봤습니다. 그래서 샐러리에서 어떻게 레이트리밋을 구현하나 살펴봤는데 태스크가 어떻게 메시지를 컨숨할지 컨수머가 있고 그리고 샐러리가 이용하는 메시징 라이브러리가 있는데 여기에서 토큰버켓이라는 거를 이용해서 세팅을 구현하고 있다는 걸 알게 됐습니다. 

그러면 이 토큰버켓이라는 게 뭐냐 하면 토큰이라는 건 곧 실행할 수 있는 권한에 해당되고요. 태스크는 1로 동일하다고 일단은 보고 구현이 되어 있었습니다. 그리고 버켓에 토큰이 있고 이 토큰이 시간에 따라 일정하게 버켓에 채워집니다. 그리고 어느 정도 리밋이 지나면 버켓이 더 이상 채워지지가 않게 되고요. 
그래서 버켓 안에 태스크를 실행을 했을 때 버켓 안에 충분한 토큰이 있으면 이 토큰을 빼고 태스크를 실행을 하게 됩니다. 그러면 버켓 안에 토큰이 하나 줄어들겠죠. 그리고 충분한 토큰이 없으면 이 시간이 지나서 토큰이 채워질 때까지 기다렸다가 다시 시도하는 게 이 토큰버켓이라는 개념이고요. 
그래서 샐러리에서는 이거를 컨수머에서는 태스크에 해당하는 버켓을 생성하는 로직과 레이트리밋이 적용되어 있을 경우에 이 토큰버켓을 생성하잖아요. 그런 로직과 이 버켓을 이용해서 내가 태스크를 실행할 수 있느냐, 토큰을 빼낼 수 있느냐를 판단하고 그리고 만약에 할 수 없다면 얼마만큼의 시간이 지내서 뺄 수 있는지 버켓에 물어보는 그런 부분이 컨수머에 있었고요. 
그래서 토큰버켓은 이 부분을 구현을 하고 있었습니다. 그래서 이 토큰버켓의 캔컨숨과 익스펙티드타임을 보면 겟토큰스가 있는데 이 겟토큰스라는 매소드를 보게 되면 토큰버켓이라는 게 결국은 시간에 따라 채워지는 건데 실제로 시간에 대해서 채워지도록 하는 멤버변수가 있는 토큰이라는 변수가 있다기보다는 저번에 토큰을 확인했을 때의 시간에 비해서 몇 개가 늘어났느냐를 확인해서 그때그때 이 함수를 호출할 때마다 토큰을 업데이트 해주는 방식이었습니다. 
그래서 저희는 일단 이 부분을 래디스로 구현을 대체해야겠다는 생각을 했고요. 왜냐하면 워커가 로컬하게 저 토큰버켓을 가지고 있어서 결국 워커별로 실행이 되는 거니까. 그래서 래디스를 이용해서 하려고 했고요. 그리고 토큰버켓에 아까 프라이빗 겟토큰스와 비슷한 로직을 구현을 했습니다. 
그래서 래디스 토큰버켓이라는 거를 정의를 하고 여기에서 아까 구현한 래디스를 이용한 토큰버켓을 이용하고 그리고 이 컨수머를 상속을 받아서 버켓 포 태스크 매소드를 오버라이드 하는 방식으로 구현을 수정을 했습니다. 
가장 하단에 있는 건 컨수머를 설정할 수 있는 기능이고요. 샐러리는 이런 식으로 컴포넌트 별로 상속하고 수정할 수 있도록 구현이 되어 있습니다. 
그리고 오른쪽에 보면 익스펙티드 타임도 구현을 했는데 저희가 아무래도 저희 유스케이스에서는 빠르게 많은 작업을 필터링하는 거다 보니까 굳이 네트워크를, 래디스라는 네트워크를 다시 하는 것보다는 그냥 적절한 시간, 채워지는 시간을 그냥 이용해서 고정적으로 기다렸다가 다시 실행하고 구현을 했습니다. 

이상 종료됐고요. 그리고 마지막으로 제가 하고 싶은 말씀은 저희가 이제 채용을 하고 있는데 많이 지원해주시면 좋겠고 그리고 내일 열린점심도 진행을 하니까 참석해주시면 감사하겠습니다. 이상입니다. 
(박수)

-(사회자) 다시 한 번 발표해주신 발표자 분께 박수 한번 부탁드리겠습니다. 
(박수)
이번 세션은 마무리 되었으니 10분간 쉬는 시간 갖도록 하겠습니다. 