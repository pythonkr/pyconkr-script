1
00:00:10,250 --> 00:00:16,140
저는 한성민이고요
파이썬과 고랭을 사랑하는 고퍼 혹은 파이써니스트입니다

2
00:00:17,380 --> 00:00:21,070
이번 발표에서 제가 얘기드리고자 하는 내용은

3
00:00:21,100 --> 00:00:24,220
이미지 프로세싱과 그리고 오픈 소스

4
00:00:24,250 --> 00:00:28,210
마지막으로 실제적으로 오픈 소스에
기여를 한 경험이 있어서

5
00:00:28,240 --> 00:00:33,310
그런 것들을 '컨트리뷰션'이라는 제목으로
공유를 드리려고 하는데요

6
00:00:33,340 --> 00:00:36,580
오픈 소스에 관심이 많으신 파이써니스트 라면

7
00:00:37,300 --> 00:00:42,580
이번 발표 세션에서
기여 가이드 같은 것을 전달 받으시고

8
00:00:42,610 --> 00:00:45,940
유용하게 사용하시면 정말 좋을 것 같습니다

9
00:00:47,290 --> 00:00:52,190
그러면 먼저 이미지 프로세싱에 대한 내용부터
설명을 드리고자 합니다

10
00:00:53,860 --> 00:00:57,140
이미지 프로세싱을 예로 들기 위해서

11
00:00:57,170 --> 00:01:00,080
가장 좌측에 고양이 이미지를 하나 넣어봤는데요

12
00:01:01,420 --> 00:01:04,800
저희가 봤을 때는 그냥 일반적인 고양이 이미지지만

13
00:01:04,960 --> 00:01:08,820
컴퓨터에서 저장을 할 때는 그 이미지의 데이터를

14
00:01:08,860 --> 00:01:13,030
흔히 Byte
컴퓨터에서 byte라는 단위로 처리를 하고요

15
00:01:13,060 --> 00:01:18,620
그 이미지의 데이터들은 모두 다
매트릭스라고 부르는 베열 형태로 저장을 하게됩니다

16
00:01:19,390 --> 00:01:23,680
이때 이미지는 각각 다
RGB 데이터로 저장을 하게 되는데요

17
00:01:23,710 --> 00:01:27,920
RGB는 흔히 레드, 그린, 블루로 되어 있는

18
00:01:28,420 --> 00:01:34,090
어떻게 보면 8bit 하나에
1byte로 처리되는 데이터들을

19
00:01:34,120 --> 00:01:40,400
매트릭스로 2차원 데이터로 변환을 해서
저장을 하게 되는 것을 말씀드릴 수 있습니다

20
00:01:41,860 --> 00:01:44,530
이미지 프로세싱이라는 것은 뭘까요?

21
00:01:44,560 --> 00:01:48,220
이미지 프로세싱은 흔히 얘기를 해서
가장 쉽게 정의를 해보면

22
00:01:48,250 --> 00:01:51,320
이미지의 어떤 변환과정을 통해서

23
00:01:51,340 --> 00:01:54,640
처리할 수 있는 모든 기술들을
얘기할 수 있을 것 같습니다

24
00:01:54,940 --> 00:01:56,680
그러면 이미지는 무엇일까요?

25
00:01:56,710 --> 00:02:00,880
이미지는 이후 슬라이드에서도
자세히 설명드리겠지만

26
00:02:01,370 --> 00:02:04,780
대표적으로는 두 가지의 이미지 종류가 있습니다

27
00:02:04,960 --> 00:02:07,690
첫 번째로는 정적인 이미지인데요

28
00:02:07,750 --> 00:02:14,020
여러분이 웹에서 많이 보셨을 법한
그림이나 사진과 같이

29
00:02:14,050 --> 00:02:18,530
멈춰있지만 2차원 데이터로 표현할 수 있는 이미지들을

30
00:02:18,550 --> 00:02:22,180
정적 이미지 중에 하나의 분류로 할 수 있고요

31
00:02:22,540 --> 00:02:28,500
두 번째로는 이런 정적 이미지들을
하나의 시간이라는 단위로

32
00:02:28,520 --> 00:02:32,920
연속적으로 재생을 시켜서 보여줄 수 있는
동적 이미지들이 있습니다

33
00:02:33,340 --> 00:02:37,410
흔히 말해서 동영상이나 비디오 같은 것들이
해당이 될 수 있습니다

34
00:02:39,950 --> 00:02:44,590
지금 이 슬라이드에 보고 계신 화면은 정적 이미지

35
00:02:44,610 --> 00:02:47,560
2차원 데이터로 표현할 수 있는 이미지

36
00:02:47,590 --> 00:02:49,590
어떻게 보면 그림이나 사진이 되겠죠

37
00:02:49,760 --> 00:02:53,450
그런 것들을 변환하기 위한
이미지 프로세싱의 예시들인데요

38
00:02:53,710 --> 00:02:56,980
가장 좌측에 Original 이미지가 있고

39
00:02:57,000 --> 00:03:02,170
그 Original 이미지에 어떻게 이동을 가하는
Translate 연산이 있을 수 있습니다

40
00:03:02,200 --> 00:03:06,130
그리고 크기에 변환을 가하는
Scale 연산도 해당이 될 수 있고요

41
00:03:06,160 --> 00:03:10,120
마지막으로 Rotate
이미지에 회전을 가해서

42
00:03:10,150 --> 00:03:13,260
이미지를 변경할 수 있는
이미지 프로세싱 기법도 있습니다

43
00:03:14,980 --> 00:03:18,300
조금 더 자세히 설명을 드리면 이미지 프로세싱에서는

44
00:03:18,320 --> 00:03:22,960
사진과 그림과 같이
정적 이미지를 처리할 수 있는 기법들이 있고요

45
00:03:23,260 --> 00:03:27,750
반대로 동적인 이미지
동영상이나 비디오를 처리할 수 있는

46
00:03:27,770 --> 00:03:30,370
이미지 프로세싱 기법이 있습니다

47
00:03:30,400 --> 00:03:32,070
순서대로 설명을 드리자면

48
00:03:32,100 --> 00:03:36,800
사진에서는 어떤 크기나 변환, 크기나 회전

49
00:03:36,830 --> 00:03:40,560
아니면 이동과 같이 그런 어떻게 보면

50
00:03:40,590 --> 00:03:46,380
공간 데이터를 변경시킬 수 있는 요소들을
기하학적 변환이라고 합니다

51
00:03:46,410 --> 00:03:49,360
그리고 색상을 변환시키는 기법도 꽤 있는데요

52
00:03:49,380 --> 00:03:52,410
예를 들면 두 가지 이미지의 색상을 합치거나

53
00:03:52,440 --> 00:03:56,260
아니면 색상에 필터를 가하거나
색상의 화이트 밸런스를 맞추거나

54
00:03:56,290 --> 00:03:57,960
이런 이미지 프로세싱들을

55
00:03:57,980 --> 00:04:02,430
색조화, 양자화, 색변환에 대한
이미지 프로세싱으로 나눌 수 있습니다

56
00:04:02,920 --> 00:04:07,470
그리고 이미지에 특정 데이터를 검출하는
어떤 패턴 인식이라거나

57
00:04:07,490 --> 00:04:10,670
특징을 검출하는 것 혹은 OCR과 같이

58
00:04:10,700 --> 00:04:14,850
글자를 인식하는 것들에 대한 것도
이미지 프로세싱이라고 볼 수 있는데요

59
00:04:15,700 --> 00:04:18,710
이런 것들은 물론 동영상에서도 쓰일 수 있지만

60
00:04:18,740 --> 00:04:23,720
일반적으로 사진과 그림에 대한
이미지 프로세싱으로 처리되기 때문에

61
00:04:24,370 --> 00:04:27,310
우선은 사진과 그림 처리에다가 해당시켰습니다

62
00:04:27,700 --> 00:04:32,510
그리고 동영상 처리에 대해서도
이미지 프로세싱의 기법들이 있는데요

63
00:04:32,590 --> 00:04:36,290
예를 들어서 압축과 같은 연산이나

64
00:04:36,310 --> 00:04:39,800
혹은 영상에 노이즈를 제거할 수 있는 기법들

65
00:04:39,870 --> 00:04:44,480
혹은 영상 분할이나 접합 등의
이미지 프로세싱 기법들이 있습니다

66
00:04:46,180 --> 00:04:51,720
이번 발표에서는 이 중에서
기하학적 변환에 대한 설명을 드리고자 합니다

67
00:04:53,300 --> 00:04:57,180
기하학적 변환 연산이란 아까 전에 말씀드렸듯이

68
00:04:57,200 --> 00:05:00,070
이미지의 크기나 위치

69
00:05:00,100 --> 00:05:04,750
혹은 회전과 같이
이미지에 기하학적인 변환을 가하는 모든 연산들을

70
00:05:04,780 --> 00:05:07,330
기하학적 변환 연산이라고 부르는데요

71
00:05:07,360 --> 00:05:11,880
대표적으로는 어파인 연산이랑
퍼스펙티브 연산이 있습니다

72
00:05:11,910 --> 00:05:17,060
퍼스펙티브 연산이라는 것은 일반적으로
"원근 변환"이라는 표현을 많이 사용하고 있습니다

73
00:05:19,750 --> 00:05:22,440
코드로 예시를 들어볼까 하는데요

74
00:05:22,960 --> 00:05:26,200
좌측에 있는 것은 파이썬 코드입니다

75
00:05:26,440 --> 00:05:30,010
여기서는 Pillow라는
오픈 소스를 라이브러리를 사용하고 있는데요

76
00:05:30,040 --> 00:05:32,980
오픈 소스이기 때문에 여러분도 쉽게

77
00:05:33,390 --> 00:05:36,920
pip와 같은 패키지 매니저로 설치를 할 수 있게 됩니다

78
00:05:38,290 --> 00:05:43,000
가장 먼저 첫 번째 줄에서는
Pillow의 Image라는 모듈을 불러왔고요

79
00:05:43,720 --> 00:05:49,310
고양이 이미지를 불러와서
그 고양이 이미지에 이미지 프로세싱을 가하려고 합니다

80
00:05:50,020 --> 00:05:54,000
오른쪽에 보시면 뭔가 어파인 연산 중에서

81
00:05:54,020 --> 00:05:58,040
이동을 담당하는 Translate 연산에 대한
수식이 보이는데요

82
00:05:58,300 --> 00:06:03,220
이 파라미터 중에서
연두 색깔 박스로 표기된 여섯 가지의 인수

83
00:06:03,850 --> 00:06:09,920
1 0 X 0 1 Y와 같은 이런 파라미터들을

84
00:06:10,270 --> 00:06:14,270
좌측의 코드 a, b, c, d, e, f에 각각 넣어주게 됩니다

85
00:06:14,650 --> 00:06:19,840
그 다음에 불러온 이미지의 transform()에
어파인 연산을 가하게 되는데요

86
00:06:19,890 --> 00:06:23,470
이때 세 번째 파라미터로 아까 전에 말씀드렸던

87
00:06:23,500 --> 00:06:26,340
여섯 가지 파라미터들을 넣게 될 겁니다

88
00:06:27,040 --> 00:06:29,950
이제 그렇게 Transform 연산을 진행하고 나서

89
00:06:29,980 --> 00:06:34,840
그 Translate 처리된 이미지를
이제 열어 보게 되면

90
00:06:34,870 --> 00:06:40,550
가장 오른쪽에 보이시는 고양이 이미지처럼
X축으로 오른쪽으로 100픽셀

91
00:06:40,580 --> 00:06:44,720
Y축으로 위쪽으로 50픽셀 이동하게 됩니다

92
00:06:46,510 --> 00:06:51,910
어파인 연산에서는 아까 전에 말씀드렸던
Translate, 이동 연산 말고도

93
00:06:51,940 --> 00:06:53,760
Rotate 연산도 사용할 수 있는데요

94
00:06:54,520 --> 00:06:59,160
오른쪽에 보시는 수식과 같이
코사인과 사인 연산을 통해서

95
00:06:59,620 --> 00:07:04,300
이미지에 특정 각도로 회전시킬 수 있는 연산을
적용할 수 있게 됩니다

96
00:07:05,050 --> 00:07:10,010
지금 이 코드 예시에서는 45도 만큼

97
00:07:10,410 --> 00:07:12,980
회전을 시키는 연산을 예시로 들었는데요

98
00:07:13,960 --> 00:07:19,310
이 경우에도 마찬가지로 여섯 가지의 파라미터를
이용해서 이미지에 변환을 가하게 됩니다

99
00:07:19,870 --> 00:07:26,140
초록 색깔 영역을 보시면 이제 코사인, 사인
그리고 마이너스 사인, 코사인

100
00:07:26,170 --> 00:07:32,170
이렇게 해서 라디안으로 변환된
어떻게 보면 각도에

101
00:07:32,200 --> 00:07:36,740
각각의 함수들을 파라미터로 적용해서

102
00:07:36,790 --> 00:07:41,710
각각 a, b, c, d, e, f 변수로 먼저 정의를 하게 됩니다

103
00:07:41,740 --> 00:07:45,340
그 정의된 파라미터들은 마찬가지로

104
00:07:45,360 --> 00:07:50,110
img.transform() 메서드 안에서
세 번째 파라미터로 제공하게 될 경우에

105
00:07:50,830 --> 00:07:57,230
가장 오른쪽에 보이는 고양이 이미지과 같이
회전이 적용된 이미지를 보실 수 있습니다

106
00:07:58,360 --> 00:08:02,070
그리고 이 경우는
조금 더 복잡한 케이스를 예시로 들었는데요

107
00:08:02,320 --> 00:08:04,690
바로 퍼스펙티브 연산입니다

108
00:08:04,960 --> 00:08:09,050
퍼스펙티브 연산은 이제 '보는 관점'

109
00:08:09,420 --> 00:08:14,600
여러분의 시야에서 보는 관점과 다르게
카메라에서 보는 관점 각각에 대해서

110
00:08:14,630 --> 00:08:17,920
이미지에 변환을 가할 수 있는 행위들을
말씀드릴 수 있는데요

111
00:08:18,280 --> 00:08:21,300
지금 가장 오른쪽에 있는 고양이 이미지를 봤을 때는

112
00:08:21,400 --> 00:08:24,910
어떻게 보면 카메라가
아래쪽에서 약간 위로 볼 수 있는

113
00:08:24,940 --> 00:08:29,740
그런 형태의 원근을 적용해서
이미지 결과를 받아볼 수 있게 됩니다

114
00:08:30,340 --> 00:08:36,550
Pillow에서는 보시는 것처럼 퍼스펙티브
어파인연산을 통해서 이미지를 변환할 수 있고요

115
00:08:37,300 --> 00:08:41,810
이때 어파인이랑 퍼스펙티브는
Pillow 자체의 연산 기법이 아니라

116
00:08:42,000 --> 00:08:45,810
일반적으로 사용하는
이미지 프로세싱의 연산들입니다

117
00:08:46,120 --> 00:08:48,720
Pillow에서는 그것을 지원한다고 볼 수 있습니다

118
00:08:50,710 --> 00:08:53,870
이번에는 색상혼합에 대해서 얘기를 드리고 싶습니다

119
00:08:54,150 --> 00:09:00,070
색상혼합은 아까 전에 보여드렸듯이
어파인이나 퍼스펙티브 연산과 다르게

120
00:09:00,550 --> 00:09:04,610
어떤 이미지의 색상 데이터를 이용해서
색상을 변환하는

121
00:09:04,690 --> 00:09:07,820
어떤 이미지 프로세싱의 과정들을 뜻하는데요

122
00:09:08,170 --> 00:09:09,990
대표적으로는 블렌딩이 있습니다

123
00:09:10,020 --> 00:09:15,850
브랜딩은 두 가지의 이미지를
하나의 이미지처럼 합성할 수 있는 기법인데요

124
00:09:16,060 --> 00:09:22,930
이제 두 가지 이미지의 색상값을 이용해서
이미지 블렌딩 처리를 하게 됩니다

125
00:09:22,960 --> 00:09:25,540
Pillow의 간단한 코드 예시를 들어봤습니다

126
00:09:26,260 --> 00:09:30,990
고양이 이미지와 강아지의 이미지를 불러와서

127
00:09:31,010 --> 00:09:33,460
두 가지의 이미지에 블렌드 처리를 하게 됩니다

128
00:09:33,490 --> 00:09:40,060
이때 블렌드의 각각 오퍼시티는 0.5
50% 적용해서 블렌딩을 시키게 됩니다

129
00:09:41,080 --> 00:09:46,150
블렌딩을 시키게 될 경우에는
보시는 이미지와 같이 강아지의 이미지와

130
00:09:46,180 --> 00:09:50,890
고양의 이미지가 각각 반반 합쳐져서 나타나게 됩니다

131
00:09:51,070 --> 00:09:54,690
그렇다면 이런 이미지 라이브러리는
과연 어떻게 동작하는 걸까요?

132
00:09:56,290 --> 00:10:02,020
이미지 라이브러리 중에서 파이썬에서
대표적인 두 가지 이미지 라이브러리가 있는데요

133
00:10:02,290 --> 00:10:07,340
대표적으로 Pillow 그리고 Wand
그리고 하나 더 있겠네요

134
00:10:07,440 --> 00:10:11,240
마지막으로 OpenCV 같은
이미지 라이브러리들이

135
00:10:11,260 --> 00:10:13,490
파이썬 오픈 소스에 자리잡고 있습니다

136
00:10:15,280 --> 00:10:21,200
그런 이미지 라이브러리들의 코드 설계를
간단하게 이 그림으로 설명하고 싶은데요

137
00:10:22,480 --> 00:10:26,550
파이썬의 이미지 처리들은
대부분 다음 그림과 같이 동작하게 됩니다

138
00:10:26,800 --> 00:10:29,970
먼저 강아지와 고양이 이미지를 불러오게 될 경우에

139
00:10:30,310 --> 00:10:34,710
그 강아지와 고양이의 2차원 배열
매트릭스 데이터를

140
00:10:34,890 --> 00:10:39,260
어떤 C 랭귀지, C언어로

141
00:10:39,280 --> 00:10:45,010
이미 작성된 함수의 바인드를 통해서
그 데이터를 전달하게 됩니다

142
00:10:45,730 --> 00:10:50,950
그리고 결과적으로
이미지 프로세싱에 실제 동작하는 로직들은

143
00:10:50,980 --> 00:10:53,260
파이썬 코드로 동작하는 것은 아니고요

144
00:10:53,740 --> 00:11:02,840
이미 C로 작성된 어떤 드라이버의
함수들을 통해서 작동하게 됩니다

145
00:11:03,170 --> 00:11:06,490
왜 이렇게 작동이 되는지 궁금하신 분들이 있을 텐데요

146
00:11:07,030 --> 00:11:11,780
파이썬은 일반적으로 배열 데이터를 다루는데
그렇게 성능이 좋다고 생각하지는 않습니다

147
00:11:12,070 --> 00:11:15,780
그래서 이렇게
굉장히 많은 배열 데이터를 다뤄야 되는

148
00:11:15,850 --> 00:11:18,700
특성을 가진 파이썬 함수들

149
00:11:18,720 --> 00:11:21,210
예를 들면 NumPy 같은 것들이 있을 것 같은데요

150
00:11:21,250 --> 00:11:24,340
그런 것들은 C로 한번 빌드된

151
00:11:24,880 --> 00:11:28,840
응용 프로그램을 드라이버로 바인드를 이어가지고

152
00:11:28,870 --> 00:11:31,060
파이썬 함수로 연결시키고

153
00:11:31,090 --> 00:11:33,260
그 파이썬 함수를 호출시킬 때

154
00:11:33,290 --> 00:11:37,830
이미 작성된 드라이버를 호출하는 형태로
작성이 되게 됩니다

155
00:11:38,260 --> 00:11:41,190
이것은 이미지 라이브러리도 마찬가지인데요

156
00:11:41,230 --> 00:11:44,790
이 이유는 대표적으로 이미지 라이브러리들의 연산은

157
00:11:44,820 --> 00:11:47,510
모두가 매트릭스 연산으로 이어져 있기 때문입니다

158
00:11:49,150 --> 00:11:51,670
파이썬 이미지 라이브러리의 구조 같은 경우에는

159
00:11:51,700 --> 00:11:56,160
아까 전에 말씀드렸듯이
C언어로 작성된 라이브러리들이 있을 것 같고요

160
00:11:56,300 --> 00:12:01,780
그리고 그 파이썬 바인드를 위한
파이썬 바인드 C가 있을 수 있고

161
00:12:01,810 --> 00:12:05,030
그리고 파이썬 바인드
setup.py가 있을 수 있습니다

162
00:12:05,440 --> 00:12:10,950
그리고 바인드된 함수들을 호출하기 위한
파이썬 인터페이스들이 자리잡을 수 있습니다

163
00:12:12,460 --> 00:12:18,290
이 이유는 아까 전에 말씀드렸듯이 매트릭스
연산에서는 굉장히 많은 비용을 요구하게 되고요

164
00:12:18,310 --> 00:12:25,220
그 비용을 C언어로 작성된 라이브러리나
드라이버를 통해서 대처할 수 있게 됩니다

165
00:12:26,560 --> 00:12:28,910
조금 더 구체적으로 설명드리려고 하는데요

166
00:12:29,290 --> 00:12:33,820
예를 들면 좌측에 process.py가 있다고
가정을 해보겠습니다

167
00:12:34,300 --> 00:12:37,900
이것은 파이썬 코드이기 때문에 여기서 여러분은

168
00:12:37,930 --> 00:12:44,670
이 process.py를 임포트해서
여기 안에 정의된 함수들을 호출하게 되는데요

169
00:12:44,830 --> 00:12:47,850
이때 실제 동작은 process.py에서

170
00:12:47,870 --> 00:12:52,090
바인드 C에 적용되어 있는 함수들을 호출하게 됩니다

171
00:12:52,330 --> 00:12:59,000
이 binding.c는 그 안에 있는 이미지 라이브러리들의
실제 코드를 호출하게 되는 형식으로

172
00:12:59,380 --> 00:13:05,000
파이썬 이미지 라이브러리나
아니면 파이썬 바인딩 라이브러리들은

173
00:13:05,890 --> 00:13:09,350
C언어에 작성된 함수들을 제공하게 됩니다

174
00:13:11,730 --> 00:13:16,460
연산 방식을 실제 코드를 보면서
좀 더 자세히 설명 드리고자 하는데요

175
00:13:16,900 --> 00:13:21,790
아까 전에 말씀드렸듯이
고양이와 강아지의 이미지가 가장 좌측에 있습니다

176
00:13:22,300 --> 00:13:25,390
블렌딩 연산을 예시로 들려고 하는데요

177
00:13:25,420 --> 00:13:29,470
가장 좌측에 보이시는 파이썬 코드
blend 함수를 보시면

178
00:13:29,500 --> 00:13:33,470
이미지1과 이미지2를 이용해서 블렌딩을 하게 됩니다

179
00:13:33,820 --> 00:13:38,170
이때 알파값을 받아서
블렌딩의 농도값을 정의를 하게 되는데요

180
00:13:38,200 --> 00:13:41,010
이 세 가지 파라미터를 가장 마지막에

181
00:13:41,030 --> 00:13:43,970
core.blend()에 그대로 전달하게 됩니다

182
00:13:45,100 --> 00:13:46,720
그럼 core.blend()는 뭘까요?

183
00:13:46,750 --> 00:13:52,610
오른쪽에 보시면 이제
libImaging/Blend.c가 있습니다

184
00:13:53,410 --> 00:13:57,370
이것은 어떻게 보면
이제 실제 동작하는 이미지 로직이고요

185
00:13:58,420 --> 00:14:01,510
아까 전에 전달 받았던 이미지 데이터와

186
00:14:01,540 --> 00:14:05,400
알파값을 C 함수에서도 동일하게 가장 위에

187
00:14:05,420 --> 00:14:11,950
Imaging imIn1, imIn2, alpha
파라미터로 전달받게 됩니다

188
00:14:11,980 --> 00:14:16,890
이렇게 전달받은 데이터들을 이용해서
매트릭스 연산을 C에서 진행하게 됩니다

189
00:14:18,910 --> 00:14:23,100
또 C 바인드 같은 경우에는 모든 기능들

190
00:14:23,130 --> 00:14:29,670
Pillow로 예시로 들면 모든 기능들을
core라는 모듈을 불러와서 진행을 하게 됩니다

191
00:14:30,520 --> 00:14:36,630
왼쪽에 보이시는 코드를 보시면
from . import _imaging as core라는

192
00:14:37,030 --> 00:14:39,370
형태로 모듈을 불러오게 되는데요

193
00:14:39,400 --> 00:14:44,280
오른쪽에 보시면 그 코어 안에 있는 모듈들은
모두 다 바인딩 형태로

194
00:14:44,350 --> 00:14:49,050
파이썬에 뭔가 함수를 제공하는 것을 볼 수 있습니다

195
00:14:49,420 --> 00:14:52,900
그래서 src/_imaging.c
오른쪽에 있는 코드를 보시면

196
00:14:52,930 --> 00:14:59,180
이것은 파이썬 인터페이스를 위해서 작성된 C 코드입니다

197
00:14:59,560 --> 00:15:02,710
이런 것을 바인딩 코드라고 부를 수 있을 것 같은데요

198
00:15:02,740 --> 00:15:05,660
C에서 작성된 파이썬을 위한 바인딩 코드입니다

199
00:15:08,050 --> 00:15:10,900
구체적으로 core 라이브러리를
조금 더 살펴보고자 하는데요

200
00:15:10,930 --> 00:15:13,910
지금 보시는 것은 setup.py입니다

201
00:15:14,290 --> 00:15:19,620
setup.py는  파이썬 패키지를 설치할 때
기본적으로 실행하는 스크립트인데요

202
00:15:20,500 --> 00:15:27,000
이 코드의 내용을 보시면 의존을 가지고 있는 C 함수들을

203
00:15:27,460 --> 00:15:30,420
파이썬 설치 스크립트에 포함을 시켜서

204
00:15:30,790 --> 00:15:35,430
예를 들면 Pillow 패키지를 설치할 때
Pillow 패키지에 필요한

205
00:15:35,500 --> 00:15:38,850
C 라이브러리들을 미리 한 번 빌드 시키고

206
00:15:39,100 --> 00:15:42,260
그 빌드된 응용 프로그램을

207
00:15:42,280 --> 00:15:48,020
파이썬 인터페이스에 연결할 수 있는 형태로
설치를 진행하게 됩니다

208
00:15:50,350 --> 00:15:55,420
보시는 것처럼
초록 색깔 영역으로 잡혀 있는 _imaging.c

209
00:15:55,450 --> 00:16:01,870
혹은 src 파일 안에 있는 C 파일들
혹은 src/libImaging 파일들을 이용해서

210
00:16:03,190 --> 00:16:09,810
그 C 파일들을 빌드시키고 최종적으로
그것을 PIL._imaging으로 제공하게 됩니다

211
00:16:10,120 --> 00:16:14,010
이렇게 제공하고 나서 아까 전에 보시는 그림처럼

212
00:16:18,250 --> 00:16:24,200
좌측에 있는 코드처럼
from . import _imaging as core로

213
00:16:24,970 --> 00:16:28,070
마치 파이썬 모듈처럼 사용할 수 있게 되는 거죠

214
00:16:28,210 --> 00:16:34,480
왜냐하면 _imaging.c 안에 들어있는 파일은
결국에는 파이썬 오브젝트

215
00:16:34,510 --> 00:16:39,910
오른쪽에 보시는 것처럼 타입 오브젝트 형태로
구현을 한 C 코드이기 때문에

216
00:16:39,940 --> 00:16:44,550
마치 파이썬에서는
파이썬 패키지나 파이썬 메서드를 불러오는 것처럼

217
00:16:44,610 --> 00:16:46,110
사용할 수 있게 되는 겁니다

218
00:16:48,190 --> 00:16:50,530
그러면 Pillow에 대해서
조금 더 자세히 알아볼게요

219
00:16:50,560 --> 00:16:54,740
Pillow에서 사용하고 있는
의존 라이브러리들입니다

220
00:16:55,210 --> 00:16:56,680
총 여섯 가지를 적어봤는데요

221
00:16:56,710 --> 00:17:02,400
사실 더 많지만 지금은 대표적으로 사용하고
있는 의존 라이브러리들을 뽑아봤습니다

222
00:17:04,030 --> 00:17:08,000
FreeType은 폰트 렌더링을 위한 라이브러리로

223
00:17:08,060 --> 00:17:10,360
굉장히 유명한 라이브러리고요

224
00:17:10,390 --> 00:17:13,750
그리고 Liblmaging은
이미지 처리를 위한 라이브러리입니다

225
00:17:14,230 --> 00:17:18,740
Libjpeg는 JPG 연산을 위한 라이브러리고요

226
00:17:19,450 --> 00:17:25,520
이제 libraqm 같은 경우에는 텍스트 레이아웃
텍스트를 렌더링을 각각 한다고 해도

227
00:17:25,550 --> 00:17:29,370
그 텍스트의 정확한 위치값을 계산하는 게
굉장히 까다롭습니다

228
00:17:29,560 --> 00:17:32,320
텍스트의 레이아웃을 계산하기 위한 라이브러리고요

229
00:17:32,340 --> 00:17:35,830
그리고 harfbuzz 같은 경우에는 폰트 글리프

230
00:17:35,850 --> 00:17:41,050
쉽게 얘기해서 글자 하나하나의 렌더링에 대한

231
00:17:41,080 --> 00:17:44,010
그 글자 하나하나를 글리프라고 부르는데요

232
00:17:44,110 --> 00:17:47,250
글리프 렌더링을 위한 라이브러리가
하나 더 존재하게 됩니다

233
00:17:47,560 --> 00:17:52,090
그리고 libimagequant 같은 경우에는

234
00:17:52,130 --> 00:17:57,900
이제 RGBA, RGB값의 알파 값이 포함된
이미지 테이터를 변환하기 위한

235
00:17:57,950 --> 00:18:03,550
그런 변환, 인코딩 디코딩 함수들의 인터페이스들이
적용된 라이브러리입니다

236
00:18:03,910 --> 00:18:08,780
Pillow 같은 경우에는 총 여섯 가지의
의존 라이브러리를 대표적으로 사용하고 있고요

237
00:18:10,600 --> 00:18:14,970
이번에는 Pillow와 다르게
ImageMagick에 대한

238
00:18:15,040 --> 00:18:18,700
오픈 소스 패키지를 좀 살펴보도록 하겠습니다

239
00:18:18,730 --> 00:18:24,100
ImageMagick 같은 경우에는
굉장히 오래된 라이브러리 중에 하나인데요

240
00:18:24,220 --> 00:18:30,650
1990년에 출시가 되었고
마찬가지로 C 언어로 작성되어 있습니다

241
00:18:30,760 --> 00:18:36,400
마찬가지라고 하는 이유가
Pillow 같은 경우에는 파이썬 인터페이스가 있지만

242
00:18:36,430 --> 00:18:39,940
Pillow 내부적으로는
대표적으로 다 C로 작성이 되어 있는데요

243
00:18:39,970 --> 00:18:46,220
마찬가지로 ImageMagick도
이미지 라이브러리이기 때문에 C로 작성되어 있습니다

244
00:18:48,430 --> 00:18:53,080
ImageMagick을 사용하기 위해서
Wand라는 파이썬 패키지를 사용하게 됩니다

245
00:18:53,410 --> 00:18:55,520
왜 ImageMagick을 바로 사용하지 못하냐면

246
00:18:55,550 --> 00:19:01,160
ImageMagick은 C로 작성된 라이브러리이기 때문에
파이썬에서 직접적으로 접근을 못합니다

247
00:19:01,570 --> 00:19:04,330
그래서 바인딩 패키지를 사용해야 되고요

248
00:19:04,960 --> 00:19:09,920
ImageMagick에 파이썬 바인딩 프로젝트는
이제 Wand라는 프로젝트가 있게 됩니다

249
00:19:10,720 --> 00:19:14,610
코드를 보시면 Wand에 이미지를 불러와가지고

250
00:19:14,670 --> 00:19:20,610
그 이미지 모듈를 통해서
고양이 이미지를 불러오게 됩니다

251
00:19:20,930 --> 00:19:24,440
그 다음에 갖가지 Wand에서 제공하고 있는

252
00:19:24,470 --> 00:19:27,390
메서드를 통해서 이미지에 변환을 가할 수 있고요

253
00:19:27,520 --> 00:19:31,090
최종적으로 Wand의 display() 메서드를 통해서

254
00:19:31,980 --> 00:19:35,100
변환된 이미지를 볼 수 있게 됩니다

255
00:19:35,560 --> 00:19:38,070
지금 보시는 것은 트랜딩 그래프인데요

256
00:19:38,650 --> 00:19:41,640
아까 전에 말씀드렸듯이 대표적으로 세 가지의

257
00:19:42,280 --> 00:19:46,060
이미지 라이브러리들의 추세를
좀 살펴보도록 하겠습니다

258
00:19:46,810 --> 00:19:49,790
보시는 것처럼 Python Pillow 같은 경우에는

259
00:19:49,810 --> 00:19:53,720
그렇게 높은 차트 성향을 띄지는 않지만

260
00:19:53,980 --> 00:19:57,440
어떻게 보면 이 그래프가 다 파이썬에 이렇게

261
00:19:57,460 --> 00:20:01,330
딱 정확하게 스코프가 잡혀 있는 차트는 아니에요

262
00:20:01,360 --> 00:20:05,560
왜냐하면 ImageMagick이나
OpenCV나 모두 다

263
00:20:05,570 --> 00:20:12,060
C++ 혹은 파이썬 아니면 다른 언어에서도
사용할 수 있는 라이브러리임에도 불구하고

264
00:20:12,080 --> 00:20:16,600
Python Pillow 같은 경우에는
오직 파이썬 유저들에게 제공하기 위한

265
00:20:16,630 --> 00:20:20,450
라이브러리이기 때문에 차트 그래프에는
뭔가 좀 차이점이 있다고 보고요

266
00:20:20,830 --> 00:20:26,580
오른쪽에 보시는 것처럼 ImageMagick과
OpenCV에 대한 차트 그래프의 차이를 볼 수 있게 됩니다

267
00:20:26,950 --> 00:20:30,080
이 오른쪽에 있는 그래프는
스택 오버플로우의 그래프고요

268
00:20:30,100 --> 00:20:36,310
좌측에 있는 그래프는 구글 트렌드 사이트에서
볼 수 있는 그래프입니다

269
00:20:37,340 --> 00:20:39,170
어떻게 보면 오른쪽에 있는 그래프가 조금 더

270
00:20:39,200 --> 00:20:44,540
개발자들의 성향 요구들을 조금 더 많이 반영한
그래프라고 볼 수 있는데요

271
00:20:45,490 --> 00:20:50,310
지금 OpenCV가 ImageMagick에 비해서
굉장히 높은 차트 추세를 보이고 있습니다

272
00:20:50,710 --> 00:20:52,660
이유가 뭘까 많이 생각을 해봤는데

273
00:20:52,680 --> 00:20:56,050
OpenCV가 유명한 라이브러리인 것도 맞고요

274
00:20:56,350 --> 00:20:59,710
그리고 두 번째로 최근에는 이제 머신러닝이 많이

275
00:20:59,740 --> 00:21:04,480
조금 더 유행함에 따라서
컴퓨터 비전을 담당하는 연구자 분들이

276
00:21:04,500 --> 00:21:08,910
사용할 수 있는 라이브러리는
OpenCV가 있다고 생각합니다

277
00:21:09,460 --> 00:21:11,860
ImageMagick과 OpenCV의 큰 차이점은

278
00:21:11,890 --> 00:21:16,560
ImageMagick은 오직 렌더링 이미지를
그리기 위한 것들에 대한

279
00:21:16,590 --> 00:21:19,080
툴킷들을 제공하는 라이브러리고요

280
00:21:19,270 --> 00:21:25,550
OpenCV는 컴퓨터 비전용 라이브러리로써
이미지에 패턴을 분석한다든지

281
00:21:25,890 --> 00:21:28,150
이미지의 유사도를 검색한다든지

282
00:21:28,180 --> 00:21:32,800
아니면 이미지에 오브젝트를 디텍션 한다든지와 같은

283
00:21:32,830 --> 00:21:37,490
컴퓨터 비전에 대한 테크닉들이 적용된
함수들이 많이 제공되고 있습니다

284
00:21:37,600 --> 00:21:43,950
그런 차이점이 있기 때문에 이것을 같은 이미지 렌더링
라이브러리 선상에서 두고 비교하기는 좀 어렵고요

285
00:21:44,320 --> 00:21:49,020
Pillow와 ImageMagick을
스택 오버플로우에서 비교할 수 없는 이유는

286
00:21:49,050 --> 00:21:53,130
스택 오버플로우에서는
Pillow에 대한 태그를 제공하지 않습니다

287
00:21:54,220 --> 00:21:59,230
아무래도 뭔가 유저 스케일이 조금 적을 수도 있고요

288
00:21:59,500 --> 00:22:05,850
혹은 Pillow라는 태그가 아직 사용되지 못하는
태그일 수도 있을 거라고 생각하지만

289
00:22:06,040 --> 00:22:14,000
제가 봤을 때는 아직 파이썬 유저만 사용하는
Pillow 이미지 라이브러리 같은 경우에는

290
00:22:14,430 --> 00:22:18,150
아직 사용자의 스케일이 적지 않을까?
라는 생각을 하고 있습니다

291
00:22:19,690 --> 00:22:24,640
마지막으로 컨트리뷰션에 대한 주제를
좀 설명 드리고 싶은데요

292
00:22:26,680 --> 00:22:30,600
일반적으로 저희가 컨트리뷰션이라고 부르는 것은

293
00:22:30,640 --> 00:22:35,660
여러분이 사용하시는 오픈 소스에 뭔가 요구사항들을

294
00:22:35,920 --> 00:22:38,190
단순히 요구를 할 수 있는 기능들

295
00:22:38,230 --> 00:22:44,180
예를 들면은 뭐 어떤 피쳐
어떤 기능들이 새로 생겼으면 좋겠다 라는 것을

296
00:22:44,290 --> 00:22:46,860
어떻게 보면 커뮤니티에다가 알렸어요

297
00:22:46,890 --> 00:22:48,580
그것은 기여일까요? 아닐까요?

298
00:22:48,610 --> 00:22:50,320
그것도 컨트리뷰션이 맞습니다

299
00:22:50,740 --> 00:22:54,880
그리고 실제 코드를 반영하는 것도
당연히 컨트리뷰션이 될 수 있고요

300
00:22:54,910 --> 00:23:00,900
아니면 버그 리포트 같은 것들을
실제 개발자들, 메인테이너들이나

301
00:23:00,930 --> 00:23:05,170
컨트리뷰터들이 알 수 있게끔
어떤 공식적인 커뮤니티 공간에 올렸어요

302
00:23:05,200 --> 00:23:07,550
그것도 오픈 소스 기여가 될 수 있습니다

303
00:23:07,810 --> 00:23:09,760
여러 가지 기여 방법이 있는데요

304
00:23:09,790 --> 00:23:13,260
지금 여기 워크플로우의 컨트리뷰션에서는

305
00:23:13,280 --> 00:23:17,560
실제 코드를 반영하는 기여 방법을 설명 드리고 있습니다

306
00:23:18,220 --> 00:23:22,150
여러분이 대부분의 오픈 소스에 기여를 하실 때는

307
00:23:22,180 --> 00:23:26,680
이제 보시는 그림과 같은 형태로
기여를 하게 될 것 같은데요

308
00:23:27,040 --> 00:23:30,960
가장 먼저 PR이라고 부르는
풀 리퀘스트를 날리게 됩니다

309
00:23:31,180 --> 00:23:34,870
'풀 리퀘스트'는 깃허브에서 사용하는 용어로써

310
00:23:34,900 --> 00:23:38,480
여러분이 코드를 수정하신 다음에
그것을 그대로 반영할 수는 없고요

311
00:23:38,710 --> 00:23:42,910
그것을 어떤 내용과 함께 요청을 날리는 형태로

312
00:23:42,930 --> 00:23:47,170
PR을 날린다라고 표현하지만
어떤 게시물을 작성하게 됩니다

313
00:23:47,200 --> 00:23:50,330
그 게시물을 작성하면 여러분의 코드들도 볼 수 있고요

314
00:23:50,420 --> 00:23:54,010
그 게시물 안에서
이 코드를 작성했던 설명들도 볼 수 있게 됩니다

315
00:23:54,240 --> 00:23:59,600
그러면 여러분이 올린 그 PR에 대해서
메인테이너라고 부르는

316
00:23:59,620 --> 00:24:04,500
프로젝트 관리자들
프로젝트의 주요 개발자들은 그 PR을 검토할 수 있는데요

317
00:24:04,690 --> 00:24:07,630
이제 메인테이너들 뿐만 아니라 컨트리뷰터

318
00:24:07,660 --> 00:24:12,340
같이 기여를 하고 있는 모든 사용자들도
특정 프로젝트의 성향에 따라서는

319
00:24:12,370 --> 00:24:14,270
PR을 같이 검토할 수 있게 됩니다

320
00:24:14,560 --> 00:24:17,060
이런 검토 과정을 리뷰라고 부르는데요

321
00:24:18,040 --> 00:24:21,340
가장 좌측에 보이시는 것은 여러분의 PR의 관점이고

322
00:24:21,370 --> 00:24:25,420
가운데에 보이시는 것은
시스템 오토매틱의 과정입니다

323
00:24:25,450 --> 00:24:28,510
가장 오른쪽에 보이시는 것은 리뷰의 과정인데요

324
00:24:28,540 --> 00:24:32,730
어떤 차이가 있는지
제가 하나하나 순서대로 설명을 드리도록 하겠습니다

325
00:24:32,890 --> 00:24:37,140
먼저 여러분이 코드를 반영하기 위해서
풀 리퀘스트를 열었을 때

326
00:24:37,460 --> 00:24:40,600
가운데 시스템이 오토매틱 처리해서

327
00:24:40,630 --> 00:24:43,100
CI/CD 라고 부르는 처리에서

328
00:24:43,600 --> 00:24:46,080
여러분의 코드를 자동적으로 검토를 하게 됩니다

329
00:24:46,480 --> 00:24:50,480
이때는 슬라이드에서는 젠킨스를 예로 들었지만

330
00:24:50,600 --> 00:24:52,980
깃허브 액션이 여기에 포함될 수도 있고요

331
00:24:53,170 --> 00:24:56,280
아니면 트래비스CI 같은 것들이 포함될 수 있습니다

332
00:24:56,300 --> 00:25:01,350
그 밖에도 뭐 오픈CI 서클CI
굉장히 많은 CI 종류가 있는데

333
00:25:01,510 --> 00:25:03,830
그런 것들이 이제 여러분의 PR이 올라왔을 때

334
00:25:03,860 --> 00:25:08,800
그것을 자동적으로 notify 받고 시스템에서
여러분의 코드가 올바른지 체크를 하게 됩니다

335
00:25:09,250 --> 00:25:14,290
거기서 뭔가 문법적인 에러가 발견됐거나
문법 스타일의 에러가 발견됐을 경우에는

336
00:25:14,320 --> 00:25:19,900
자동적으로 여러분의 PR이
더 이상 병합이 불가능하도록 막혀버리게 됩니다

337
00:25:19,930 --> 00:25:22,600
이런 것들이 이제 Blocking merge라고 부르는데요

338
00:25:23,080 --> 00:25:26,380
Merge는 일반적으로
여러분의 PR이 최종적으로 통과됐을 때

339
00:25:26,620 --> 00:25:29,520
그것을 코드 베이스에 합칠 수 있는 것을 말합니다

340
00:25:29,950 --> 00:25:35,270
만약에 시스템에서 차단될 경우에는
여러분의 머지 버튼은 아마 막히게 되겠죠

341
00:25:36,240 --> 00:25:40,330
그러면 여러분은 합치기 위해서
그 코드에 이제 시스템이 알려준

342
00:25:40,570 --> 00:25:44,100
변경 사항들을 반영해서
Fix commit을 날리게 됩니다

343
00:25:44,470 --> 00:25:48,410
그러고 나서 시스템에서는
통과를 시켜주게 될 경우에는

344
00:25:48,440 --> 00:25:51,320
리뷰어 분들이 리뷰를 진행하게 되고요

345
00:25:51,520 --> 00:25:56,120
가장 오른쪽에 보시는 것처럼
리뷰어들이 뭔가 수정사항을 발견했을 때는

346
00:25:56,140 --> 00:25:57,910
Request changes를 날리게 됩니다

347
00:25:58,120 --> 00:26:02,290
이것은 어떻게 보면 리뷰어들이 검토한 항목 중에서

348
00:26:02,320 --> 00:26:05,860
일부분이 그 프로세스에 알맞지 않다고 판단됐을 때

349
00:26:05,890 --> 00:26:07,300
요청하는 것들이고요

350
00:26:08,110 --> 00:26:12,430
프로젝트의 성향에 따라서
Request changes가 날라갔을 때는

351
00:26:12,730 --> 00:26:14,310
머지 자체가 막히게 됩니다

352
00:26:15,460 --> 00:26:21,630
마찬가지로 Fix commit을 통해서 리뷰어들의
리뷰 코멘트를 다시 한 번 반영하게 되고요

353
00:26:22,000 --> 00:26:26,990
그럴 경우에는 시스템에서 통과되고
리뷰어에서도 최종적으로 통과됐을 경우에

354
00:26:27,170 --> 00:26:29,630
리뷰어들은 Approve라는 것을 주게 됩니다

355
00:26:29,950 --> 00:26:34,360
Approve를 줬을 경우에는
최종적으로 머지 버튼이 활성화되고요

356
00:26:34,570 --> 00:26:39,550
그러면은 컨트리뷰터들이
머지 버튼을 눌러서 합칠 수도 있고

357
00:26:39,580 --> 00:26:45,180
혹은 메인테이너가 머지 버튼을 눌러서
여러분의 코드를 코드베이스에 병합할 수 있게 됩니다

358
00:26:45,490 --> 00:26:51,340
그래서 이제 Approve라는 것을 받기 위해서
PR 유저들을 굉장히 많이 힘을 쓰는 편이고요

359
00:26:51,700 --> 00:26:56,600
힘을 쓴다는 표현은 Approve를 따내기 위해서
굉장히 코드들을 많이 잘 짜려고 노력을 하게 됩니다

360
00:26:59,410 --> 00:27:05,070
이제부터는 제가 이미지 라이브러리의 기능을

361
00:27:05,090 --> 00:27:10,400
최종적으로 합치기까지 어떤 단계를
거쳤는지를 조금 더 설명드리고 싶습니다

362
00:27:10,690 --> 00:27:14,470
지금 제가 기여했던 이미지 라이브러리는
ImageMagick이고요

363
00:27:14,710 --> 00:27:17,690
ImageMagick에서 버그가 발견되어서

364
00:27:17,710 --> 00:27:22,390
그 버그를 어떻게 해결하는지
먼저 논의를 시작하게 됐습니다

365
00:27:22,420 --> 00:27:26,350
그래서 ImageMagick의 공식 커뮤니티에서

366
00:27:26,380 --> 00:27:31,470
밑줄과 가운데 취소선이
제대로 렌더링이 되지 않는 것을 발견해서

367
00:27:31,520 --> 00:27:33,880
그런 것들을 좀 설명을 드렸고요

368
00:27:33,910 --> 00:27:42,360
이때는 가장 좌측에 ImageMagick의
현재 버전의 렌더링 결과들을 보여주고

369
00:27:42,390 --> 00:27:47,200
제가 했던 동작 방법들을 설명하게 됩니다

370
00:27:47,230 --> 00:27:50,360
그리고 제가 예상했던 기능들도 설명을 잘해야 되는데요

371
00:27:50,380 --> 00:27:54,610
지금 보시는 이미지 라이브러리들은

372
00:27:54,630 --> 00:27:57,700
어떻게 보면 이미지를 처리하는 것이기 때문에
결과들이 다 이미지입니다

373
00:27:57,730 --> 00:28:02,600
그래서 비교적 쉬운데요
제가 예상하는 이미지를 그냥 올리면 됩니다

374
00:28:02,620 --> 00:28:07,370
그래서 좌측에 보시는 것처럼
현재 ImageMagick은 이렇게 렌더링을 하지만

375
00:28:07,780 --> 00:28:10,180
제가 예상하는 거 다른 유명한 프로그램

376
00:28:10,210 --> 00:28:16,640
예를 들면 포토샵이나 마이크로소프트 워드 같은 경우에는
오른쪽처럼 렌더링을 한다고 설명을 드렸고요

377
00:28:17,830 --> 00:28:23,530
보시는 것처럼 밑줄 같은 경우에는 조금 더 크기가 굵고
폰트의 크기에 따라서

378
00:28:23,560 --> 00:28:26,990
밑줄의 크기가 좀 나눠져야 되고
그리고 가운데 취소선도

379
00:28:27,020 --> 00:28:32,180
지금 오른쪽에 보시면 화면처럼 텍스트의
정확히 세로의 가운데 축으로 들어가야 되지만

380
00:28:32,530 --> 00:28:37,530
그때 당시의 ImageMagick은 그 가운데 축을
정확히 맞추지 못하는 문제들이 있었습니다

381
00:28:40,270 --> 00:28:46,030
결국에 커뮤니티에서 실제로
그 버그 자체를 고칠 수 있는

382
00:28:46,060 --> 00:28:48,130
뭔가 assignee가 잡히진 않았어요

383
00:28:48,160 --> 00:28:55,340
그래서 그때 당시에 좀 더 기다려 본 다음에
아무도 없으면 그냥 제가 고치겠습니다 라고 말씀드리고 나서

384
00:28:55,660 --> 00:29:00,760
그 다음에 이제 메인테이너 분이
이제 고쳤으면 좋겠다 라고 피드백을 주시고

385
00:29:01,030 --> 00:29:03,520
그래서 최종적으로 PR을 올리게 되었는데요

386
00:29:03,550 --> 00:29:05,950
PR 같은 경우에는 아까 제가 말씀드렸듯이

387
00:29:05,980 --> 00:29:08,890
깃허브에서 관리하고 있는 풀 리퀘스트라고 부르는

388
00:29:08,920 --> 00:29:13,370
"코드를 최종적으로 병합해주세요"라고 하는
어떤 게시물이라고 보시면 될 것 같습니다

389
00:29:13,780 --> 00:29:18,340
이때는 내가 고쳤던 그 버그에 대한 자세한 설명들

390
00:29:18,370 --> 00:29:21,710
그리고 어떻게 고쳤는지 등을 잘 설명해야 되는데요

391
00:29:22,240 --> 00:29:26,890
좌측에 보시는 것처럼 ImageMagick 같은
경우에는 굉장히 오래되었기도 하고

392
00:29:26,920 --> 00:29:31,350
굉장히 체계가 잘 잡혀 있는 프로젝트 중
하나라고 볼 수 있습니다

393
00:29:31,780 --> 00:29:36,040
지금이 2020년이기 때문에
ImageMagick은 거의 30년이 된

394
00:29:36,070 --> 00:29:38,140
이미지 라이브러리 중에 하나고요

395
00:29:39,310 --> 00:29:44,560
그래서 이미 PR이나 이슈를 올릴 때
템플릿이 작성되어 있습니다

396
00:29:44,590 --> 00:29:48,360
그래서 여러분이 PR을 올리실 때
자동적으로 내용들이 채워지게 되고요

397
00:29:48,390 --> 00:29:52,990
그 내용들에 맞게끔
여러분이 추가적인 코멘트를 기입하면

398
00:29:53,020 --> 00:29:54,440
PR을 날릴 수 있게 됩니다

399
00:29:55,390 --> 00:29:57,970
보시는 것처럼 이제 뭔가 컨트리뷰션 가이드나

400
00:29:58,000 --> 00:30:02,120
아니면 PR에 뭔가 중복된 사항들이 없는지
검토하는 것들에 대한

401
00:30:02,150 --> 00:30:04,100
체크리스트들을 제공하고 있고요

402
00:30:04,570 --> 00:30:07,140
그런 것들을 하나하나 읽어보고 체크를 한 다음에

403
00:30:07,360 --> 00:30:11,850
여러분이 어떤 것을 고쳤고
어떤 식으로 고친 것을 테스트할 수 있는지

404
00:30:11,920 --> 00:30:15,750
테스트의 방법들을
추가적으로 설명에 기입을 해주면 됩니다

405
00:30:16,120 --> 00:30:20,470
저 같은 경우에는
현재의 ImageMagick의 버전에서는

406
00:30:20,500 --> 00:30:25,760
어떤 문제가 있었고 그것을 최종적으로
어떻게 고쳤는지에 대한 설명을 드렸습니다

407
00:30:26,200 --> 00:30:30,090
똑같은 동작을 했을 때
기존 버전에서는 버그로 잡히지만

408
00:30:30,160 --> 00:30:35,670
이 PR에서 돌려볼 경우에는 버그로 잡히지 않는
그런 현상을 자세히 설명을 해주시면 되고요

409
00:30:36,050 --> 00:30:40,570
보시는 것처럼 수정 전 버전에서는 오른쪽 그림과 같이

410
00:30:40,600 --> 00:30:43,850
밑줄에 대한 크기라거나 아니면 취소선에 대한

411
00:30:43,870 --> 00:30:47,660
위치라거나 이런 것들이 제대로 제공되지 않고 있지만

412
00:30:48,070 --> 00:30:50,100
최종적으로 고쳤던 PR에서는

413
00:30:50,120 --> 00:30:54,250
이제 밑줄과 취소선이 제대로 위치에 들어가 있고

414
00:30:54,280 --> 00:30:56,650
두께도 잘 잡혀 있는 것을 볼 수 있습니다

415
00:30:57,070 --> 00:31:00,910
추가적으로 밑줄에 대해서도
색깔을 정의해줘야 되는데

416
00:31:00,940 --> 00:31:04,720
예를 들면 빨간 색깔로 적용된 글씨에서

417
00:31:04,750 --> 00:31:10,630
밑줄은 그대로 글자 색깔 같이
빨간 색깔 밑줄이 들어가야 되지만

418
00:31:10,900 --> 00:31:14,160
기존 버전에서는
검정 색깔로 표기가 됐던 문제가 있었습니다

419
00:31:14,440 --> 00:31:18,260
그런 것들을 같이 고쳐줬던 것도 PR에 반영을 했고요

420
00:31:19,510 --> 00:31:23,080
그래서 지금부터 나오는 코드들은 C 언어지만

421
00:31:23,110 --> 00:31:25,240
굉장히 쉽게 설명드리도록 하겠습니다

422
00:31:25,720 --> 00:31:29,200
이제 보시면 초록 색깔 영역과 같이

423
00:31:29,220 --> 00:31:33,160
뭔가 그 글자의 색상 정보가 있을 경우에는

424
00:31:33,190 --> 00:31:36,710
그 글자의 색상 정보를 stroke

425
00:31:36,730 --> 00:31:40,270
윗줄에도 같이 적용해주는 형태로
코드가 반영이 되었고요

426
00:31:41,470 --> 00:31:47,670
그리고 ImageMagick 같은 경우에는
밑줄이나 취소선에 대한 위치를

427
00:31:47,690 --> 00:31:52,300
FreeType이라고 아까 전에 설명드렸던
폰트 렌더링 라이브러리에

428
00:31:52,330 --> 00:31:55,700
어떤 정보를 받아서
그 정보를 바탕으로 처리하게 됩니다

429
00:31:56,260 --> 00:32:01,510
그런데 그 정보가
비교적 잘못 설명이 되어 있었기 때문에

430
00:32:01,540 --> 00:32:06,000
보시는 것처럼 매트릭스라는 정보 객체에서

431
00:32:06,030 --> 00:32:10,390
폰트의 픽셀 정보를 받아오고

432
00:32:10,420 --> 00:32:15,260
그 정보를 바탕으로 밑줄이나 아니면 취소선의 위치를

433
00:32:15,280 --> 00:32:20,400
잘 계산할 수 있는 형태로
PR의 코드가 반영된 것을 볼 수 있습니다

434
00:32:21,520 --> 00:32:27,020
그래서 최종적으로 ImageMagick에서
제공하고 있는 CLI를 사용했을 때는

435
00:32:27,430 --> 00:32:30,750
convert -size 320x120

436
00:32:30,780 --> 00:32:36,340
어떻게 보면
너비가 320고 높이가 120인 캔버스에서

437
00:32:36,370 --> 00:32:40,210
하늘 색깔로 적용된 캔버스에서
이제 어떤 특정한 폰트를 그리는 거

438
00:32:40,240 --> 00:32:43,630
각도를 꺾어서 밑줄까지 적용한 폰트를 그렸을 때

439
00:32:43,650 --> 00:32:47,400
보시는 것처럼 밑줄의 크기라든가 위치라든가

440
00:32:47,440 --> 00:32:49,900
아니면 색상이 잘 적용된 것을 볼 수 있습니다

441
00:32:50,290 --> 00:32:55,240
지금 이 커맨드 같은 경우엔 ImageMagick을
사용할 때는 굉장히 다양한 방법이 있는데요

442
00:32:55,420 --> 00:33:01,070
아까 전에 말씀드렸듯이 파이썬에서
Wand 패키지를 통해서 이미지를 렌더링 할 수 있는 방법

443
00:33:01,320 --> 00:33:05,470
혹은 ImageMagick 자체에서
제공하고 있는 커맨드라인 도구

444
00:33:05,500 --> 00:33:09,700
convert라는 도구를 이용해서
이미지 렌더링을 테스트할 수 있는 방법

445
00:33:09,850 --> 00:33:13,450
혹은 C 라이브러리로 제공된
ImageMagick을

446
00:33:13,480 --> 00:33:16,590
C에서 불러와가지고 사용할 수 있는
방법들이 있습니다

447
00:33:17,230 --> 00:33:21,460
지금 왜 CLI를 사용했는지 설명해 드리고자 하면

448
00:33:21,490 --> 00:33:25,210
제가 ImageMagick에서 어떤 부분을 고쳤을 때

449
00:33:25,240 --> 00:33:29,800
그것을 파이썬의 Wand로 설명을 드리게 되면

450
00:33:29,820 --> 00:33:33,250
ImageMagick 메인테이너 분들은
잘 모르실 거예요

451
00:33:33,280 --> 00:33:36,440
그래서 바로
그 컴퓨터에서 바로 테스트할 수 있는

452
00:33:36,460 --> 00:33:41,510
가장 쉬운 방법인 CLI로 설명을 드렸던 것 같습니다

453
00:33:42,280 --> 00:33:46,900
제가 이런 기여를 했던 이유는
저는 파이썬의 Wand를 사용하고 있었고

454
00:33:47,110 --> 00:33:52,200
파이썬의 Wand로 어떻게 보면 포토샵과 비슷한
기능을 하기 위한 프로젝트를 진행하고 있었어요

455
00:33:52,450 --> 00:33:56,060
그때 몇 가지 기능들이 제대로 동작이 안 돼서
그때 기여를 했던 것 같고요

456
00:33:56,410 --> 00:34:00,790
이 버전이 반영되고 나서
파이썬의 Wand로 이미지를 렌더링할 경우에도

457
00:34:00,820 --> 00:34:03,190
굉장히 잘 작동되는 것을 볼 수 있었습니다

458
00:34:04,720 --> 00:34:08,180
그래서 Wand로 그리는 것을 예시로 들어볼게요

459
00:34:08,470 --> 00:34:12,260
아까 전에 글씨를 그렸던 것과
굉장히 비슷한 코드인데요

460
00:34:12,850 --> 00:34:17,950
Wand 패키지에서 drawing이랑
image, color 패키지를 불러오게 됩니다

461
00:34:18,250 --> 00:34:24,710
그 다음에 이미지를 마찬가지로
320 너비에 100 높이로 잡고

462
00:34:25,280 --> 00:34:27,660
배경은 하늘 색깔로 잡았습니다

463
00:34:27,850 --> 00:34:32,520
그 다음에 Drawing()을 통해서
실제로 그 캔버스 안에서

464
00:34:32,540 --> 00:34:34,760
글자들을 렌더링 할 수 있게 되는데요

465
00:34:35,460 --> 00:34:40,990
마찬가지로 폰트도 동일한 걸로 정의를 해보고
언더라인 데코레이션도 넣어보고

466
00:34:41,020 --> 00:34:46,510
그리고 폰트 색깔은 검정 색깔
그리고 텍스트의 위치는 28에 68px

467
00:34:46,530 --> 00:34:48,550
어떻게 보면 X축 Y축입니다

468
00:34:48,580 --> 00:34:54,330
그리고 나서 이미지를 test.jpg로 생성해
봤을 때 잘 작동되는 것을 볼 수 있었습니다

469
00:34:56,800 --> 00:34:59,400
여기까지가 오늘 발표의 전부인데요

470
00:35:00,630 --> 00:35:06,040
이제 여러분 파이썬을 개발하시면서 뭔가
문제가 발생할 수 있는 라이브러리들이 좀 있습니다

471
00:35:06,070 --> 00:35:11,390
좀 예시로 들어보면 Pillow 같은 경우에도
텍스트의 아웃라인

472
00:35:12,250 --> 00:35:14,100
테두리를 정하고 싶을 때

473
00:35:14,180 --> 00:35:16,220
그것을 서포트 하지 않고 있는데요

474
00:35:16,880 --> 00:35:22,360
만약 여러분들이 뭔가 이런 이미지 라이브러리
혹은 다른 파이썬 라이브러리들이더라도

475
00:35:22,390 --> 00:35:27,910
뭔가 문제들, 기능이 없다거나
기능이 버그로 동작하거나 하는 것들이 발견됐을 때

476
00:35:28,120 --> 00:35:33,330
기회가 된다면 조금 더 관심을
가져서 실제로 PR까지 날려볼 수 있는

477
00:35:33,360 --> 00:35:35,320
경험들을 하시면

478
00:35:35,350 --> 00:35:39,760
여러분의 파이썬 프로젝트에 조금 더 귀중한
경험이 되지 않을까? 라는 생각을 하고 있습니다

479
00:35:40,210 --> 00:35:44,920
다음에는 조금 더 유익한 정보로
만날 수 있으면 좋을 것 같습니다

480
00:35:45,380 --> 00:35:46,530
네 이상입니다



