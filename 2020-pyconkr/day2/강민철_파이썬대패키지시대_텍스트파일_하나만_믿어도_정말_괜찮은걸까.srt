1
00:00:10,335 --> 00:00:11,093
안녕하세요

2
00:00:11,118 --> 00:00:15,280
파이썬 대 패키지 시대 텍스트 파일 하나만 믿어도 정말 괜찮은 걸까

3
00:00:15,305 --> 00:00:17,774
발표를 맡게 된 강민철이라고 합니다

4
00:00:18,055 --> 00:00:23,326
이번에 저는 기존 PIP를 이용한 파이썬
패키지 관리 컨벤션이 갖고 있는 문제점과

5
00:00:23,350 --> 00:00:28,740
그를 대체할 수 있는 다양한 패키지 의존성
관리자에 대한 소개 및 비교분석 결과를

6
00:00:28,765 --> 00:00:30,485
발표로 준비하게 되었습니다

7
00:00:31,090 --> 00:00:34,516
본격적인 발표를 진행하기 앞서서 간략하게 저의 소개를 드리자면

8
00:00:34,540 --> 00:00:39,793
저는 현재 〈오픈소스 컨설팅〉이라고 하는
회사에서 근무하고 있는 시스템 엔지니어이자

9
00:00:39,818 --> 00:00:42,688
온/오프라인 프로그래밍 교육을 하고 있는 강사입니다

10
00:00:42,940 --> 00:00:47,102
또한 제가 배울 수 있는 것들은 모두 다
배우고 싶어 하는 어떤 욕심많은 학생이기도 하고요

11
00:00:47,127 --> 00:00:49,641
취미로 오픈소스에 컨트리뷰션을 하기도 합니다

12
00:00:50,260 --> 00:00:52,588
자 그러면 원활하게 발표 주제에 접근하기 위해서

13
00:00:52,613 --> 00:00:56,221
꼭 필요한 배경지식들을 빠르게 설명해 드리도록 하겠습니다

14
00:00:56,246 --> 00:00:58,980
우선 모듈, 패키지, 라이브러리가 무엇인지

15
00:00:59,005 --> 00:01:04,246
그리고 기존 패키지 인스톨러인 PIP에 대해서 설명해드릴 예정이고요

16
00:01:04,270 --> 00:01:08,235
그리고 의존성 관리란 무엇이며 또 왜 필요한지 말씀드린 뒤에

17
00:01:08,598 --> 00:01:13,461
파이썬과 옆 동네 자바 스크립트의 어떤 의존성 관리를 비교해보도록 하겠습니다

18
00:01:13,900 --> 00:01:16,666
우선 모듈은 그냥 파이썬으로 정의된 파일입니다

19
00:01:16,690 --> 00:01:20,336
실행 가능한 파이썬 파일을 모듈이라고 보시면 됩니다

20
00:01:20,830 --> 00:01:24,187
그리고 패키지는 모듈의 집합이라고 보셔도 되는데

21
00:01:24,218 --> 00:01:28,636
조금 더 자세하게는 파이썬코드내에서 '점 모듈 이름'으로써

22
00:01:28,660 --> 00:01:33,743
그 모듈 속 내용에 접근할 수 있게끔 하는 네임스페이스를 패키지라고 부릅니다

23
00:01:34,030 --> 00:01:40,186
이번 발표에서는 프로젝트를 이루는 단위 즉
프로젝트를 완성하기 위해 사용하는 어떤 코드뭉치

24
00:01:40,210 --> 00:01:45,555
혹은 모듈의 집합을 통틀어서 편의상 '패키지'라고 지칭할 예정입니다

25
00:01:46,150 --> 00:01:51,526
그리고 마지막으로 라이브러리는 쓸만한
기능들을 미리 모듈 혹은 패키지로 만들어 놓은 것

26
00:01:51,550 --> 00:01:55,977
즉 미리 준비된 모듈 혹은 패키지를 라이브러리라고 부릅니다

27
00:01:56,560 --> 00:02:01,816
파이썬이 준비해둔 라이브러리에는 '파이썬 스탠다드 라이브러리' 즉 표준 라이브러리와

28
00:02:01,840 --> 00:02:06,798
지금 이 순간에도 수많은 파이써니스타들이
다 배포하고 있고 또 다운로드 받을 수 있는

29
00:02:06,823 --> 00:02:12,795
어떤 패키지 저장소인 파이썬 패키지 인덱스
PyPI가 제공하고 있는 라이브러리가 있습니다

30
00:02:12,820 --> 00:02:19,635
이 PyPI에는 방대한 양의 패키지가 존재하고 또 실시간으로 업데이트되고 있는 만큼

31
00:02:19,660 --> 00:02:25,306
이 패키지들을 설치하고 삭제하고 또 현재
설치된 패키지들의 목록들을 조회하는 등

32
00:02:25,331 --> 00:02:29,000
패키지를 관리해주는 툴도 당연히 있어야 될 겁니다

33
00:02:29,456 --> 00:02:36,829
파이썬에서는 바로 이 PIP라고 하는 툴이 이 파이썬의
패키지 혹은 라이브러리를 관리해준다 라고 보셔도 됩니다

34
00:02:37,180 --> 00:02:41,746
예컨대 "pip install {패키지 이름}"이라고 하는 명령어를 이용한다면

35
00:02:41,770 --> 00:02:48,102
이 PIP는 PyPI에서 해당하는 패키지를 자동으로
찾아주고 다운로드 해주고 설치도 진행해줍니다

36
00:02:48,490 --> 00:02:54,706
원하는 특정 버전의 패키지를 지정해서 설치할
수도 있고 반대로 설치된 패키지를 제거할 수도 있고요

37
00:02:54,730 --> 00:02:58,636
뭐 이미 설치된 패키지를 최신 버전으로 업그레이드할 수도 있습니다

38
00:02:58,660 --> 00:03:03,736
이렇게 PIP는 패키지들을 관리하는 다양한 명령들을 제공하는데요

39
00:03:03,760 --> 00:03:08,649
그중에서도 이 명령어가 이번 발표를
이해하시는데 있어서 좀 중요한 역할을 합니다

40
00:03:08,674 --> 00:03:13,006
이 "pip freeze"라고 하는 명령어는 현재 프로젝트 환경에서 설치된

41
00:03:13,030 --> 00:03:17,382
모든 패키지들의 이름 및 버전 정보를 출력해주는 명령입니다

42
00:03:17,407 --> 00:03:19,383
예를 들면 뭐 이렇게 말이죠

43
00:03:20,320 --> 00:03:22,413
자 그럼 의존성 관리는 무엇일까요?

44
00:03:22,438 --> 00:03:25,636
뭐 이미 아시는 분들은 조금만 더 기다려주시면 감사하겠습니다

45
00:03:25,660 --> 00:03:31,129
의존성 관리는 지금 이 프로젝트 환경에서 어떤 버전의 어떤 패키지가 쓰였나

46
00:03:31,154 --> 00:03:36,841
그리고 어떤 버전의 어떤 패키지가 쓰일 수 있나를 관리하는 것을 말합니다

47
00:03:37,090 --> 00:03:41,316
다시 말씀드려서 이제 프로젝트가 어떤 외부 라이브러리를 쓰고 있는지를

48
00:03:41,341 --> 00:03:44,596
따로 관리해주는 것을 의존성 관리라고 부르는데요

49
00:03:44,620 --> 00:03:49,307
이 의존성 관리는 어떤 프로젝트 흥망에도 직접적으로 영향을 줄 수 있을 만큼

50
00:03:49,332 --> 00:03:52,186
개발을 하는데 있어서 매우 매우 중요한 요소입니다

51
00:03:52,210 --> 00:03:55,585
그러면 정확하게 이게 왜 중요할까요?

52
00:03:55,639 --> 00:03:58,639
패키지를 관리하는 게, 패키지를 따로 관리하는 게

53
00:03:58,664 --> 00:04:02,060
왜 프로젝트의 흥망에도 영향을 줄 만큼 중요한 요소일까요?

54
00:04:02,085 --> 00:04:04,846
예를 들어서 제가 프로젝트를 막 만들고 있는데

55
00:04:04,870 --> 00:04:09,845
제 프로젝트에 꼭 필요한 패키지인 "PyconKorea"라고 하는 패키지를 설치했다

56
00:04:09,870 --> 00:04:11,063
라고 가정해봅시다

57
00:04:11,440 --> 00:04:16,736
그리고 이 "PyconKorea"라고 하는 패키지는 A, B, C라고 하는 외부 모듈

58
00:04:16,761 --> 00:04:18,605
혹은 패키지로 이루어져 있고

59
00:04:18,630 --> 00:04:22,840
A라고 하는 모듈은 A'이라고 하는 다른 외부모듈

60
00:04:22,865 --> 00:04:25,539
혹은 패키지가 쓰였다 라고 가정해봅시다

61
00:04:26,050 --> 00:04:31,245
자 이런 상황에서 제 프로젝트에는 "PyconKorea"라고 하는 패키지가 필요한데

62
00:04:31,269 --> 00:04:35,994
그럼 당연히 제 프로젝트를 사용한 미래의 사용자들은 그때 그때 제 프로젝트에서

63
00:04:36,019 --> 00:04:41,056
꼭 사용하는 "PyconKorea" 패키지를
그때그때 설치해 주는 방법도 있을 수가 있겠죠

64
00:04:41,080 --> 00:04:42,899
설치를 해줘야겠죠, 그렇죠?

65
00:04:43,270 --> 00:04:48,946
그런데 이때 A' 모듈 혹은 패키지가
갑자기 버전이 바뀌었다 라고 가정해봅시다

66
00:04:48,970 --> 00:04:53,882
이거는 A'이라고 하는 코드가 바뀌었음을 의미하겠죠. 그렇죠?

67
00:04:53,907 --> 00:04:59,202
그런데 A'이라고 하는 새 버전이
A한테까지 영향을 끼친다면 어떻게 될까요?

68
00:04:59,227 --> 00:05:02,625
좀 안 좋은 사례이긴 하지만 이 A'의 패치로 인해서

69
00:05:02,650 --> 00:05:06,460
A도 기존 버전으로는 좀 동작이 안 되는 경우도 있을 겁니다

70
00:05:06,485 --> 00:05:08,704
A도 덩달아 패치가 필요해지는 거죠

71
00:05:09,430 --> 00:05:12,319
이렇게 되면 당연히 제 프로젝트에도 영향을 받겠죠. 그렇죠

72
00:05:12,344 --> 00:05:17,980
옛날 버전에 A를 상정하고 맞는 프로젝트인데
A' 때문에 A가 변해버렸으니까

73
00:05:18,005 --> 00:05:20,065
만약에 옛날 버젼을 고려하지 않는다면

74
00:05:20,090 --> 00:05:24,591
버전 때문에 설치가 제대로 안 되는 이용자들도 분명히 생길 겁니다. 그렇죠

75
00:05:24,616 --> 00:05:26,716
그러면 아예 이런 방법은 어떨까요?

76
00:05:26,740 --> 00:05:32,266
제 프로젝트에 쓰는 특정 버전의 의존성 모듈 A, B, C, A' 모두 다

77
00:05:32,290 --> 00:05:35,516
그냥 내 프로젝트 안에다가 소스코드로 박제해버리는 거예요

78
00:05:35,950 --> 00:05:37,306
어떨 거 같으세요?

79
00:05:37,330 --> 00:05:41,117
코드가 돌아가기가 돌아가겠지만 당연히 문제가 좀 생길 수가 있겠죠

80
00:05:41,142 --> 00:05:45,676
애초에 프로젝트에 싣을 수 없는 코드도 있을 뿐더러 싣을 수 있다고 해도

81
00:05:45,700 --> 00:05:50,910
꼬리에 꼬리를 무는 어떤 패키지들의 코드
때문에 프로젝트 자체도 굉장히 무거워질 겁니다. 그렇죠?

82
00:05:50,935 --> 00:05:56,956
또 만일에 A'이나 A의
업데이트 이유가 보안상의 취약점 때문이었다면

83
00:05:56,981 --> 00:06:01,396
내 프로젝트는 보안에 취약한 구 버전을 사용하는 꼴이 되기도 쉽고요

84
00:06:01,420 --> 00:06:06,301
이렇듯 의존성 관리가 제대로 되지 않는다면 실컷 다 만들어놓은 프로젝트인데도

85
00:06:06,326 --> 00:06:09,091
이 광활한 우주에서 내 컴퓨터에서만 동작하는

86
00:06:09,116 --> 00:06:12,226
어떤 프로젝트를 만드는 대참사를 일으킬 수도 있습니다

87
00:06:12,250 --> 00:06:17,026
저도 개인적으로도 이런 의존성 관리가 잘 안
돼가지고 프로젝트가 여러 번 망한 적이 있습니다

88
00:06:17,050 --> 00:06:21,586
그럼 지금까지 파이썬에서는 의존성 관리를
어떻게 해오고 있었는지를 한번 알아볼까요?

89
00:06:21,610 --> 00:06:25,586
가장 유명하고 또 대중적인 방법은 이 명령어를 이용하는 방법입니다

90
00:06:25,961 --> 00:06:28,335
"pip freeze"는 아까 말씀드렸다시피

91
00:06:28,360 --> 00:06:34,726
"현재 내 프로젝트 환경에 설치된 모든 패키지
이름과 버전을 출력해줘"라고 하는 명령어고요

92
00:06:34,750 --> 00:06:39,787
이 명령어의 결과를 어디에 기록하길
바랐냐면 "requirements.txt"라고 하는

93
00:06:39,812 --> 00:06:44,485
텍스트 파일의 기록하기를 바란다라고 하는 명령어라고 보시면 됩니다

94
00:06:44,710 --> 00:06:47,778
즉 이 명령어를 수행하면은 지금 보시는 것처럼

95
00:06:47,803 --> 00:06:52,013
"pip freeze"의 결과가, "pip freeze"를 한 명령어의 결과가

96
00:06:52,038 --> 00:06:55,586
"requirements.txt" 파일 안에 자동으로 담기게 될 겁니다

97
00:06:56,260 --> 00:07:01,185
그리고 이렇게 만들어진 패키지의 버전에
대한 정보를 담은 "requirements.txt" 파일은

98
00:07:01,210 --> 00:07:05,877
프로젝트 환경이 아닌 다른 환경 예컨대 뭐 다른 유저가 사용하는 환경에서

99
00:07:05,902 --> 00:07:08,086
이런 명령으로 설치할 수가 있습니다

100
00:07:08,350 --> 00:07:12,391
이 명령은 어떤 명령하냐면 저 패키지를 설치해 건데요

101
00:07:12,850 --> 00:07:16,528
이 파일의 내용에 맞게 설치할 거예요라고 하는 뜻입니다

102
00:07:16,553 --> 00:07:21,490
그러면 이 파일에 담긴 이름, 그리고 버전에
맞는 패키지들이 자동적으로 설치가 되겠죠. 그렇죠

103
00:07:21,515 --> 00:07:25,302
즉 지금까지 파이썬 의존성 관리는

104
00:07:25,327 --> 00:07:31,425
프로젝트 수행 환경에서 사용된 패키지와
버전들을 모조리 기록한 "requirements.txt"를 만들고

105
00:07:31,450 --> 00:07:37,133
또 다른 환경에서 그 "requirements.txt"을 갖고
그대로 설치하는 이러한 방식으로 진행되곤했습니다

106
00:07:37,510 --> 00:07:39,946
이거는 꽤나 간편하고 또 대중적인 방법입니다

107
00:07:39,970 --> 00:07:46,546
제가 심심해서 발표 준비할 때 파이콘코리아 공식
홈페이지는 어떻게 의존성을 관리하는지 한번 찾아봤었는데

108
00:07:46,570 --> 00:07:49,005
여기도 "requirements.txt"를 사용하더라고요

109
00:07:49,030 --> 00:07:53,600
명령어 한번으로 패키지의 이름과 버전 정보가 모조리 싹다 담기니까

110
00:07:53,625 --> 00:07:55,516
꽤나 간편한 방법이기도 합니다

111
00:07:55,865 --> 00:07:57,738
근데 제 발표 제목을 보시면 아시겠지만

112
00:07:57,763 --> 00:08:00,177
저는 이번에 이렇게 PIP를 이용해서

113
00:08:00,202 --> 00:08:02,700
모조리 패키지 관리를 하는 이러한 방식에 대해서

114
00:08:02,724 --> 00:08:06,034
어떤 문제점을 짚고 또 대안점을 제시할 예정입니다

115
00:08:06,059 --> 00:08:09,551
근데 그 전에 이 문제의식에 대해서 말씀드리기 전에요

116
00:08:09,576 --> 00:08:14,649
옆동네 자바스크립트에서는 어떻게 패키지 의존성을
관리하는지 잠깐 보고 오도록 할까요?

117
00:08:15,070 --> 00:08:19,276
왜 갑자기 파이콘에서 뜬금없이 자바스크립트
말씀을 하세요라고 물어보실 수도 있겠지만

118
00:08:19,300 --> 00:08:24,226
이 자바스크립트가 패키지 관리를 제가
개인적으로 생각했을때는 굉장히 기가 막히게 하거든요

119
00:08:24,250 --> 00:08:29,046
참고로 NPM과 Yarn은 파이선의 PIP와 비슷한 대표적인

120
00:08:29,071 --> 00:08:32,610
자바스크립트의 패키지 관리자 혹은 관리툴이라고 보시면 됩니다

121
00:08:33,460 --> 00:08:39,202
우선 이 자바스크립트. 대표적으로 NPM은
이 세 녀석들로 패키지 의존성을 관리합니다

122
00:08:39,428 --> 00:08:43,727
package,json  package-lock,Json
node_modules 디렉토리

123
00:08:44,620 --> 00:08:47,705
우선 이 "node_modules"는 이 NPM으로 다운로드한

124
00:08:47,730 --> 00:08:50,774
외부 라이브러리들이 담기는 폴더라고 보시면 됩니다

125
00:08:50,799 --> 00:08:55,477
NPM으로 외부에서부터 패키지들을 다운로드하시면 여기에 담긴다라고 보시면 돼요

126
00:08:55,690 --> 00:08:57,703
다음은 이 "package.json"파일입니다

127
00:08:57,728 --> 00:09:02,176
이 파일은 프로젝트가 시작할 때 쓰는 "npm init"을 치면 자동으로

128
00:09:02,200 --> 00:09:06,948
생성되는 프로젝트 정보와 의존성을 관리해주는 문서라고 보시면 됩니다

129
00:09:06,973 --> 00:09:11,626
잘 보시면 이 패키지의 이름, 버전, 설명, 저장소 키워드, 라이선스 등등을

130
00:09:11,650 --> 00:09:14,079
담고 있다 라고 하는 걸 확인할 수가 있죠

131
00:09:14,440 --> 00:09:20,956
주목할 점은 이 NPM은 개발용 패키지와 배포용
패키지를 따로 관리할 수 있다 라는 점입니다

132
00:09:20,980 --> 00:09:25,996
우리 프로젝트를 생각할 때 프로젝트 자체 개발을 위해서 꼭 설치해줘야 되는

133
00:09:26,020 --> 00:09:29,356
배포용 패키지. 그리고 디버깅, 테스트처럼

134
00:09:29,380 --> 00:09:34,216
개발 과정에 편의를 위해서 설치하는 개발용 패키지는 다를 수 있지 않겠어요

135
00:09:34,240 --> 00:09:38,685
NPM은 이렇듯 배포용 패키지를 설치 및 관리해주는 명령어와

136
00:09:38,710 --> 00:09:43,274
개발용 패키지를 설치 및 관리해주는 명령어가 구분되어 있습니다

137
00:09:45,130 --> 00:09:47,019
다음은 "package-lock" 파일입니다

138
00:09:47,044 --> 00:09:50,273
언뜻 보면 좀 낯설 수도 있는 이 "package-lock" 파일도

139
00:09:50,298 --> 00:09:53,928
굉장히 굉장히 유용하고 필수적인 역할을 맡고 있는데요

140
00:09:53,953 --> 00:09:58,215
이 "package-lock"이라고 하는 파일은
"node_modules"나

141
00:09:58,240 --> 00:10:03,346
패키지 파일이 변경될 때마다 자동으로 생성되고 또 업데이트 되는 파일입니다

142
00:10:03,370 --> 00:10:08,323
다시 말씀드려서 node_modules 디렉토리나 패키지 타입이 변경될 때마다

143
00:10:08,348 --> 00:10:11,056
그 순간의 스냅샷을 저장하는 역할을 합니다

144
00:10:11,080 --> 00:10:15,244
즉 "node_modules"나 "package.json"의 순간을 저장해서

145
00:10:15,269 --> 00:10:19,415
항상 동일한 모듈 트리의 생성을 보장하는 녀석이라고 보시면 됩니다

146
00:10:19,440 --> 00:10:23,135
이렇게 패키지 파일에서는 해당 프로젝트에 대한 정보와

147
00:10:23,160 --> 00:10:27,436
설치된 패키지들의 의존성 정보들이 종류별로 담기게되고요

148
00:10:27,460 --> 00:10:34,013
"package-lock"파일 즉 락파일에는 패키지와 "node_modules"의 어떤 변경사항이 생길때마다

149
00:10:34,038 --> 00:10:38,446
"node_modules" 디렉토리의 그 순간 순간의 스냅샷을 저장하기 때문에

150
00:10:38,470 --> 00:10:41,880
"package"파일과 "package-lock"파일만 git에다가 올리게 되면

151
00:10:41,905 --> 00:10:47,305
항상 동일한 패키지트리인 "node_modules"를
만들 수 있게끔 보장할 수가 있게 되는 겁니다

152
00:10:48,190 --> 00:10:53,626
저는 개인적으로는 이런 어떤 옆 동네
자바스크립트 패키지 의존성 관리를 보고 나니까

153
00:10:53,650 --> 00:10:59,118
개인적으로 PIP를 이용한 기존에 requirements.txt
방식에 좀 문제의식이 느껴졌습니다

154
00:10:59,380 --> 00:11:01,730
구체적으로 어떤 문제들이 있을 수 있을까요?

155
00:11:01,755 --> 00:11:03,766
저는 다음과 같이 꼽았습니다

156
00:11:03,790 --> 00:11:06,799
이원화되어 있지 않은 개발용 패키지, 배포용 패키지

157
00:11:06,824 --> 00:11:10,589
의존관계 파악의 어려움. 특정 패키지 버전지정의 어려움

158
00:11:10,614 --> 00:11:13,039
그리고 설치시 발생할 수 있는 문제

159
00:11:13,064 --> 00:11:17,596
일단 개발용 패키지, 배포용 패키지가
이원화되어 있지 않아서 생기는 문제들이 있습니다

160
00:11:17,620 --> 00:11:20,806
아까 전에 제가 NPM의 "package.json"에서 보여드렸듯이

161
00:11:20,830 --> 00:11:24,845
개발을 할 때 있어서는, 개발할 때 있어서 사용하는 패키지는

162
00:11:24,870 --> 00:11:29,056
으레 개발용 패키지와 배포용 패키지가 구분되기 마련이잖아요. 그렇죠

163
00:11:29,080 --> 00:11:33,586
만약에 개발용 패키지가 배포용 패키지의 일부라고 가정을 한다면

164
00:11:33,611 --> 00:11:37,304
배포용 패키지를 이 명령어를 이용해서 한 번에 만든다고 쳐도

165
00:11:37,329 --> 00:11:42,047
나머지 개발용 패키지들은 직접 손으로
써가면서 기록해야 된다는 불편함이 있습니다

166
00:11:42,520 --> 00:11:45,863
또 만약에 개발용 패키지들의 종류 및 버전이

167
00:11:45,888 --> 00:11:48,924
배포용 패키지들을 완전히 포함하고 있지는 않을 때

168
00:11:48,949 --> 00:11:52,261
즉 배포용 패키지로는 사용하지 않을 패키지가

169
00:11:52,286 --> 00:11:55,876
개발용 패키지에 포함되어 있다면 더욱 관리가 귀찮아지더라구요

170
00:11:55,900 --> 00:12:00,446
이때는 다음과 같이 특정 디렉토리 하에 파일을 이렇게 구분을 해놓으면

171
00:12:00,471 --> 00:12:04,186
배포용, 개발용 패키지가 한방에 설치가 되겠지만

172
00:12:04,210 --> 00:12:09,613
이때는 개발용 패키지 의존성 관리문서와 배포용 패키지 의존성 관리문서를

173
00:12:09,638 --> 00:12:13,125
모두 돈으로 써가면서 관리해야 되는 번거로움이 좀 있었습니다

174
00:12:13,510 --> 00:12:18,905
PIP을 이용한 패키지 관리의 두 번째
문제는 의존관계 파악이 어렵다는 데 있습니다

175
00:12:18,945 --> 00:12:24,459
일예로 "Keras"를 PIP로 설치한 뒤에
"pip freeze"를 하면은 다음과 같이 보이고요

176
00:12:24,484 --> 00:12:29,206
Django REST Framework를 설치하고
"pip freeze"를 하면은 다음과 같이 보이게 됩니다

177
00:12:29,230 --> 00:12:34,589
어떤 패키지가 어떤 패키지에 의존적인 지 각자의 패키지는 무슨 관계이며

178
00:12:34,614 --> 00:12:38,656
또 어떤 역할을 하는지 딱 보면은 감이 잘 안 오시죠. 그렇죠

179
00:12:38,680 --> 00:12:42,515
더군다나 "pip uninstall"을 통해서 특정 패키지를 삭제해도

180
00:12:42,540 --> 00:12:47,296
이런 의존성 패키지까지는 리커시브하게 삭제가 되지 않기 때문에

181
00:12:47,320 --> 00:12:52,563
프로젝트가 진행되면 진행될수록 어떤 패키지에
의존관계 파악이 더욱더 어려워질 겁니다

182
00:12:53,380 --> 00:12:56,656
마지막으로 설치할 때 어떤 생길 수 있는 문제점도 있습니다

183
00:12:56,680 --> 00:13:02,116
즉 "pip install -r requirements.txt" 명령어가 문제를 일으킬 수도 있습니다

184
00:13:02,140 --> 00:13:05,405
가상환경만 사용하지 않고 생으로 설치하게 될 경우

185
00:13:05,430 --> 00:13:09,496
만약에 설치 환경에서 이미 설치한 패키지와 상충되는 경우에는

186
00:13:09,520 --> 00:13:13,696
당연히 기존의 어떤 환경에 영향을 끼칠 것이고

187
00:13:13,720 --> 00:13:19,276
애초에 특정 패키지 설치가 안 되는 환경일
경우에는 프로젝트 전체가 설치되지를 않겠죠

188
00:13:19,300 --> 00:13:23,716
그래서 대부분 가상환경을 켜둔 채 "pip install"을 진행하게 될 겁니다

189
00:13:23,740 --> 00:13:28,936
그런데 이럴 경우에는 어떤 통일되지 않은 패키지 관리자와 가상환경 때문에

190
00:13:28,960 --> 00:13:32,476
바로 바로 설치가 안 되는 경우도 간혹 있더라고요

191
00:13:32,500 --> 00:13:35,857
예컨대 Anaconda에서 지원하는 "conda" 패키지 관리자와

192
00:13:35,882 --> 00:13:40,845
"conda env"는 "requirements.txt"를
내보내고 또 설치할 수는 있지만

193
00:13:40,870 --> 00:13:46,985
설치 과정에서 PIP하고 혼용이 안 되거나
번거로운 작업을 거쳐야만 혼용이 가능했습니다

194
00:13:47,230 --> 00:13:52,103
즉 항상 편리하고 안정적으로 동일한 패키지 설치를 보장하기 위해서는

195
00:13:52,128 --> 00:13:56,446
패키지 관리자와 가상환경이 동일해야 된다 라고 생각했습니다

196
00:13:56,470 --> 00:14:00,446
자 이러한 문제의식을 안은 채 더 나은 의존성 관리자를 찾기 위한

197
00:14:00,471 --> 00:14:02,806
저의 어떤 여정이 시작되었습니다

198
00:14:02,830 --> 00:14:05,392
이제부터 하나씩 분석하고 또 살펴볼 대상은

199
00:14:05,417 --> 00:14:09,040
pip-tools, pip env, Poetry 이 3개입니다

200
00:14:09,460 --> 00:14:13,306
이 pip-tools는 pip-compile과
pip-sync로 구성된 툴입니다

201
00:14:13,330 --> 00:14:17,762
이 pip-compile은 "setup.py" 또는 "requirements.in"들의 재료를 가지고

202
00:14:17,794 --> 00:14:21,024
"requirements.txt" 만들어내는 역할을 하고요

203
00:14:21,340 --> 00:14:24,738
그리고 pip-sync는 이렇게 만들어진 "requirements.txt"를

204
00:14:24,763 --> 00:14:27,766
프로젝트에 직접 설치하고 반영해주는 역할을 합니다

205
00:14:28,420 --> 00:14:31,504
이 그림을 보시면 조금 더 명확하게 이해가 되실 텐데요

206
00:14:31,529 --> 00:14:35,511
requirements.in 혹은
개발용 dev-requirements.in을

207
00:14:35,536 --> 00:14:40,261
pip-compile로 이런 파일들을 만들어
내면 이를 토대로 pip-sync 통해서

208
00:14:40,286 --> 00:14:44,956
프로젝트에 반영하는 과정으로 의존성 관리가 이루어진다 라고 보시면 됩니다

209
00:14:44,980 --> 00:14:50,595
즉 여기서는 "requirements.txt"
또는 개발용 "dev-requirements.txt"가

210
00:14:50,620 --> 00:14:54,406
아까 보여드렸던 NPM의 "package-lock.json"처럼

211
00:14:54,430 --> 00:14:58,149
락파일의 역할을 수행한다 라고도 볼 수 있겠죠. 그렇죠

212
00:14:58,360 --> 00:15:02,180
그리고 NPM을 쓸 때 그랬듯이 이 두 개를 git에다가

213
00:15:02,205 --> 00:15:07,610
같은 버전 컨트롤 시스템에 올려두면 항상
동일한 패키지 설치가 어느 정도는 보장이 될 겁니다

214
00:15:08,017 --> 00:15:10,968
실제 유스케이스를 좀 보여드리자면 다음과 같이

215
00:15:10,993 --> 00:15:14,746
"requirements.in"에다가 "djangorestframework"라고

216
00:15:14,770 --> 00:15:17,266
우리가 사용할 패키지들의 이름을 적어둔 다음에

217
00:15:17,290 --> 00:15:23,685
"pip-compile" 명령어를 치게 되면 "requirements.txt"
파일이 자동으로 뿅하고 생길 것이고

218
00:15:23,710 --> 00:15:28,636
이 안에 "pip-compile" 명령어를 치는 순간에 Django REST Framework 패키지와 버전

219
00:15:28,660 --> 00:15:32,532
그리고 의존성 패키지들에 대한 정보가 자동으로 담기게 될 겁니다

220
00:15:32,920 --> 00:15:38,029
그리고 자세히 보시면 주석으로 이 패키지가 어디 패키지에 의존된 패키지인지

221
00:15:38,054 --> 00:15:41,125
자동으로 써준다 라고 하는 정도 확인할 수 있을 겁니다

222
00:15:41,590 --> 00:15:45,126
참고로 "pip-compile" 명령어를 치실 때 특정 옵션을 주시게 되면

223
00:15:45,151 --> 00:15:49,845
"requirements.txt" 안에 NPM의 "package-lock.json"이 그러했듯이

224
00:15:49,870 --> 00:15:52,133
이렇게 해시값을 생성해주기도 합니다

225
00:15:52,750 --> 00:15:56,890
그리고 "pip-tools"를 이용한다면 특정 패키지의 버전을 업그레이드를 할 때

226
00:15:56,915 --> 00:15:59,532
버전을 지정해주기가 매우 매우 쉬워집니다

227
00:15:59,921 --> 00:16:02,561
전체 패키지를 업그레이드하고 싶을 때는 이렇게

228
00:16:02,586 --> 00:16:10,845
그리고 Django를 최신으로 Requests는
2.0.0 으로 업그레이드하고 싶을때는 이렇게

229
00:16:10,870 --> 00:16:15,335
그리고 Django는 2점대 이하 버전으로 업그레이드한 값의 락파일을

230
00:16:15,360 --> 00:16:18,735
"requirements-django1x.txt" 하는 이름의

231
00:16:18,760 --> 00:16:22,188
파일에 담고 싶으면 이렇게 써주시면 됩니다

232
00:16:22,991 --> 00:16:26,653
PIP를 이용했더라면 이러한 상황에서 명령어를 여러 번 치거나

233
00:16:26,678 --> 00:16:30,696
"requirements.txt" 직접 수동으로
건드려주어야 했을 겁니다. 그렇죠

234
00:16:31,648 --> 00:16:34,411
그리고 이렇게 생성된 "requirements.txt" 는

235
00:16:34,435 --> 00:16:38,532
이렇게 "pip-sync"를 통해서 실제 프로젝트에 반영할 수가 있습니다

236
00:16:39,070 --> 00:16:41,943
특정 락파일을 프로젝트에 반영하고 싶을 때는

237
00:16:41,968 --> 00:16:46,538
즉 이 경우에는 "requirements-django1x"

238
00:16:46,563 --> 00:16:52,211
아까 전에 그 락 파일을 프로젝트에 반영하고 싶으시다면

239
00:16:52,236 --> 00:16:55,220
이렇게 파일명만 적어주시면 보이시는 것처럼

240
00:16:55,245 --> 00:16:59,446
특정 락파일이 프로젝트에 잘 반영이 된 겁니다

241
00:16:59,980 --> 00:17:05,798
이 "pip-tools"가 기존이 PIP를 이용한 패키지
관리 문제 해결에서 가지는 좀 가장 큰 의의는

242
00:17:05,823 --> 00:17:10,006
이 락파일을 담당하는 "requirements.txt"를
자동으로 얻을 수 있다는 겁니다

243
00:17:10,030 --> 00:17:13,342
그렇기 때문에 당연히 개발환경을 재구성하고 또 재현하는데

244
00:17:13,367 --> 00:17:16,545
정말 용이해진 점도 있고 정말 편리해진 부분도 있고요

245
00:17:16,569 --> 00:17:20,694
그리고 아까 전에 말씀드렸던 것처럼 뭐 설치를 하거나 또 업그레이드를 할 때

246
00:17:20,719 --> 00:17:23,485
특정 패키지의 버전지정이 정말 편리해졌습니다

247
00:17:23,510 --> 00:17:27,953
그리고 requirements에서 자동으로 생성되는 주석 덕분에

248
00:17:27,978 --> 00:17:33,094
requirements에서 자동으로 생성되는 주석에 의존성 정보가 쓰이기 때문에

249
00:17:33,339 --> 00:17:37,891
패키지 의존성 트레킹이 어느 정도는 가능해졌습니다

250
00:17:38,530 --> 00:17:41,960
자 근데 사실 여기서 만족해서도 됐었는데 그리고 저는 아직까지도

251
00:17:41,985 --> 00:17:45,856
만약에 누군가가 저한테 "최대한 가볍고 단순하게 파이썬 패키지

252
00:17:45,880 --> 00:17:49,965
의존성 관리하는 방법이 뭐예요?"라고 만약에 누군가 저한테 물어보신다면

253
00:17:49,990 --> 00:17:52,857
"pip-tools요" 라고 답할 의사도 분명히 있는데

254
00:17:52,882 --> 00:17:58,096
개인적으로는 조금 제 개인적인 니즈하고는 좀 안 맞는 지점들이 있더라고요

255
00:17:58,120 --> 00:18:01,298
일단이 "pip-tools"는 패키지 설치기능 자체는 없습니다

256
00:18:01,323 --> 00:18:04,391
그렇기 때문에 PIP는 당연히 좀 끼워야 하고요

257
00:18:05,268 --> 00:18:07,947
그리고 여전히 패키지 관리자와 가환경은 따로 놀기 때문에

258
00:18:07,972 --> 00:18:11,321
패키지 관리자와 더불어서 가상환경도 따로 하나 끼워야 합니다

259
00:18:11,346 --> 00:18:14,228
그리고 만약에 파이썬 버전별 매니지먼트가 필요하시다면

260
00:18:14,253 --> 00:18:16,756
pyvenv도 당연히 기셔야겠죠. 그렇죠

261
00:18:16,780 --> 00:18:21,586
그리고 무엇보다도 이게 의존관계가 한눈에 잘 안 들어옵니다

262
00:18:21,610 --> 00:18:25,289
이 주석으로 써준다고는 하는데 이게 프로젝트가 커지고

263
00:18:25,314 --> 00:18:28,996
또 패키지가 많아지니까 가독성이 영 좋지는 않더라고요

264
00:18:29,020 --> 00:18:33,466
이 pip-tools도 이거를 의식하고 있는지 pip-tools 공식저장소에 가보면

265
00:18:33,490 --> 00:18:38,536
의존성 그래프의 가독성을 높일거면 pipdeptree라고 하는 패키지가 있어요

266
00:18:38,560 --> 00:18:41,657
'이거 깔아서 쓰세요'라고 안내하고 있기도 하고요

267
00:18:42,280 --> 00:18:47,045
그러니까 pip-tools가 너무너무 좋긴 한데 이게 의존성 관리 이외에는

268
00:18:47,070 --> 00:18:50,547
아무것도 안 해준다라고 하는 느낌은 조금 있었더라고요

269
00:18:50,770 --> 00:18:56,965
그래서 개인적으로는 당시에 저는 패키지와
관련된 모든 것들을 다알아서 해줄 수 있는 툴

270
00:18:56,990 --> 00:19:00,875
즉 올인원을 해줄 수 있는 패키지 관리자를 좀 원했었습니다

271
00:19:01,630 --> 00:19:07,063
그래서 다음으로 알아봤던 대안이
뭐였냐면 이 pipenv, PIP 인바이러먼트였습니다

272
00:19:07,570 --> 00:19:11,999
이 pipenv 동작과정은 pipenv를 처음 사용했을 때

273
00:19:12,024 --> 00:19:15,736
즉 콘솔 화면에서 찍히는 정보들을 읽어보면 좀 이해가 잘 갑니다

274
00:19:15,760 --> 00:19:19,275
이 pipenv가 워낙에 친절하게 프린트를 잘 찍어줘가지고

275
00:19:19,300 --> 00:19:24,508
이것만 잘 읽어도 어떻게 동작하는지
어느 정도 이해하시는데 도움이 많이 될 거예요

276
00:19:25,510 --> 00:19:28,845
예를 들어서 pipenv라고 하는 프로젝트 폴더를 하나 만들고

277
00:19:28,870 --> 00:19:33,805
그 안에서 pipenv를 이용한 패키지 관리를 진행한다 라고 가정해보죠

278
00:19:34,501 --> 00:19:39,636
제가 지금 빨간색으로 친 "pipenv install"이라고 하는 명령어는

279
00:19:39,661 --> 00:19:44,190
'의존성 파일들에 적힌 내용대로 패키지를 설치해라' 라고 하는 명령어인데

280
00:19:44,215 --> 00:19:47,835
만약에 프로젝트에서 처음으로 이 명령어지게 되면

281
00:19:47,860 --> 00:19:52,516
즉 한번도 이 명령어를 쳐본 적이 없는 상황에서
처음으로 이 명령어를 치시게 되면은

282
00:19:52,540 --> 00:19:56,665
제가 지금 빨간색 하이라이트를 친 걸 보시면 아실 수 있듯이

283
00:19:56,690 --> 00:20:00,211
가상환경이 특정 경로에 생성이 됩니다

284
00:20:00,580 --> 00:20:04,306
프로젝트마다 각기 다른 가상환경을 pipenv가 만들어주는데

285
00:20:04,330 --> 00:20:09,046
맨 아래 줄을 보시면 아시다시피
"pipenv shell"이라고 하는 명령어를 통해서

286
00:20:09,070 --> 00:20:13,438
지금 이 처음으로 만들어진 각기 다른 가상환경을 실행해 볼 수도 있습니다

287
00:20:13,720 --> 00:20:19,036
그리고 만약에 프로젝트 초기에 처음으로 "pipenv install" 명령어를 치게 되면

288
00:20:19,060 --> 00:20:22,186
보시는 것처럼 가상환경뿐만 아니라 이 Pipfile

289
00:20:22,210 --> 00:20:27,591
그리고 Pipfile.lock 즉 락파일도 덩달아서 생성되게 됩니다

290
00:20:27,616 --> 00:20:33,645
이 Pipfile은 Pipfile과 Pipfile.lock으로 자체적으로 생성한 가상환경 하에서

291
00:20:33,670 --> 00:20:37,306
패키지 의존성 관리를 진행한다 라고 보시면 됩니다

292
00:20:37,330 --> 00:20:42,465
짐작하시겠지만 이 "Pipfile"과 "Pipfile.lock"은 아까 전에 제가 초기에 보였던

293
00:20:42,490 --> 00:20:48,563
NPM의 "package.json", "package-lock.json"의 역할을 수행한다 라고보시면 됩니다

294
00:20:49,210 --> 00:20:53,086
이 pipenv는 패키지 설치기능도 갖고 있는데요

295
00:20:53,110 --> 00:20:56,459
pipenv Django를 이런 식으로 설치할 수도 있습니다

296
00:20:56,484 --> 00:21:01,449
이 Django를 설치하게 되면 NPM이 그러했듯이
이 락파일이 자동으로 업데이트가 될 겁니다

297
00:21:01,474 --> 00:21:06,346
제가 지금 빨간색으로 하이라이트 친
부분에 부분이 그 부분에 해당하는 부분이에요

298
00:21:06,370 --> 00:21:09,046
그리고 개발용 패키지도 쉽게 설치할 수가 있습니다

299
00:21:09,070 --> 00:21:15,046
"pipenv install"에 "--dev" 옵션을 주게 되면
개발용 패키지도 덩달아서 설치를 할 수가 있는데

300
00:21:15,070 --> 00:21:21,047
이 경우에 락파일에는 "dev-packages"라고 하는
어떤 독립된 패키지 리스트들을 락킹하게 됩니다

301
00:21:23,290 --> 00:21:26,725
그리고 배포용 패키지와 개발용 패키지를 각각 설치했을 때

302
00:21:26,750 --> 00:21:29,062
Pipfile에도 이렇게 "dev-packages"

303
00:21:29,087 --> 00:21:33,421
그리고 "packages"가 나뉘어서 명시된다 라고하는 것도 알 수 있습니다

304
00:21:33,850 --> 00:21:37,396
그리고 개인적으로 정말 좋았던 거는 드디어 패키지에 의존관계를

305
00:21:37,421 --> 00:21:40,576
한눈에 볼 수 있는 그래프가 제공되었다는 점입니다

306
00:21:40,600 --> 00:21:45,496
보시면 아시겠지만 이 Django라는 패키지에는 이러한 패키지들이 종속되어 있고

307
00:21:45,521 --> 00:21:49,716
몇 버전들이 필요하며 현재 설치된 버젼은 몇 버전인지 까지가

308
00:21:49,741 --> 00:21:53,781
한눈에 볼 수 있을 정도로 이렇게 명시가 된다 라고 하는 것을 알 수가 있죠

309
00:21:54,460 --> 00:22:00,038
이런 기본적인 기능들 이외에도 "pipenv run python" 명령어를 이용해서

310
00:22:00,063 --> 00:22:03,068
파이썬의 모듈을 직접 실행시켜볼 수도 있습니다

311
00:22:03,093 --> 00:22:07,475
예컨대 Django로 웹서버를 구동하려면
"pipenv run python manage.py runserver"

312
00:22:07,500 --> 00:22:11,146
로 실행시킬 수 있겠죠. 그렇죠

313
00:22:11,170 --> 00:22:14,285
그리고 여러 락파일을 업데이트할 수 있는 락 명령어도 있고요

314
00:22:14,310 --> 00:22:17,091
그리고 여러 파이썬이 만약에 이미 설치되어 있거나

315
00:22:17,116 --> 00:22:20,326
혹은 pyvenv가 이미 사용 중이라면

316
00:22:20,350 --> 00:22:25,507
여러 프로젝트 환경에서 사용할 수 있는 특정
버전의 파이썬을 이렇게 지정할 수도 있습니다

317
00:22:26,680 --> 00:22:29,694
지금까지 말씀을 들어보셨다면 분명히 공감하시겠지만

318
00:22:29,719 --> 00:22:33,679
이 pipenv는 분명히 기존의 PIP가 가지고 있는

319
00:22:33,704 --> 00:22:36,976
제가 문제제기했었던 문제점들을 해결해 주었습니다

320
00:22:37,000 --> 00:22:43,842
일단 이 락파일이 생겼기 때문에 Pipfile과 Pipfile.lock

321
00:22:43,867 --> 00:22:47,326
이두개의 파일을 버전 관리 시스템에 올리기만 한다면

322
00:22:47,351 --> 00:22:51,916
누가 어디서 클론을 받든지 패키지 의존성이 어느 정도 보장된 상태에서

323
00:22:51,940 --> 00:22:53,862
설치를 제대로 할 수가 있을 겁니다

324
00:22:53,887 --> 00:22:55,426
사용할 수가 있을 겁니다

325
00:22:55,450 --> 00:23:00,766
그리고 pip-tools와는 다르게 패키지의 설치와 관리, 가상환경 생성까지

326
00:23:00,790 --> 00:23:06,133
모두 한 번의 수행해준다는 점에서 기존의 문제점을 해결함과 동시에

327
00:23:06,158 --> 00:23:07,726
편의성도 제공해 주었다 라고 한다는 점을 알 수가 있고요

328
00:23:07,750 --> 00:23:12,664
그리고 아까 보여드렸듯이 프로젝트마다 파이썬의 버전을 지정하는 것도 쉬워졌고요

329
00:23:12,689 --> 00:23:17,596
개발용, 배포용 패키지를 나누어서 설치하고 관리하기가 조금 더 수월해졌습니다

330
00:23:17,620 --> 00:23:22,066
그런데 이 pipenv도 여러 소프트웨어가 그렇듯이 완벽하지는 않아서

331
00:23:22,090 --> 00:23:24,942
뭐 이런 저런 논란 그리고 비판점들로 인해서

332
00:23:24,967 --> 00:23:29,093
완벽하게 신뢰하기는 좀 어렵지 않나 라고 하는 목소리들도 있었습니다

333
00:23:29,470 --> 00:23:32,343
뭐 대표적인 예로 너무 늦은 릴리스 주기가 있었죠

334
00:23:32,368 --> 00:23:37,636
올해 릴리즈가 나오기는 했는데
디펜던시 레졸루션 이슈가 꾸준히 있었음에도 불구하고

335
00:23:37,660 --> 00:23:41,446
2018년부터 올해까지 새릴리즈가 하나도 없었습니다

336
00:23:41,470 --> 00:23:47,289
그래서 이용자 입장에서는 이게 프로젝트가 제대로
메인테인이 되는 거 맞나라고 하는 의구심도 들었던 거죠

337
00:23:48,340 --> 00:23:52,546
그리고 이거는 조금 이따가 성능 분석 때 다시 한 번 말씀드릴 예정인데요

338
00:23:52,570 --> 00:23:55,644
운영체제별로도 조금의 퍼포먼스 차이가 있긴 합니다

339
00:23:55,669 --> 00:24:00,286
아예 이제 pipenv 공식저장소에 가보면 뭐 윈도우가 우리한테는

340
00:24:00,310 --> 00:24:04,216
퍼스트클래스 시리즈입니다라고 명확히 적어되기도 했더라고요

341
00:24:04,240 --> 00:24:10,485
이런 어떤 시원섭섭한 상황에서 최근에
pipenv의 새로운 경쟁자가 등장했습니다

342
00:24:10,510 --> 00:24:14,686
바로 Poetry이라고 하는 만들어진지 얼마 되지 않은 패키지 관리자인데요

343
00:24:14,710 --> 00:24:18,161
기능성으로만 놓고 봤을 때 기능성으로만 놓고 봤을 때는

344
00:24:18,186 --> 00:24:21,154
아까 전에 언급해드렸던 pipenv 기능성,

345
00:24:21,179 --> 00:24:24,914
플러스 알파를 제공하는 패키지 관리자라고 보시면 됩니다

346
00:24:25,720 --> 00:24:29,445
Poetry이 기본적인 유스케이스도 빠르게 소개해 드리도록 할게요

347
00:24:29,590 --> 00:24:35,056
사용하는 주요 기능 자체는 pipenv랑
비슷하기 때문에 좀 빠르게 살펴보고 넘어가자면

348
00:24:35,080 --> 00:24:38,322
처음 프로젝트 환경에서 "poetry init"을 입력하게 되면

349
00:24:38,347 --> 00:24:42,826
이 pipenv에서 Pipfile이라고 하는 의존성 관리 문서가 생성이 되었듯이

350
00:24:42,850 --> 00:24:47,536
Poetry는 "pyproject.toml"이라고
하는 의존성 관리문서가 생성이 됩니다

351
00:24:47,560 --> 00:24:51,616
이 "pyproject.toml"에 담기는 내용은 제가 하이라이트 친 부분에 해당하고요

352
00:24:51,640 --> 00:24:55,255
그리고 Pipfile과 비슷하게 "poetry install" 명령어를 치게 되면

353
00:24:55,280 --> 00:24:59,247
가상환경과 더불어서 "poetry.lock"파일이 만들어지게 됩니다

354
00:24:59,272 --> 00:25:02,359
pipenv랑 사용하는 게 좀 유사하죠

355
00:25:03,220 --> 00:25:06,376
그리고 그렇게 만들어진 가상환경을 실행시키는 명령어

356
00:25:06,401 --> 00:25:09,953
즉 액티베이트 시키는 명령어는 "poetry shell"입니다

357
00:25:10,358 --> 00:25:15,466
개인적으로는 pipenv의 가상환경의 프롬프트가 뭐 저만 그런 건지 모르겠는데

358
00:25:15,490 --> 00:25:18,919
가상환경을 켰을 때 껏을 때 서로 큰 차이가 없어서

359
00:25:18,944 --> 00:25:23,056
좀 액티베이트가 된 건지 안 된 건지 좀 헷갈리는 경우가 많았었는데

360
00:25:23,080 --> 00:25:28,816
이 Poetry 가상환경을 액티베이트를 하면 지금 보시는
것처럼 프롬프트부터 달라져서 좀 되게 편하더라구요

361
00:25:28,840 --> 00:25:32,562
뭔가 딱 새로운 환경에 들어왔다 라고 하는 느낌도 들기도 하고요

362
00:25:34,390 --> 00:25:38,436
그리고 Poetry 도 pipenv와 마찬가지로 패키지를 설치할 수 있는

363
00:25:38,461 --> 00:25:41,003
어떤 패키지 관리자 기능도 수행을 하는데요

364
00:25:41,028 --> 00:25:45,093
예를 들어서 배포용으로 Django를 설치하는 명령어는 다음과 같습니다

365
00:25:45,370 --> 00:25:49,929
뭐 이렇게 Django를 추가하게 되면 당연히 락파일도 덩달아서 업데이트가 될 겁니다

366
00:25:50,510 --> 00:25:54,672
그리고 이제는 어쩌면 당연하게도 개발용 패키지를 구분해서 설치할 수도 있습니다

367
00:25:54,697 --> 00:25:58,322
지금 보시는 것처럼 "--dev" 옵션으로 패키지를 추가하시게 되면은

368
00:25:58,347 --> 00:26:01,781
배포하고는 무관한 개발용 패키지가 잘 설치가 될 거예요

369
00:26:02,680 --> 00:26:06,886
그리고 여기서부터 Poetry 플러스 알파에 해당하는 기능들인데요

370
00:26:06,910 --> 00:26:09,792
물론 다양한 기능들을 제공하지만
개인적으로 생각했을 때

371
00:26:09,817 --> 00:26:14,416
개발을 할 때 있어서 가장 고맙고 또 유용했던 기능들을 꼽아봤습니다

372
00:26:14,440 --> 00:26:16,846
일단 처음으로 패키지 서치기능인데요

373
00:26:16,870 --> 00:26:19,690
이건 흥미롭게도 pip는 제공을 하지만

374
00:26:19,715 --> 00:26:23,416
pipenv나 pip-tools는 제공하지 않는 기능입니다

375
00:26:23,440 --> 00:26:28,080
예를 들어서 "poetry search keras" 이렇게 패키지를 검색하게 되면

376
00:26:28,105 --> 00:26:30,226
거기에 매칭되는 패키지와 버전

377
00:26:30,250 --> 00:26:33,898
그리고 간략한 설명까지 프린트되는 걸 확인할 수가 있습니다

378
00:26:34,180 --> 00:26:39,826
개인적으로 첨언을 드리자면 이러한 기능들이
실제 프로젝트에서 더 특별히 유용하게 쓰이는 이유는

379
00:26:39,850 --> 00:26:46,185
제가 발표 제목에도 써드렸다시피 바야흐로
파이썬 대 패키지의 시대이기 때문입니다

380
00:26:46,210 --> 00:26:49,816
우리들이 필요한 패키지들을 모두 이름을 외우고 다닐 수는 없을 거예요

381
00:26:49,840 --> 00:26:54,859
그리고 극히 일부의 패키지들을 쓰고 싶을
때 굳이 그거를 포함하고 있는 패키지까지

382
00:26:55,060 --> 00:26:57,466
저 넓은 패키지까지 받은 필요도 없을 거고요

383
00:26:57,490 --> 00:27:01,941
결국에 이렇게 패키지를 서치하고 조회하는 기능이 있어야지

384
00:27:01,966 --> 00:27:07,305
우리들은 적재적소에 또 가볍게 원하는
패키지들을 받을 수 있다 라고 생각했기 때문에

385
00:27:07,330 --> 00:27:11,406
이 "poetry search"라고 하는 기능이 저는
조금 더 고맙게 다가왔던 것 같습니다

386
00:27:12,160 --> 00:27:18,466
그리고 개인적으로 좋았던 것 중에 하나는
Poetry의 어떤 친절한 인터페이스 입니다

387
00:27:18,490 --> 00:27:23,416
뭐 예를 들어서 "poetry show" 혹은 "show --tree" 옵션으로 패키지로 조회하게 되면요

388
00:27:23,440 --> 00:27:29,165
현재 프로젝트의 어떤 패키지가 어떤 버전으로 있고
심지어는 이 패키지가 어떤 기능을 하는지

389
00:27:29,190 --> 00:27:32,386
종속관계별로 색깔을 표시해서 이렇게 보여주더라고요

390
00:27:32,410 --> 00:27:34,917
개인적으로 이런 유저 친화적인 인터페이스가

391
00:27:34,942 --> 00:27:38,556
제가 딱 원했던 이상적인 패키지 매니저의 덕목 중의 하나여서

392
00:27:38,581 --> 00:27:41,686
정말 사막의 오아시스를 찾았던 기분을 느꼈습니다

393
00:27:41,710 --> 00:27:46,302
참고로 말씀드리자면요 이 PIP도 show옵션은 지원을 합니다

394
00:27:46,327 --> 00:27:51,466
현재 설치된 패키지가 패키지 중에서
이게 어떤 패키지고 어떤 버전에 설치돼 있고

395
00:27:51,490 --> 00:27:54,316
간략하게 설명은 무엇인지 그렇게 써주긴하는데

396
00:27:54,340 --> 00:27:57,447
Poetry처럼 이렇게 친절하게 써주지는 않습니다

397
00:27:57,472 --> 00:28:02,534
이밖에도 Poetry는 이 pipenv보다
훨씬 더 많은 기능들을 제공을 하는데요

398
00:28:02,559 --> 00:28:07,396
이 프로젝트에 필수적인 파일, 그리고 디렉토리 구조까지 세팅을 처음으로 세팅해주는

399
00:28:07,420 --> 00:28:10,185
킥스타터 기능이나 혹은 빌드기능

400
00:28:10,210 --> 00:28:15,435
가장 큰 차별점으로까지 인정받고 있는 배포기능, 퍼블리시 기능 등등

401
00:28:15,460 --> 00:28:17,926
정말 많은 기능들을 제공하고 있습니다

402
00:28:17,950 --> 00:28:22,058
때문에 Poetry는 이런 다채로운 기능들을
바탕으로 기존에 제가 제기했던 문제

403
00:28:22,083 --> 00:28:25,786
즉 PIP가 가지고 있는 문제들을 정말 잘 해결하고 있습니다

404
00:28:25,810 --> 00:28:28,216
이 락파일을 이용한 의존성 관리는 당연하구요

405
00:28:28,240 --> 00:28:34,006
패키지 설치, 가상환경, 의존성 관리 올인원
역할을 하는 것도 굉장히 고마운 부분이었죠

406
00:28:34,030 --> 00:28:37,349
그리고 pipenv처럼 파이썬 버전 호환이 자유롭고요

407
00:28:37,374 --> 00:28:40,147
그리고 아까 전에 말씀드렸던 것처럼 배포, 검색

408
00:28:40,172 --> 00:28:45,056
또 의존성 그래프를 비롯한 친절한 인터페이스 그리고 배포까지 등등

409
00:28:45,081 --> 00:28:48,595
Poetry는 기존에 제가 문제제기했었던 모든 문제 거기에

410
00:28:48,620 --> 00:28:53,390
플러스 알파까지도 제공해주는 정말 강력한 패키지 관리자 였던 것 같습니다

411
00:28:54,430 --> 00:28:57,076
그런데 사실 이 발표의 결론은

412
00:28:57,100 --> 00:29:01,412
원래 그래서 '여러분 그래서 파이썬에서 패키지 관리하실 때

413
00:29:01,437 --> 00:29:05,446
의존성 관리하실 때 Poetry를 쓰세요'가 원래 결론이었습니다

414
00:29:05,470 --> 00:29:09,226
왜냐하면 이 발표를 처음으로 준비했을 때가 3월 달에서 4월 달에 했는데

415
00:29:09,250 --> 00:29:12,279
저 때도 pipenv는 새 버전의 릴리스가 없었거든요

416
00:29:12,304 --> 00:29:15,646
그래서 2018년부터 지금까지 릴리스가 없으니까

417
00:29:15,670 --> 00:29:18,871
암묵적으로 메인테인이 잘 안 되는구나라고 생각해서

418
00:29:18,895 --> 00:29:22,096
원래 'Poetry 쓰세요'가 이 발표의 결론이였었는데

419
00:29:22,120 --> 00:29:26,057
올해 갑자기 pipenv에 대해서 두 개나 버전을 내더라구요

420
00:29:26,082 --> 00:29:29,416
심지어 그리고 이번 릴리스는 반응도 되게 좋았어요

421
00:29:29,440 --> 00:29:32,375
그래서 결국 결론을 조금 바꾸게 됐죠

422
00:29:33,160 --> 00:29:37,756
그래서 어떤 방면에서는 뭐가 더 나은지
그래서 어떤 니즈를 가질 경우에는

423
00:29:37,780 --> 00:29:43,726
어떤 패키지 매니저를 사용해야 되는지에 대한
답변을 드리는 걸로 결론이 바뀌었습니다

424
00:29:43,750 --> 00:29:47,881
그리고 그 결론을 도출하기 위해서 지금까지 제가 제기했던 문제들을 해결했던

425
00:29:47,906 --> 00:29:52,327
앞선 두 가지 도구 Poetry와 pipenv의 기능면, 관리면

426
00:29:52,352 --> 00:29:55,390
그리고 성능면에서 한번 비교를 해보도록 하겠습니다

427
00:29:56,650 --> 00:30:00,007
일단 다채로운 기능은 이 Poetry를 따라올 수가 없습니다

428
00:30:00,250 --> 00:30:04,170
그리고 개인적으로 Poetry의 기능성이 정말 뛰어나다라고 생각한 이유는

429
00:30:04,195 --> 00:30:09,256
'뭐 하나만 걸려라'라고 하는 식으로 하는
산발적인 기능들을 병렬적으로 추가한 게 아니라

430
00:30:09,280 --> 00:30:13,865
딱 패키지 혹은 프로젝트의 처음 탄생부터 배포까지 겪을 법한 일들을

431
00:30:13,890 --> 00:30:16,396
돕기 위한 기능들이 주를 이루기 때문이에요

432
00:30:16,421 --> 00:30:19,514
아까 전에 제가 예시로 보여드렸던 킥스타트, 검색,

433
00:30:19,539 --> 00:30:21,914
배포 같은 기능들도 같은 맥락이고요

434
00:30:22,510 --> 00:30:25,276
그런데 그래서 프로젝트의 발전 상황은 어떠냐

435
00:30:25,300 --> 00:30:28,426
버그는 얼마나 있고 얼마나 안정적으로 쓸 수가 있느냐

436
00:30:28,450 --> 00:30:32,776
얼마나 빨리 고쳐지고 있느냐 이걸 여쭤보신다면 또 상황이 다릅니다

437
00:30:32,800 --> 00:30:35,845
왜냐하면 Poetry의 버그가 정말 압도적으로 많아요

438
00:30:35,870 --> 00:30:38,118
워낙에 신생이라서 그런 것도 있는것 같고요

439
00:30:38,143 --> 00:30:41,429
역으로 기능이 워낙 많아서 그런 것도 있는 것 같습니다

440
00:30:42,100 --> 00:30:43,636
다음으로는 성능 테스트입니다

441
00:30:43,660 --> 00:30:46,936
성능 테스트와 관련해서는 또 드릴 말씀이 되게 많은데

442
00:30:46,960 --> 00:30:51,766
이번 발표에서는 시간관계상 중요한 핵심 결론만 말씀드리도록 하겠습니다

443
00:30:51,790 --> 00:30:57,826
어떤 자세한 결과나 추가적인 설명 혹은 더 많은
실험들은 우측하단 링크에다가 남겨드릴 테니까

444
00:30:57,850 --> 00:31:04,406
혹시라도 필요하시거나 관심 있는 분들은 따로
들어가서 보시면 정말 정말 감사드릴 것 같습니다

445
00:31:04,990 --> 00:31:10,096
일단 pipenv와 Poetry의 상황별 성능을 "time"을 이용해서 측정을 했는데

446
00:31:10,120 --> 00:31:13,486
기본적으로 Django, Django REST Framework를 설치하고

447
00:31:13,510 --> 00:31:17,588
개발용 패키지로 Flake, Django Debug Toolbar

448
00:31:17,613 --> 00:31:20,506
그리고 Pytest를 설치하는 과정을 측정했습니다

449
00:31:20,530 --> 00:31:23,670
그리고 이 패키지들을 인스톨하고 디펜던시를 추가하고

450
00:31:23,695 --> 00:31:27,007
락킹하고 언인스톨하는 과정도 측정했습니다

451
00:31:28,240 --> 00:31:31,418
일단 여러번의 실험을 다양한 환경에서 반복시행한 결과

452
00:31:31,443 --> 00:31:36,346
공통적으로 인스톨할 때는 pipenv가 더 높은 속도를 보였고요

453
00:31:36,370 --> 00:31:42,136
그 이외의 상황 즉 디펜던시를 추가하거나
특정 패키지를 언인스톨하거나 락킹할 때는

454
00:31:42,160 --> 00:31:45,046
큰 폭으로 Poetry의 성능이 더 우세했습니다

455
00:31:45,070 --> 00:31:48,272
그런데 이 실험을 진행할 때 제가 리눅스 환경

456
00:31:48,297 --> 00:31:53,225
즉 두 개의 리눅스 환경에서 실험을 더 진행을 해봤었거든요. 처음에

457
00:31:53,250 --> 00:31:58,241
CentOS 7.7이랑 Ubuntu 18.04 LTS에서 실험을 진행했었는데

458
00:31:58,266 --> 00:32:02,116
나중에 이 테스트를 윈도우즈에서 진행했을 때는 이 차이의 폭이

459
00:32:02,140 --> 00:32:04,216
그렇게 크지는 않았습니다

460
00:32:04,240 --> 00:32:08,116
여러번 노트북을 달리해서 실험해봐도 같은 결과가 나오는 걸 보면은

461
00:32:08,140 --> 00:32:13,966
확실히 pipenv는 윈도우즈에서 사용하기가 좀 더 적합한 툴인 것 같습니다

462
00:32:13,990 --> 00:32:19,396
그리고 운영체제에 따라서 성능이 얼마나 차이가
있는지에 대해서도 테스트를 해보고 싶었는데

463
00:32:19,420 --> 00:32:23,537
동일하거나 비슷한 성능을 갖고 있는 맥북, 리눅스, 윈도우 컴퓨터를

464
00:32:23,562 --> 00:32:26,026
다 구하는 게 아무래도 좀 어렵더라고요

465
00:32:26,050 --> 00:32:30,076
그래서 아마 컨퍼런스가 시작되고 여러분들이 이 발표를 보실 때쯤에는

466
00:32:30,100 --> 00:32:36,166
아마 해당 테스트까지 완료된 어떤 내용을
하단 링크에서 확인하실 수 있을 겁니다

467
00:32:36,190 --> 00:32:38,116
꼭 남겨 주도록 할게요

468
00:32:38,140 --> 00:32:42,706
그리고 마지막으로 pipenv가 올해 릴리즈가 있었다 라고 말씀을 드렸잖아요

469
00:32:42,730 --> 00:32:45,761
그런데 pipenv에 최신 버전으로 테스트를 해보면은

470
00:32:45,786 --> 00:32:49,456
이전 버전에 비해서 성능이 또 눈에 띄게 좋아졌더라고요

471
00:32:49,480 --> 00:32:53,146
당연한 이야기일 수는 있겠지만 버전에 따라서도 성능 개선 있었습니다

472
00:32:53,170 --> 00:32:57,196
단지 이제 pipenv의 성능 개선이, 버전에 따라 성능 개선이

473
00:32:57,220 --> 00:33:02,171
좀 더 눈에 띄게 더 많은 개선이 있었다 라는점 결론으로 말씀드리겠습니다

474
00:33:02,860 --> 00:33:06,316
자 그래서 길었던 저의 이야기의 결론은 다음과 같습니다

475
00:33:06,340 --> 00:33:11,926
만약에 이 PIP를 이용한 패킷이 관리의
문제점에 공감하고 있는 어떤 사람이 와서

476
00:33:11,950 --> 00:33:15,073
'저는 배포나 패키지 트래킹은 아직까지 큰 관심 없어요

477
00:33:15,098 --> 00:33:17,476
딱히 가상환경을 따로 쓰고 싶지도 않구요

478
00:33:17,500 --> 00:33:19,666
파이썬 버전별로 개발할 필요도 없어요

479
00:33:19,690 --> 00:33:24,796
그냥 동일한 프로젝트 환경을 재구성하는
것만 보장할 수 있으면 돼요'라고 물어보신다면

480
00:33:24,820 --> 00:33:28,029
저는 그냥 '가볍게 pip-tools 쓰시고 requirements.in

481
00:33:28,054 --> 00:33:33,828
혹은 setup.py를 requirements.txt랑
커밋해 주세요'라고만 말씀드릴 것 같습니다

482
00:33:34,690 --> 00:33:38,866
또 만약에 누군가가 '저는 패키지 디펜더시 트레킹은 정말 중요해요

483
00:33:38,890 --> 00:33:43,156
동일한 프로젝트 환경을 재생성하는 거는 당연히 당연히 중요하고요

484
00:33:43,180 --> 00:33:48,136
가상환경 필요하고, 디펜던시 리졸빙 이슈는 웬만하면 진짜 만나고 싶지는 않아요

485
00:33:48,160 --> 00:33:54,496
무난하고, 할 거다 해주는 패키지 관리자를 원해요' 라고 물어보신다면

486
00:33:54,520 --> 00:33:58,012
라는 니즈를 갖고 계신다면 저는 그래도
아직까지는 '안정적이고 버그가 비교적 적은

487
00:33:58,037 --> 00:34:03,671
그냥 좋은 게 좋은. 무난한 pipenv
도 되게 좋습니다' 라고 말씀드릴 것 같습니다

488
00:34:04,240 --> 00:34:09,226
그리고 마지막으로 누군가가 '프로젝트의
처음부터 끝까지 편리하게 케어받을 수 있는

489
00:34:09,250 --> 00:34:12,196
패키지 의존성 매니저가 있나요?'라고 물어보신다면

490
00:34:12,220 --> 00:34:15,789
저는 Poetry를 쓰시라고 말씀드릴 것 같습니다

491
00:34:16,450 --> 00:34:18,736
끝으로 저의 사견을 마지막으로 본 발표를 마치자면

492
00:34:18,760 --> 00:34:26,760
저는 진심으로 pipenv의 올해 릴리즈에 대한 감사한 마음을 갖고 있습니다만

493
00:34:26,889 --> 00:34:31,748
Poetry에 대한 지속적인 관심과 컨트리뷰션을 저와 함께 이어나가고 싶으신

494
00:34:31,773 --> 00:34:34,276
파이써니스타들이 정말 많아지신다면

495
00:34:34,300 --> 00:34:38,368
다채로운 기능성을 갖춘, 또 한편으로는 또 안정적인 패키지 관리자가

496
00:34:38,393 --> 00:34:42,992
또 하나 만들어지지 않을까? 라고 하는 어떤 행복한 상상을 해보기도 했습니다

497
00:34:43,480 --> 00:34:46,096
자 이상으로 저의 발표를 마치도록 하겠습니다

498
00:34:46,120 --> 00:34:50,656
끝까지 들어주셔서 진심으로 정말 정말 감사드립니다. 감사합니다

