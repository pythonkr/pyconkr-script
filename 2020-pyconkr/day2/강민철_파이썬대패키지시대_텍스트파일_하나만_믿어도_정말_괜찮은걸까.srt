1
00:00:10,335 --> 00:00:11,093
안녕하세요
  

2
00:00:11,118 --> 00:00:15,280
파이썬 대 패키지 시대 텍스트 파일 하나만 믿어도 정말 괜찮은 걸까
  

3
00:00:15,305 --> 00:00:17,774
발표를 맡게 된 강민철이라고 합니다
  

4
00:00:18,055 --> 00:00:23,326
이번에 저는 기존 PIP를 이용한 파이썬
패키지 관리 컨벤션이 갖고 있는 문제점과  

5
00:00:23,350 --> 00:00:28,740
그를 대체할 수 있는 다양한 패키지 의존성
관리자에 대한 소개 및 비교분석 결과를  

6
00:00:28,765 --> 00:00:30,485
발표로 준비하게 되었습니다
  

7
00:00:31,090 --> 00:00:34,516
본격적인 발표를 진행하기 앞서서 간략하게 저의 소개를 드리자면
  

8
00:00:34,540 --> 00:00:39,793
저는 현재 〈오픈소스 컨설팅〉이라고 하는
회사에서 근무하고 있는 시스템 엔지니어이자  

9
00:00:39,818 --> 00:00:42,688
온/오프라인 프로그래밍 교육을 하고 있는 강사입니다
  

10
00:00:42,940 --> 00:00:47,102
또한 제가 배울 수 있는 것들은 모두 다
배우고 싶어 하는 어떤 욕심많은 학생이기도 하고요  

11
00:00:47,127 --> 00:00:49,641
취미로 오픈소스에 컨트리뷰션을 하기도 합니다
  

12
00:00:50,260 --> 00:00:52,588
자 그러면 원활하게 발표 주제에 접근하기 위해서
  

13
00:00:52,613 --> 00:00:56,221
꼭 필요한 배경지식들을 빠르게 설명해 드리도록 하겠습니다
  

14
00:00:56,246 --> 00:00:58,980
우선 모듈, 패키지, 라이브러리가 무엇인지
  

15
00:00:59,005 --> 00:01:04,246
그리고 기존 패키지 인스톨러인 PIP에 대해서 설명해드릴 예정이고요
  

16
00:01:04,270 --> 00:01:08,235
그리고 의존성 관리란 무엇이며 또 왜 필요한지 말씀드린 뒤에
  

17
00:01:08,598 --> 00:01:13,461
파이썬과 옆 동네 자바 스크립트의 어떤 의존성 관리를 비교해보도록 하겠습니다
  

18
00:01:13,900 --> 00:01:16,666
우선 모듈은 그냥 파이썬으로 정의된 파일입니다
  

19
00:01:16,690 --> 00:01:20,336
실행 가능한 파이썬 파일을 모듈이라고 보시면 됩니다
  

20
00:01:20,830 --> 00:01:24,187
그리고 패키지는 모듈의 집합이라고 보셔도 되는데
  

21
00:01:24,218 --> 00:01:28,636
조금 더 자세하게는 파이썬코드내에서 '점 모듈 이름'으로써
  

22
00:01:28,660 --> 00:01:33,743
그 모듈 속 내용에 접근할 수 있게끔 하는 네임스페이스를 패키지라고 부릅니다
  

23
00:01:34,030 --> 00:01:40,186
이번 발표에서는 프로젝트를 이루는 단위 즉
프로젝트를 완성하기 위해 사용하는 어떤 코드뭉치  

24
00:01:40,210 --> 00:01:45,555
혹은 모듈의 집합을 통틀어서 편의상 '패키지'라고 지칭할 예정입니다
  

25
00:01:46,150 --> 00:01:51,526
그리고 마지막으로 라이브러리는 쓸만한
기능들을 미리 모듈 혹은 패키지로 만들어 놓은 것  

26
00:01:51,550 --> 00:01:55,977
즉 미리 준비된 모듈 혹은 패키지를 라이브러리라고 부릅니다
  

27
00:01:56,560 --> 00:02:01,816
파이썬이 준비해둔 라이브러리에는 '파이썬 스탠다드 라이브러리' 즉 표준 라이브러리와
  

28
00:02:01,840 --> 00:02:06,798
지금 이 순간에도 수많은 파이써니스타들이
다 배포하고 있고 또 다운로드 받을 수 있는  

29
00:02:06,823 --> 00:02:12,795
어떤 패키지 저장소인 파이썬 패키지 인덱스
PyPI가 제공하고 있는 라이브러리가 있습니다  

30
00:02:12,820 --> 00:02:19,635
이 PyPI에는 방대한 양의 패키지가 존재하고 또 실시간으로 업데이트되고 있는 만큼
  

31
00:02:19,660 --> 00:02:25,306
이 패키지들을 설치하고 삭제하고 또 현재
설치된 패키지들의 목록들을 조회하는 등  

32
00:02:25,331 --> 00:02:29,000
패키지를 관리해주는 툴도 당연히 있어야 될 겁니다
  

33
00:02:29,456 --> 00:02:36,829
파이썬에서는 바로 이 PIP라고 하는 툴이 이 파이썬의
패키지 혹은 라이브러리를 관리해준다 라고 보셔도 됩니다  

34
00:02:37,180 --> 00:02:41,746
예컨대 "pip install {패키지 이름}"이라고 하는 명령어를 이용한다면
  

35
00:02:41,770 --> 00:02:48,102
이 PIP는 PyPI에서 해당하는 패키지를 자동으로
찾아주고 다운로드 해주고 설치도 진행해줍니다  

36
00:02:48,490 --> 00:02:54,706
원하는 특정 버전의 패키지를 지정해서 설치할
수도 있고 반대로 설치된 패키지를 제거할 수도 있고요  

37
00:02:54,730 --> 00:02:58,636
뭐 이미 설치된 패키지를 최신 버전으로 업그레이드할 수도 있습니다
  

38
00:02:58,660 --> 00:03:03,736
이렇게 PIP는 패키지들을 관리하는 다양한 명령들을 제공하는데요
  

39
00:03:03,760 --> 00:03:08,649
그중에서도 이 명령어가 이번 발표를
이해하시는데 있어서 좀 중요한 역할을 합니다  

40
00:03:08,674 --> 00:03:13,006
이 "pip freeze"라고 하는 명령어는 현재 프로젝트 환경에서 설치된
  

41
00:03:13,030 --> 00:03:17,382
모든 패키지들의 이름 및 버전 정보를 출력해주는 명령입니다
  

42
00:03:17,407 --> 00:03:19,383
예를 들면 뭐 이렇게 말이죠
  

43
00:03:20,320 --> 00:03:22,413
자 그럼 의존성 관리는 무엇일까요?
  

44
00:03:22,438 --> 00:03:25,636
뭐 이미 아시는 분들은 조금만 더 기다려주시면 감사하겠습니다
  

45
00:03:25,660 --> 00:03:31,129
의존성 관리는 지금 이 프로젝트 환경에서 어떤 버전의 어떤 패키지가 쓰였나
  

46
00:03:31,154 --> 00:03:36,841
그리고 어떤 버전의 어떤 패키지가 쓰일 수 있나를 관리하는 것을 말합니다
  

47
00:03:37,090 --> 00:03:41,316
다시 말씀드려서 이제 프로젝트가 어떤 외부 라이브러리를 쓰고 있는지를
  

48
00:03:41,341 --> 00:03:44,596
따로 관리해주는 것을 의존성 관리라고 부르는데요
  

49
00:03:44,620 --> 00:03:49,307
이 의존성 관리는 어떤 프로젝트 흥망에도 직접적으로 영향을 줄 수 있을 만큼
  

50
00:03:49,332 --> 00:03:52,186
개발을 하는데 있어서 매우 매우 중요한 요소입니다
  

51
00:03:52,210 --> 00:03:55,585
그러면 정확하게 이게 왜 중요할까요?
  

52
00:03:55,639 --> 00:03:58,639
패키지를 관리하는 게, 패키지를 따로 관리하는 게
  

53
00:03:58,664 --> 00:04:02,060
왜 프로젝트의 흥망에도 영향을 줄 만큼 중요한 요소일까요?
  

54
00:04:02,085 --> 00:04:04,846
예를 들어서 제가 프로젝트를 막 만들고 있는데
  

55
00:04:04,870 --> 00:04:09,845
제 프로젝트에 꼭 필요한 패키지인 "PyconKorea"라고 하는 패키지를 설치했다
  

56
00:04:09,870 --> 00:04:11,063
라고 가정해봅시다
  

57
00:04:11,440 --> 00:04:16,736
그리고 이 "PyconKorea"라고 하는 패키지는 A, B, C라고 하는 외부 모듈
  

58
00:04:16,761 --> 00:04:18,605
혹은 패키지로 이루어져 있고
  

59
00:04:18,630 --> 00:04:22,840
A라고 하는 모듈은 A'이라고 하는 다른 외부모듈
  

60
00:04:22,865 --> 00:04:25,539
혹은 패키지가 쓰였다 라고 가정해봅시다
  

61
00:04:26,050 --> 00:04:31,245
자 이런 상황에서 제 프로젝트에는 "PyconKorea"라고 하는 패키지가 필요한데
  

62
00:04:31,269 --> 00:04:35,994
그럼 당연히 제 프로젝트를 사용한 미래의 사용자들은 그때 그때 제 프로젝트에서
  

63
00:04:36,019 --> 00:04:41,056
꼭 사용하는 "PyconKorea" 패키지를
그때그때 설치해 주는 방법도 있을 수가 있겠죠  

64
00:04:41,080 --> 00:04:42,899
설치를 해줘야겠죠, 그렇죠?
  

65
00:04:43,270 --> 00:04:48,946
그런데 이때 A' 모듈 혹은 패키지가
갑자기 버전이 바뀌었다 라고 가정해봅시다  

66
00:04:48,970 --> 00:04:53,882
이거는 A'이라고 하는 코드가 바뀌었음을 의미하겠죠. 그렇죠?
  

67
00:04:53,907 --> 00:04:59,202
그런데 A'이라고 하는 새 버전이
A한테까지 영향을 끼친다면 어떻게 될까요?  

68
00:04:59,227 --> 00:05:02,625
좀 안 좋은 사례이긴 하지만 이 A'의 패치로 인해서
  

69
00:05:02,650 --> 00:05:06,460
A도 기존 버전으로는 좀 동작이 안 되는 경우도 있을 겁니다
  

70
00:05:06,485 --> 00:05:08,704
A도 덩달아 패치가 필요해지는 거죠
  

71
00:05:09,430 --> 00:05:12,319
이렇게 되면 당연히 제 프로젝트에도 영향을 받겠죠. 그렇죠
  

72
00:05:12,344 --> 00:05:17,980
옛날 버전에 A를 상정하고 맞는 프로젝트인데
A' 때문에 A가 변해버렸으니까  

73
00:05:18,005 --> 00:05:20,065
만약에 옛날 버젼을 고려하지 않는다면
  

74
00:05:20,090 --> 00:05:24,591
버전 때문에 설치가 제대로 안 되는 이용자들도 분명히 생길 겁니다. 그렇죠
  

75
00:05:24,616 --> 00:05:26,716
그러면 아예 이런 방법은 어떨까요?
  

76
00:05:26,740 --> 00:05:32,266
제 프로젝트에 쓰는 특정 버전의 의존성 모듈 A, B, C, A' 모두 다
  

77
00:05:32,290 --> 00:05:35,516
그냥 내 프로젝트 안에다가 소스코드로 박제해버리는 거예요
  

78
00:05:35,950 --> 00:05:37,306
어떨 거 같으세요?
  

79
00:05:37,330 --> 00:05:41,117
코드가 돌아가기가 돌아가겠지만 당연히 문제가 좀 생길 수가 있겠죠
  

80
00:05:41,142 --> 00:05:45,676
애초에 프로젝트에 싣을 수 없는 코드도 있을 뿐더러 싣을 수 있다고 해도
  

81
00:05:45,700 --> 00:05:50,910
꼬리에 꼬리를 무는 어떤 패키지들의 코드
때문에 프로젝트 자체도 굉장히 무거워질 겁니다. 그렇죠?  

82
00:05:50,935 --> 00:05:56,956
또 만일에 A'이나 A의
업데이트 이유가 보안상의 취약점 때문이었다면  

83
00:05:56,981 --> 00:06:01,396
내 프로젝트는 보안에 취약한 구 버전을 사용하는 꼴이 되기도 쉽고요
  

84
00:06:01,420 --> 00:06:06,301
이렇듯 의존성 관리가 제대로 되지 않는다면 실컷 다 만들어놓은 프로젝트인데도
  

85
00:06:06,326 --> 00:06:09,091
이 광활한 우주에서 내 컴퓨터에서만 동작하는
  

86
00:06:09,116 --> 00:06:12,226
어떤 프로젝트를 만드는 대참사를 일으킬 수도 있습니다
  

87
00:06:12,250 --> 00:06:17,026
저도 개인적으로도 이런 의존성 관리가 잘 안
돼가지고 프로젝트가 여러 번 망한 적이 있습니다  

88
00:06:17,050 --> 00:06:21,586
그럼 지금까지 파이썬에서는 의존성 관리를
어떻게 해오고 있었는지를 한번 알아볼까요?  

89
00:06:21,610 --> 00:06:25,586
가장 유명하고 또 대중적인 방법은 이 명령어를 이용하는 방법입니다
  

90
00:06:25,961 --> 00:06:28,335
"pip freeze"는 아까 말씀드렸다시피
  

91
00:06:28,360 --> 00:06:34,726
"현재 내 프로젝트 환경에 설치된 모든 패키지
이름과 버전을 출력해줘"라고 하는 명령어고요  

92
00:06:34,750 --> 00:06:39,787
이 명령어의 결과를 어디에 기록하길
바랐냐면 "requirements.txt"라고 하는  

93
00:06:39,812 --> 00:06:44,485
텍스트 파일의 기록하기를 바란다라고 하는 명령어라고 보시면 됩니다
  

94
00:06:44,710 --> 00:06:47,778
즉 이 명령어를 수행하면은 지금 보시는 것처럼
  

95
00:06:47,803 --> 00:06:52,013
"pip freeze"의 결과가, "pip freeze"를 한 명령어의 결과가
  

96
00:06:52,038 --> 00:06:55,586
"requirements.txt" 파일 안에 자동으로 담기게 될 겁니다
  

97
00:06:56,260 --> 00:07:01,185
그리고 이렇게 만들어진 패키지의 버전에
대한 정보를 담은 "requirements.txt" 파일은  

98
00:07:01,210 --> 00:07:05,877
프로젝트 환경이 아닌 다른 환경 예컨대 뭐 다른 유저가 사용하는 환경에서
  

99
00:07:05,902 --> 00:07:08,086
이런 명령으로 설치할 수가 있습니다
  

100
00:07:08,350 --> 00:07:12,391
이 명령은 어떤 명령하냐면 저 패키지를 설치해 건데요
  

101
00:07:12,850 --> 00:07:16,528
이 파일의 내용에 맞게 설치할 거예요라고 하는 뜻입니다
  

102
00:07:16,553 --> 00:07:21,490
그러면 이 파일에 담긴 이름, 그리고 버전에
맞는 패키지들이 자동적으로 설치가 되겠죠. 그렇죠  

103
00:07:21,515 --> 00:07:25,302
즉 지금까지 파이썬 의존성 관리는
  

104
00:07:25,327 --> 00:07:31,425
프로젝트 수행 환경에서 사용된 패키지와
버전들을 모조리 기록한 "requirements.txt"를 만들고  

105
00:07:31,450 --> 00:07:37,133
또 다른 환경에서 그 "requirements.txt"을 갖고
그대로 설치하는 이러한 방식으로 진행되곤했습니다  

106
00:07:37,510 --> 00:07:39,946
이거는 꽤나 간편하고 또 대중적인 방법입니다
  

107
00:07:39,970 --> 00:07:46,546
제가 심심해서 발표 준비할 때 파이콘코리아 공식
홈페이지는 어떻게 의존성을 관리하는지 한번 찾아봤었는데  

108
00:07:46,570 --> 00:07:49,005
여기도 "requirements.txt"를 사용하더라고요
  

109
00:07:49,030 --> 00:07:53,600
명령어 한번으로 패키지의 이름과 버전 정보가 모조리 싹다 담기니까
  

110
00:07:53,625 --> 00:07:55,516
꽤나 간편한 방법이기도 합니다
  

111
00:07:55,865 --> 00:07:57,738
근데 제 발표 제목을 보시면 아시겠지만
  

112
00:07:57,763 --> 00:08:00,177
저는 이번에 이렇게 PIP를 이용해서
  

113
00:08:00,202 --> 00:08:02,700
모조리 패키지 관리를 하는 이러한 방식에 대해서
  

114
00:08:02,724 --> 00:08:06,034
어떤 문제점을 짚고 또 대안점을 제시할 예정입니다
  

115
00:08:06,059 --> 00:08:09,551
근데 그 전에 이 문제의식에 대해서 말씀드리기 전에요
  

116
00:08:09,576 --> 00:08:14,649
옆동네 자바스크립트에서는 어떻게 패키지 의존성을
관리하는지 잠깐 보고 오도록 할까요?  

117
00:08:15,070 --> 00:08:19,276
왜 갑자기 파이콘에서 뜬금없이 자바스크립트
말씀을 하세요라고 물어보실 수도 있겠지만  

118
00:08:19,300 --> 00:08:24,226
이 자바스크립트가 패키지 관리를 제가
개인적으로 생각했을때는 굉장히 기가 막히게 하거든요  

119
00:08:24,250 --> 00:08:29,046
참고로 NPM과 Yarn은 파이선의 PIP와 비슷한 대표적인
  

120
00:08:29,071 --> 00:08:32,610
자바스크립트의 패키지 관리자 혹은 관리툴이라고 보시면 됩니다
  

121
00:08:33,460 --> 00:08:39,202
우선 이 자바스크립트. 대표적으로 NPM은
이 세 녀석들로 패키지 의존성을 관리합니다  

122
00:08:39,428 --> 00:08:43,727
package,json  package-lock,Json  
node_modules 디렉토리  

123
00:08:44,620 --> 00:08:47,705
우선 이 "node_modules"는 이 NPM으로 다운로드한
  

124
00:08:47,730 --> 00:08:50,774
외부 라이브러리들이 담기는 폴더라고 보시면 됩니다
  

125
00:08:50,799 --> 00:08:55,477
NPM으로 외부에서부터 패키지들을 다운로드하시면 여기에 담긴다라고 보시면 돼요
  

126
00:08:55,690 --> 00:08:57,703
다음은 이 "package.json"파일입니다
  

127
00:08:57,728 --> 00:09:02,176
이 파일은 프로젝트가 시작할 때 쓰는 "npm init"을 치면 자동으로
  

128
00:09:02,200 --> 00:09:06,948
생성되는 프로젝트 정보와 의존성을 관리해주는 문서라고 보시면 됩니다
  

129
00:09:06,973 --> 00:09:11,626
잘 보시면 이 패키지의 이름, 버전, 설명, 저장소 키워드, 라이선스 등등을
  

130
00:09:11,650 --> 00:09:14,079
담고 있다 라고 하는 걸 확인할 수가 있죠
  

131
00:09:14,440 --> 00:09:20,956
주목할 점은 이 NPM은 개발용 패키지와 배포용
패키지를 따로 관리할 수 있다 라는 점입니다  

132
00:09:20,980 --> 00:09:25,996
우리 프로젝트를 생각할 때 프로젝트 자체 개발을 위해서 꼭 설치해줘야 되는
  

133
00:09:26,020 --> 00:09:29,356
배포용 패키지. 그리고 디버깅, 테스트처럼
  

134
00:09:29,380 -->   00:09:24.216
개발 과정에 편의를 위해서 설치하는 개발용 패키지는 다를 수 있지 않겠어요
  

135
00:09:24.240   -->   00:09:28.685
NPM은 이렇듯 배포용 패키지를 설치 및 관리해주는 명령어와
  

136
00:09:28.710   -->   00:09:33.274
개발용 패키지를 설치 및 관리해주는 명령어가 구분되어 있습니다
  

137
00:09:35.130   -->   00:09:37.019
다음은 "package-lock" 파일입니다
  

138
00:09:37.044   -->   00:09:40.273
언뜻 보면 좀 낯설 수도 있는 이 "package-lock" 파일도
  

139
00:09:40.298   -->   00:09:43.928
굉장히 굉장히 유용하고 필수적인 역할을 맡고 있는데요
  

140
00:09:43.953   -->   00:09:48.215
이 "package-lock"이라고 하는 파일은
"node_modules"나

141
00:09:48.240   -->   00:09:53.346
패키지 파일이 변경될 때마다 자동으로 생성되고 또 업데이트 되는 파일입니다
  

142
00:09:53.370   -->   00:09:58.323
다시 말씀드려서 node_modules 디렉토리나 패키지 타입이 변경될 때마다
  

143
00:09:58.348   -->   00:10:01.056
그 순간의 스냅샷을 저장하는 역할을 합니다
  

144
00:10:01.080   -->   00:10:05.244
즉 "node_modules"나 "package.json"의 순간을 저장해서
  

145
00:10:05.269   -->   00:10:09.415
항상 동일한 모듈 트리의 생성을 보장하는 녀석이라고 보시면 됩니다
  

146
00:10:09.440   -->   00:10:13.135
이렇게 패키지 파일에서는 해당 프로젝트에 대한 정보와
  

147
00:10:13.160   -->   00:10:17.436
설치된 패키지들의 의존성 정보들이 종류별로 담기게되고요
  

148
00:10:17.460   -->   00:10:24.013
"package-lock"파일 즉 락파일에는 패키지와 "node_modules"의 어떤 변경사항이 생길때마다
 

149
00:10:24.038   -->   00:10:28.446
"node_modules" 디렉토리의 그 순간 순간의 스냅샷을 저장하기 때문에
  

150
00:10:28.470   -->   00:10:31.880
"package"파일과 "package-lock"파일만 git에다가 올리게 되면
  

151
00:10:31.905   -->   00:10:37.305
항상 동일한 패키지트리인 "node_modules"를
만들 수 있게끔 보장할 수가 있게 되는 겁니다  

152
00:10:38.190   -->   00:10:43.626
저는 개인적으로는 이런 어떤 옆 동네
자바스크립트 패키지 의존성 관리를 보고 나니까  

153
00:10:43.650   -->   00:10:49.118
개인적으로 PIP를 이용한 기존에 requirements.txt
방식에 좀 문제의식이 느껴졌습니다  

154
00:10:49.380   -->   00:10:51.730
구체적으로 어떤 문제들이 있을 수 있을까요?
  

155
00:10:51.755   -->   00:10:53.766
저는 다음과 같이 꼽았습니다
  

156
00:10:53.790   -->   00:10:56.799
이원화되어 있지 않은 개발용 패키지, 배포용 패키지
  

157
00:10:56.824   -->   00:11:00.589
의존관계 파악의 어려움. 특정 패키지 버전지정의 어려움
  

158
00:11:00.614   -->   00:11:03.039
그리고 설치시 발생할 수 있는 문제
  

159
00:11:03.064   -->   00:11:07.596
일단 개발용 패키지, 배포용 패키지가
이원화되어 있지 않아서 생기는 문제들이 있습니다  

160
00:11:07.620   -->   00:11:10.806
아까 전에 제가 NPM의 "package.json"에서 보여드렸듯이
  

161
00:11:10.830   -->   00:11:14.845
개발을 할 때 있어서는, 개발할 때 있어서 사용하는 패키지는
  

162
00:11:14.870   -->   00:11:19.056
으레 개발용 패키지와 배포용 패키지가 구분되기 마련이잖아요. 그렇죠
  

163
00:11:19.080   -->   00:11:23.586
만약에 개발용 패키지가 배포용 패키지의 일부라고 가정을 한다면
  

164
00:11:23.611   -->   00:11:27.304
배포용 패키지를 이 명령어를 이용해서 한 번에 만든다고 쳐도
  

165
00:11:27.329   -->   00:11:32.047
나머지 개발용 패키지들은 직접 손으로
써가면서 기록해야 된다는 불편함이 있습니다  

166
00:11:32.520   -->   00:11:35.863
또 만약에 개발용 패키지들의 종류 및 버전이
  

167
00:11:35.888   -->   00:11:38.924
배포용 패키지들을 완전히 포함하고 있지는 않을 때
  

168
00:11:38.949   -->   00:11:42.261
즉 배포용 패키지로는 사용하지 않을 패키지가
  

169
00:11:42.286   -->   00:11:45.876
개발용 패키지에 포함되어 있다면 더욱 관리가 귀찮아지더라구요
  

170
00:11:45.900   -->   00:11:50.446
이때는 다음과 같이 특정 디렉토리 하에 파일을 이렇게 구분을 해놓으면
  

171
00:11:50.471   -->   00:11:54.186
배포용, 개발용 패키지가 한방에 설치가 되겠지만
  

172
00:11:54.210   -->   00:11:59.613
이때는 개발용 패키지 의존성 관리문서와 배포용 패키지 의존성 관리문서를
  

173
00:11:59.638   -->   00:12:03.125
모두 돈으로 써가면서 관리해야 되는 번거로움이 좀 있었습니다
  

174
00:12:03.510   -->   00:12:08.905
PIP을 이용한 패키지 관리의 두 번째
문제는 의존관계 파악이 어렵다는 데 있습니다  

175
00:12:08.945   -->   00:12:14.459
일예로 "Keras"를 PIP로 설치한 뒤에
"pip freeze"를 하면은 다음과 같이 보이고요  

176
00:12:14.484   -->   00:12:19.206
Django REST Framework를 설치하고
"pip freeze"를 하면은 다음과 같이 보이게 됩니다  

177
00:12:19.230   -->   00:12:24.589
어떤 패키지가 어떤 패키지에 의존적인 지 각자의 패키지는 무슨 관계이며
  

178
00:12:24.614   -->   00:12:28.656
또 어떤 역할을 하는지 딱 보면은 감이 잘 안 오시죠. 그렇죠
  

179
00:12:28.680   -->   00:12:32.515
더군다나 "pip uninstall"을 통해서 특정 패키지를 삭제해도
  

180
00:12:32.540   -->   00:12:37.296
이런 의존성 패키지까지는 리커시브하게 삭제가 되지 않기 때문에
  

181
00:12:37.320   -->   00:12:42.563
프로젝트가 진행되면 진행될수록 어떤 패키지에
의존관계 파악이 더욱더 어려워질 겁니다  

182
00:12:43.380   -->   00:12:46.656
마지막으로 설치할 때 어떤 생길 수 있는 문제점도 있습니다
  

183
00:12:46.680   -->   00:12:52.116
즉 "pip install -r requirements.txt" 명령어가 문제를 일으킬 수도 있습니다
  

184
00:12:52.140   -->   00:12:55.405
가상환경만 사용하지 않고 생으로 설치하게 될 경우
  

185
00:12:55.430   -->   00:12:59.496
만약에 설치 환경에서 이미 설치한 패키지와 상충되는 경우에는
  

186
00:12:59.520   -->   00:13:03.696
당연히 기존의 어떤 환경에 영향을 끼칠 것이고
  

187
00:13:03.720   -->   00:13:09.276
애초에 특정 패키지 설치가 안 되는 환경일
경우에는 프로젝트 전체가 설치되지를 않겠죠  

188
00:13:09.300   -->   00:13:13.716
그래서 대부분 가상환경을 켜둔 채 "pip install"을 진행하게 될 겁니다
  

189
00:13:13.740   -->   00:13:18.936
그런데 이럴 경우에는 어떤 통일되지 않은 패키지 관리자와 가상환경 때문에
  

190
00:13:18.960   -->   00:13:22.476
바로 바로 설치가 안 되는 경우도 간혹 있더라고요
  

191
00:13:22.500   -->   00:13:25.857
예컨대 Anaconda에서 지원하는 "conda" 패키지 관리자와
  

192
00:13:25.882   -->   00:13:30.845
"conda env"는 "requirements.txt"를
내보내고 또 설치할 수는 있지만  

193
00:13:30.870   -->   00:13:36.985
설치 과정에서 PIP하고 혼용이 안 되거나
번거로운 작업을 거쳐야만 혼용이 가능했습니다  

194
00:13:37.230   -->   00:13:42.103
즉 항상 편리하고 안정적으로 동일한 패키지 설치를 보장하기 위해서는
  

195
00:13:42.128   -->   00:13:46.446
패키지 관리자와 가상환경이 동일해야 된다 라고 생각했습니다
  

196
00:13:46.470   -->   00:13:50.446
자 이러한 문제의식을 안은 채 더 나은 의존성 관리자를 찾기 위한
  

197
00:13:50.471   -->   00:13:52.806
저의 어떤 여정이 시작되었습니다
  

198
00:13:52.830   -->   00:13:55.392
이제부터 하나씩 분석하고 또 살펴볼 대상은
  

199
00:13:55.417   -->   00:13:59.040
pip-tools, pip env, Poetry 이 3개입니다
  

200
00:13:59.460   -->   00:14:03.306
이 pip-tools는 pip-compile과
pip-sync로 구성된 툴입니다  

201
00:14:03.330   -->   00:14:07.762
이 pip-compile은 "setup.py" 또는 "requirements.in"들의 재료를 가지고
  

202
00:14:07.794   -->   00:14:11.024
"requirements.txt" 만들어내는 역할을 하고요
  

203
00:14:11.340   -->   00:14:14.738
그리고 pip-sync는 이렇게 만들어진 "requirements.txt"를
  

204
00:14:14.763   -->   00:14:17.766
프로젝트에 직접 설치하고 반영해주는 역할을 합니다
  

205
00:14:18.420   -->   00:14:21.504
이 그림을 보시면 조금 더 명확하게 이해가 되실 텐데요
  

206
00:14:21.529   -->   00:14:25.511
requirements.in 혹은
개발용 dev-requirements.in을  

207
00:14:25.536   -->   00:14:30.261
pip-compile로 이런 파일들을 만들어
내면 이를 토대로 pip-sync 통해서  

208
00:14:30.286   -->   00:14:34.956
프로젝트에 반영하는 과정으로 의존성 관리가 이루어진다 라고 보시면 됩니다
  

209
00:14:34.980   -->   00:14:40.595
즉 여기서는 "requirements.txt"
또는 개발용 "dev-requirements.txt"가  

210
00:14:40.620   -->   00:14:44.406
아까 보여드렸던 NPM의 "package-lock.json"처럼
  

211
00:14:44.430   -->   00:14:48.149
락파일의 역할을 수행한다 라고도 볼 수 있겠죠. 그렇죠
  

212
00:14:48.360   -->   00:14:52.180
그리고 NPM을 쓸 때 그랬듯이 이 두 개를 git에다가
  

213
00:14:52.205   -->   00:14:57.610
같은 버전 컨트롤 시스템에 올려두면 항상
동일한 패키지 설치가 어느 정도는 보장이 될 겁니다  

214
00:14:58.017   -->   00:15:00.968
실제 유스케이스를 좀 보여드리자면 다음과 같이
  

215
00:15:00.993   -->   00:15:04.746
"requirements.in"에다가 "djangorestframework"라고
  

216
00:15:04.770   -->   00:15:07.266
우리가 사용할 패키지들의 이름을 적어둔 다음에
  

217
00:15:07.290   -->   00:15:13.685
"pip-compile" 명령어를 치게 되면 "requirements.txt"
파일이 자동으로 뿅하고 생길 것이고  

218
00:15:13.710   -->   00:15:18.636
이 안에 "pip-compile" 명령어를 치는 순간에 Django REST Framework 패키지와 버전
  

219
00:15:18.660   -->   00:15:22.532
그리고 의존성 패키지들에 대한 정보가 자동으로 담기게 될 겁니다
  

220
00:15:22.920   -->   00:15:28.029
그리고 자세히 보시면 주석으로 이 패키지가 어디 패키지에 의존된 패키지인지
  

221
00:15:28.054   -->   00:15:31.125
자동으로 써준다 라고 하는 정도 확인할 수 있을 겁니다
  

222
00:15:31.590   -->   00:15:35.126
참고로 "pip-compile" 명령어를 치실 때 특정 옵션을 주시게 되면
  

223
00:15:35.151   -->   00:15:39.845
"requirements.txt" 안에 NPM의 "package-lock.json"이 그러했듯이
  

224
00:15:39.870   -->   00:15:42.133
이렇게 해시값을 생성해주기도 합니다
  

225
00:15:42.750   -->   00:15:46.890
그리고 "pip-tools"를 이용한다면 특정 패키지의 버전을 업그레이드를 할 때
  

226
00:15:46.915   -->   00:15:49.532
버전을 지정해주기가 매우 매우 쉬워집니다
  

227
00:15:49.921   -->   00:15:52.561
전체 패키지를 업그레이드하고 싶을 때는 이렇게
  

228
00:15:52.586   -->   00:16:00.845
그리고 Django를 최신으로 Requests는
2.0.0 으로 업그레이드하고 싶을때는 이렇게  

229
00:16:00.870   -->   00:16:05.335
그리고 Django는 2점대 이하 버전으로 업그레이드한 값의 락파일을
  

230
00:16:05.360   -->   00:16:08.735
"requirements-django1x.txt" 하는 이름의
  

231
00:16:08.760   -->   00:16:12.188
파일에 담고 싶으면 이렇게 써주시면 됩니다
  

232
00:16:12.991   -->   00:16:16.653
PIP를 이용했더라면 이러한 상황에서 명령어를 여러 번 치거나
  

233
00:16:16.678   -->   00:16:20.696
"requirements.txt" 직접 수동으로
건드려주어야 했을 겁니다. 그렇죠  

234
00:16:21.648   -->   00:16:24.411
그리고 이렇게 생성된 "requirements.txt" 는
  

235
00:16:24.435   -->   00:16:28.532
이렇게 "pip-sync"를 통해서 실제 프로젝트에 반영할 수가 있습니다
  

236
00:16:29.070   -->   00:16:31.943
특정 락파일을 프로젝트에 반영하고 싶을 때는
  

237
00:16:31.968   -->   00:16:36.538
즉 이 경우에는 "requirements-django1x"
  

238
00:16:36.563   -->   00:16:42.211
아까 전에 그 락 파일을 프로젝트에 반영하고 싶으시다면
  

239
00:16:42.236   -->   00:16:45.220
이렇게 파일명만 적어주시면 보이시는 것처럼
  

240
00:16:45.245   -->   00:16:49.446
특정 락파일이 프로젝트에 잘 반영이 된 겁니다
  

241
00:16:49.980   -->   00:16:55.798
이 "pip-tools"가 기존이 PIP를 이용한 패키지
관리 문제 해결에서 가지는 좀 가장 큰 의의는  

242
00:16:55.823   -->   00:17:00.006
이 락파일을 담당하는 "requirements.txt"를
자동으로 얻을 수 있다는 겁니다  

243
00:17:00.030   -->   00:17:03.342
그렇기 때문에 당연히 개발환경을 재구성하고 또 재현하는데
  

244
00:17:03.367   -->   00:17:06.545
정말 용이해진 점도 있고 정말 편리해진 부분도 있고요
  

245
00:17:06.569   -->   00:17:10.694
그리고 아까 전에 말씀드렸던 것처럼 뭐 설치를 하거나 또 업그레이드를 할 때
  

246
00:17:10.719   -->   00:17:13.485
특정 패키지의 버전지정이 정말 편리해졌습니다
  

247
00:17:13.510   -->   00:17:17.953
그리고 requirements에서 자동으로 생성되는 주석 덕분에
  

248
00:17:17.978   -->   00:17:23.094
requirements에서 자동으로 생성되는 주석에 의존성 정보가 쓰이기 때문에
  

249
00:17:23.339   -->   00:17:27.891
패키지 의존성 트레킹이 어느 정도는 가능해졌습니다
  

250
00:17:28.530   -->   00:17:31.960
자 근데 사실 여기서 만족해서도 됐었는데 그리고 저는 아직까지도
  

251
00:17:31.985   -->   00:17:35.856
만약에 누군가가 저한테 "최대한 가볍고 단순하게 파이썬 패키지
  

252
00:17:35.880   -->   00:17:39.965
의존성 관리하는 방법이 뭐예요?"라고 만약에 누군가 저한테 물어보신다면
  

253
00:17:39.990   -->   00:17:42.857
"pip-tools요" 라고 답할 의사도 분명히 있는데
  

254
00:17:42.882   -->   00:17:48.096
개인적으로는 조금 제 개인적인 니즈하고는 좀 안 맞는 지점들이 있더라고요
  

255
00:17:48.120   -->   00:17:51.298
일단이 "pip-tools"는 패키지 설치기능 자체는 없습니다
  

256
00:17:51.323   -->   00:17:54.391
그렇기 때문에 PIP는 당연히 좀 끼워야 하고요
  

257
00:17:55.268   -->   00:17:57.947
그리고 여전히 패키지 관리자와 가환경은 따로 놀기 때문에
  

258
00:17:57.972   -->   00:18:01.321
패키지 관리자와 더불어서 가상환경도 따로 하나 끼워야 합니다
  

259
00:18:01.346   -->   00:18:04.228
그리고 만약에 파이썬 버전별 매니지먼트가 필요하시다면
  

260
00:18:04.253   -->   00:18:06.756
pyvenv도 당연히 기셔야겠죠. 그렇죠
  

261
00:18:06.780   -->   00:18:11.586
그리고 무엇보다도 이게 의존관계가 한눈에 잘 안 들어옵니다
  

262
00:18:11.610   -->   00:18:15.289
이 주석으로 써준다고는 하는데 이게 프로젝트가 커지고
  

263
00:18:15.314   -->   00:18:18.996
또 패키지가 많아지니까 가독성이 영 좋지는 않더라고요
  

264
00:18:19.020   -->   00:18:23.466
이 pip-tools도 이거를 의식하고 있는지 pip-tools 공식저장소에 가보면
  

265
00:18:23.490   -->   00:18:28.536
의존성 그래프의 가독성을 높일거면 pipdeptree라고 하는 패키지가 있어요
  

266
00:18:28.560   -->   00:18:31.657
'이거 깔아서 쓰세요'라고 안내하고 있기도 하고요
  

267
00:18:32.280   -->   00:18:37.045
그러니까 pip-tools가 너무너무 좋긴 한데 이게 의존성 관리 이외에는
  

268
00:18:37.070   -->   00:18:40.547
아무것도 안 해준다라고 하는 느낌은 조금 있었더라고요
  

269
00:18:40.770   -->   00:18:46.965
그래서 개인적으로는 당시에 저는 패키지와
관련된 모든 것들을 다알아서 해줄 수 있는 툴  

270
00:18:46.990   -->   00:18:50.875
즉 올인원을 해줄 수 있는 패키지 관리자를 좀 원했었습니다
  

271
00:18:51.630   -->   00:18:57.063
그래서 다음으로 알아봤던 대안이
뭐였냐면 이 pipenv, PIP 인바이러먼트였습니다  

272
00:18:57.570   -->   00:19:01.999
이 pipenv 동작과정은 pipenv를 처음 사용했을 때
  

273
00:19:02.024   -->   00:19:05.736
즉 콘솔 화면에서 찍히는 정보들을 읽어보면 좀 이해가 잘 갑니다
  

274
00:19:05.760   -->   00:19:09.275
이 pipenv가 워낙에 친절하게 프린트를 잘 찍어줘가지고
  

275
00:19:09.300   -->   00:19:14.508
이것만 잘 읽어도 어떻게 동작하는지
어느 정도 이해하시는데 도움이 많이 될 거예요  

276
00:19:15.510   -->   00:19:18.845
예를 들어서 pipenv라고 하는 프로젝트 폴더를 하나 만들고
  

277
00:19:18.870   -->   00:19:23.805
그 안에서 pipenv를 이용한 패키지 관리를 진행한다 라고 가정해보죠
  

278
00:19:24.501   -->   00:19:29.636
제가 지금 빨간색으로 친 "pipenv install"이라고 하는 명령어는
  

279
00:19:29.661   -->   00:19:34.190
'의존성 파일들에 적힌 내용대로 패키지를 설치해라' 라고 하는 명령어인데
  

280
00:19:34.215   -->   00:19:37.835
만약에 프로젝트에서 처음으로 이 명령어지게 되면
  

281
00:19:37.860   -->   00:19:42.516
즉 한번도 이 명령어를 쳐본 적이 없는 상황에서
처음으로 이 명령어를 치시게 되면은  

282
00:19:42.540   -->   00:19:46.665
제가 지금 빨간색 하이라이트를 친 걸 보시면 아실 수 있듯이
  

283
00:19:46.690   -->   00:19:50.211
가상환경이 특정 경로에 생성이 됩니다
  

284
00:19:50.580   -->   00:19:54.306
프로젝트마다 각기 다른 가상환경을 pipenv가 만들어주는데
  

285
00:19:54.330   -->   00:19:59.046
맨 아래 줄을 보시면 아시다시피
"pipenv shell"이라고 하는 명령어를 통해서  

286
00:19:59.070   -->   00:20:03.438
지금 이 처음으로 만들어진 각기 다른 가상환경을 실행해 볼 수도 있습니다
  

287
00:20:03.720   -->   00:20:09.036
그리고 만약에 프로젝트 초기에 처음으로 "pipenv install" 명령어를 치게 되면
  

288
00:20:09.060   -->   00:20:12.186
보시는 것처럼 가상환경뿐만 아니라 이 Pipfile
  

289
00:20:12.210   -->   00:20:17.591
그리고 Pipfile.lock 즉 락파일도 덩달아서 생성되게 됩니다
  

290
00:20:17.616   -->   00:20:23.645
이 Pipfile은 Pipfile과 Pipfile.lock으로 자체적으로 생성한 가상환경 하에서
  

291
00:20:23.670   -->   00:20:27.306
패키지 의존성 관리를 진행한다 라고 보시면 됩니다
  

292
00:20:27.330   -->   00:20:32.465
짐작하시겠지만 이 "Pipfile"과 "Pipfile.lock"은 아까 전에 제가 초기에 보였던
  

293
00:20:32.490   -->   00:20:38.563
NPM의 "package.json", "package-lock.json"의 역할을 수행한다 라고보시면 됩니다
  

294
00:20:39.210   -->   00:20:43.086
이 pipenv는 패키지 설치기능도 갖고 있는데요
  

295
00:20:43.110   -->   00:20:46.459
pipenv Django를 이런 식으로 설치할 수도 있습니다
  

296
00:20:46.484   -->   00:20:51.449
이 Django를 설치하게 되면 NPM이 그러했듯이
이 락파일이 자동으로 업데이트가 될 겁니다  

297
00:20:51.474   -->   00:20:56.346
제가 지금 빨간색으로 하이라이트 친
부분에 부분이 그 부분에 해당하는 부분이에요  

298
00:20:56.370   -->   00:20:59.046
그리고 개발용 패키지도 쉽게 설치할 수가 있습니다
  

299
00:20:59.070   -->   00:21:05.046
"pipenv install"에 "--dev" 옵션을 주게 되면
개발용 패키지도 덩달아서 설치를 할 수가 있는데  

300
00:21:05.070   -->   00:21:11.047
이 경우에 락파일에는 "dev-packages"라고 하는
어떤 독립된 패키지 리스트들을 락킹하게 됩니다  

301
00:21:13.290   -->   00:21:16.725
그리고 배포용 패키지와 개발용 패키지를 각각 설치했을 때
  

302
00:21:16.750   -->   00:21:19.062
Pipfile에도 이렇게 "dev-packages"
  

303
00:21:19.087   -->   00:21:23.421
그리고 "packages"가 나뉘어서 명시된다 라고하는 것도 알 수 있습니다
  

304
00:21:23.850   -->   00:21:27.396
그리고 개인적으로 정말 좋았던 거는 드디어 패키지에 의존관계를
  

305
00:21:27.421   -->   00:21:30.576
한눈에 볼 수 있는 그래프가 제공되었다는 점입니다
  

306
00:21:30.600   -->   00:21:35.496
보시면 아시겠지만 이 Django라는 패키지에는 이러한 패키지들이 종속되어 있고
  

307
00:21:35.521   -->   00:21:39.716
몇 버전들이 필요하며 현재 설치된 버젼은 몇 버전인지 까지가
  

308
00:21:39.741   -->   00:21:43.781
한눈에 볼 수 있을 정도로 이렇게 명시가 된다 라고 하는 것을 알 수가 있죠
  

309
00:21:44.460   -->   00:21:50.038
이런 기본적인 기능들 이외에도 "pipenv run python" 명령어를 이용해서
  

310
00:21:50.063   -->   00:21:53.068
파이썬의 모듈을 직접 실행시켜볼 수도 있습니다
  

311
00:21:53.093   -->   00:21:57.475
예컨대 Django로 웹서버를 구동하려면
"pipenv run python manage.py runserver"  

312
00:21:57.500   -->   00:22:01.146
로 실행시킬 수 있겠죠. 그렇죠
  

313
00:22:01.170   -->   00:22:04.285
그리고 여러 락파일을 업데이트할 수 있는 락 명령어도 있고요
  

314
00:22:04.310   -->   00:22:07.091
그리고 여러 파이썬이 만약에 이미 설치되어 있거나
  

315
00:22:07.116   -->   00:22:10.326
혹은 pyvenv가 이미 사용 중이라면
  

316
00:22:10.350   -->   00:22:15.507
여러 프로젝트 환경에서 사용할 수 있는 특정
버전의 파이썬을 이렇게 지정할 수도 있습니다  

317
00:22:16.680   -->   00:22:19.694
지금까지 말씀을 들어보셨다면 분명히 공감하시겠지만
  

318
00:22:19.719   -->   00:22:23.679
이 pipenv는 분명히 기존의 PIP가 가지고 있는
  

319
00:22:23.704   -->   00:22:26.976
제가 문제제기했었던 문제점들을 해결해 주었습니다
  

320
00:22:27.000   -->   00:22:33.842
일단 이 락파일이 생겼기 때문에 Pipfile과 Pipfile.lock
  

321
00:22:33.867   -->   00:22:37.326
이두개의 파일을 버전 관리 시스템에 올리기만 한다면
  

322
00:22:37.351   -->   00:22:41.916
누가 어디서 클론을 받든지 패키지 의존성이 어느 정도 보장된 상태에서
  

323
00:22:41.940   -->   00:22:43.862
설치를 제대로 할 수가 있을 겁니다
  

324
00:22:43.887   -->   00:22:45.426
사용할 수가 있을 겁니다
  

325
00:22:45.450   -->   00:22:50.766
그리고 pip-tools와는 다르게 패키지의 설치와 관리, 가상환경 생성까지
  

326
00:22:50.790   -->   00:22:56.133
모두 한 번의 수행해준다는 점에서 기존의 문제점을 해결함과 동시에
  

327
00:22:56.158   -->   00:22:57.726
편의성도 제공해 주었다 라고 한다는 점을 알 수가 있고요
  

328
00:22:57.750   -->   00:23:02.664
그리고 아까 보여드렸듯이 프로젝트마다 파이썬의 버전을 지정하는 것도 쉬워졌고요
  

329
00:23:02.689   -->   00:23:07.596
개발용, 배포용 패키지를 나누어서 설치하고 관리하기가 조금 더 수월해졌습니다
  

330
00:23:07.620   -->   00:23:12.066
그런데 이 pipenv도 여러 소프트웨어가 그렇듯이 완벽하지는 않아서
  

331
00:23:12.090   -->   00:23:14.942
뭐 이런 저런 논란 그리고 비판점들로 인해서
  

332
00:23:14.967   -->   00:23:19.093
완벽하게 신뢰하기는 좀 어렵지 않나 라고 하는 목소리들도 있었습니다
  

333
00:23:19.470   -->   00:23:22.343
뭐 대표적인 예로 너무 늦은 릴리스 주기가 있었죠
  

334
00:23:22.368   -->   00:23:27.636
올해 릴리즈가 나오기는 했는데
디펜던시 레졸루션 이슈가 꾸준히 있었음에도 불구하고  

335
00:23:27.660   -->   00:23:31.446
2018년부터 올해까지 새릴리즈가 하나도 없었습니다
  

336
00:23:31.470   -->   00:23:37.289
그래서 이용자 입장에서는 이게 프로젝트가 제대로
메인테인이 되는 거 맞나라고 하는 의구심도 들었던 거죠  

337
00:23:38.340   -->   00:23:42.546
그리고 이거는 조금 이따가 성능 분석 때 다시 한 번 말씀드릴 예정인데요
  

338
00:23:42.570   -->   00:23:45.644
운영체제별로도 조금의 퍼포먼스 차이가 있긴 합니다
  

339
00:23:45.669   -->   00:23:50.286
아예 이제 pipenv 공식저장소에 가보면 뭐 윈도우가 우리한테는
  

340
00:23:50.310   -->   00:23:54.216
퍼스트클래스 시리즈입니다라고 명확히 적어되기도 했더라고요
  

341
00:23:54.240   -->   00:24:00.485
이런 어떤 시원섭섭한 상황에서 최근에
pipenv의 새로운 경쟁자가 등장했습니다  

342
00:24:00.510   -->   00:24:04.686
바로 Poetry이라고 하는 만들어진지 얼마 되지 않은 패키지 관리자인데요
  

343
00:24:04.710   -->   00:24:08.161
기능성으로만 놓고 봤을 때 기능성으로만 놓고 봤을 때는
  

344
00:24:08.186   -->   00:24:11.154
아까 전에 언급해드렸던 pipenv 기능성,
  

345
00:24:11.179   -->   00:24:14.914
플러스 알파를 제공하는 패키지 관리자라고 보시면 됩니다
  

346
00:24:15.720   -->   00:24:19.445
Poetry이 기본적인 유스케이스도 빠르게 소개해 드리도록 할게요
  

347
00:24:19.590   -->   00:24:25.056
사용하는 주요 기능 자체는 pipenv랑
비슷하기 때문에 좀 빠르게 살펴보고 넘어가자면  

348
00:24:25.080   -->   00:24:28.322
처음 프로젝트 환경에서 "poetry init"을 입력하게 되면
  

349
00:24:28.347   -->   00:24:32.826
이 pipenv에서 Pipfile이라고 하는 의존성 관리 문서가 생성이 되었듯이
  

350
00:24:32.850   -->   00:24:37.536
Poetry는 "pyproject.toml"이라고
하는 의존성 관리문서가 생성이 됩니다  

351
00:24:37.560   -->   00:24:41.616
이 "pyproject.toml"에 담기는 내용은 제가 하이라이트 친 부분에 해당하고요
  

352
00:24:41.640   -->   00:24:45.255
그리고 Pipfile과 비슷하게 "poetry install" 명령어를 치게 되면
  

353
00:24:45.280   -->   00:24:49.247
가상환경과 더불어서 "poetry.lock"파일이 만들어지게 됩니다
  

354
00:24:49.272   -->   00:24:52.359
pipenv랑 사용하는 게 좀 유사하죠
  

355
00:24:53.220   -->   00:24:56.376
그리고 그렇게 만들어진 가상환경을 실행시키는 명령어
  

356
00:24:56.401   -->   00:24:59.953
즉 액티베이트 시키는 명령어는 "poetry shell"입니다
  

357
00:25:00.358   -->   00:25:05.466
개인적으로는 pipenv의 가상환경의 프롬프트가 뭐 저만 그런 건지 모르겠는데
  

358
00:25:05.490   -->   00:25:08.919
가상환경을 켰을 때 껏을 때 서로 큰 차이가 없어서
  

359
00:25:08.944   -->   00:25:13.056
좀 액티베이트가 된 건지 안 된 건지 좀 헷갈리는 경우가 많았었는데
  

360
00:25:13.080   -->   00:25:18.816
이 Poetry 가상환경을 액티베이트를 하면 지금 보시는
것처럼 프롬프트부터 달라져서 좀 되게 편하더라구요  

361
00:25:18.840   -->   00:25:22.562
뭔가 딱 새로운 환경에 들어왔다 라고 하는 느낌도 들기도 하고요
  

362
00:25:24.390   -->   00:25:28.436
그리고 Poetry 도 pipenv와 마찬가지로 패키지를 설치할 수 있는
  

363
00:25:28.461   -->   00:25:31.003
어떤 패키지 관리자 기능도 수행을 하는데요
  

364
00:25:31.028   -->   00:25:35.093
예를 들어서 배포용으로 Django를 설치하는 명령어는 다음과 같습니다
  

365
00:25:35.370   -->   00:25:39.929
뭐 이렇게 Django를 추가하게 되면 당연히 락파일도 덩달아서 업데이트가 될 겁니다
  

366
00:25:40.510   -->   00:25:44.672
그리고 이제는 어쩌면 당연하게도 개발용 패키지를 구분해서 설치할 수도 있습니다
  

367
00:25:44.697   -->   00:25:48.322
지금 보시는 것처럼 "--dev" 옵션으로 패키지를 추가하시게 되면은
  

368
00:25:48.347   -->   00:25:51.781
배포하고는 무관한 개발용 패키지가 잘 설치가 될 거예요
  

369
00:25:52.680   -->   00:25:56.886
그리고 여기서부터 Poetry 플러스 알파에 해당하는 기능들인데요
  

370
00:25:56.910   -->   00:25:59.792
물론 다양한 기능들을 제공하지만
개인적으로 생각했을 때  

371
00:25:59.817   -->   00:26:04.416
개발을 할 때 있어서 가장 고맙고 또 유용했던 기능들을 꼽아봤습니다
  

372
00:26:04.440   -->   00:26:06.846
일단 처음으로 패키지 서치기능인데요
  

373
00:26:06.870   -->   00:26:09.690
이건 흥미롭게도 pip는 제공을 하지만
  

374
00:26:09.715   -->   00:26:13.416
pipenv나 pip-tools는 제공하지 않는 기능입니다
  

375
00:26:13.440   -->   00:26:18.080
예를 들어서 "poetry search keras" 이렇게 패키지를 검색하게 되면
  

376
00:26:18.105   -->   00:26:20.226
거기에 매칭되는 패키지와 버전
  

377
00:26:20.250   -->   00:26:23.898
그리고 간략한 설명까지 프린트되는 걸 확인할 수가 있습니다
  

378
00:26:24.180   -->   00:26:29.826
개인적으로 첨언을 드리자면 이러한 기능들이
실제 프로젝트에서 더 특별히 유용하게 쓰이는 이유는  

379
00:26:29.850   -->   00:26:36.185
제가 발표 제목에도 써드렸다시피 바야흐로
파이썬 대 패키지의 시대이기 때문입니다  

380
00:26:36.210   -->   00:26:39.816
우리들이 필요한 패키지들을 모두 이름을 외우고 다닐 수는 없을 거예요
  

381
00:26:39.840   -->   00:26:44.859
그리고 극히 일부의 패키지들을 쓰고 싶을
때 굳이 그거를 포함하고 있는 패키지까지  

382
00:26:45.060   -->   00:26:47.466
저 넓은 패키지까지 받은 필요도 없을 거고요
  

383
00:26:47.490   -->   00:26:51.941
결국에 이렇게 패키지를 서치하고 조회하는 기능이 있어야지
  

384
00:26:51.966   -->   00:26:57.305
우리들은 적재적소에 또 가볍게 원하는
패키지들을 받을 수 있다 라고 생각했기 때문에  

385
00:26:57.330   -->   00:27:01.406
이 "poetry search"라고 하는 기능이 저는
조금 더 고맙게 다가왔던 것 같습니다  

386
00:27:02.160   -->   00:27:08.466
그리고 개인적으로 좋았던 것 중에 하나는
Poetry의 어떤 친절한 인터페이스 입니다  

387
00:27:08.490   -->   00:27:13.416
뭐 예를 들어서 "poetry show" 혹은 "show --tree" 옵션으로 패키지로 조회하게 되면요
  

388
00:27:13.440   -->   00:27:19.165
현재 프로젝트의 어떤 패키지가 어떤 버전으로 있고
심지어는 이 패키지가 어떤 기능을 하는지  

389
00:27:19.190   -->   00:27:22.386
종속관계별로 색깔을 표시해서 이렇게 보여주더라고요
  

390
00:27:22.410   -->   00:27:24.917
개인적으로 이런 유저 친화적인 인터페이스가
  

391
00:27:24.942   -->   00:27:28.556
제가 딱 원했던 이상적인 패키지 매니저의 덕목 중의 하나여서
  

392
00:27:28.581   -->   00:27:31.686
정말 사막의 오아시스를 찾았던 기분을 느꼈습니다
  

393
00:27:31.710   -->   00:27:36.302
참고로 말씀드리자면요 이 PIP도 show옵션은 지원을 합니다
  

394
00:27:36.327   -->   00:27:41.466
현재 설치된 패키지가 패키지 중에서
이게 어떤 패키지고 어떤 버전에 설치돼 있고  

395
00:27:41.490   -->   00:27:44.316
간략하게 설명은 무엇인지 그렇게 써주긴하는데
  

396
00:27:44.340   -->   00:27:47.447
Poetry처럼 이렇게 친절하게 써주지는 않습니다
  

397
00:27:47.472   -->   00:27:52.534
이밖에도 Poetry는 이 pipenv보다
훨씬 더 많은 기능들을 제공을 하는데요  

398
00:27:52.559   -->   00:27:57.396
이 프로젝트에 필수적인 파일, 그리고 디렉토리 구조까지 세팅을 처음으로 세팅해주는
  

399
00:27:57.420   -->   00:28:00.185
킥스타터 기능이나 혹은 빌드기능
  

400
00:28:00.210   -->   00:28:05.435
가장 큰 차별점으로까지 인정받고 있는 배포기능, 퍼블리시 기능 등등
  

401
00:28:05.460   -->   00:28:07.926
정말 많은 기능들을 제공하고 있습니다
  

402
00:28:07.950   -->   00:28:12.058
때문에 Poetry는 이런 다채로운 기능들을
바탕으로 기존에 제가 제기했던 문제  

403
00:28:12.083   -->   00:28:15.786
즉 PIP가 가지고 있는 문제들을 정말 잘 해결하고 있습니다
  

404
00:28:15.810   -->   00:28:18.216
이 락파일을 이용한 의존성 관리는 당연하구요
  

405
00:28:18.240   -->   00:28:24.006
패키지 설치, 가상환경, 의존성 관리 올인원
역할을 하는 것도 굉장히 고마운 부분이었죠  

406
00:28:24.030   -->   00:28:27.349
그리고 pipenv처럼 파이썬 버전 호환이 자유롭고요
  

407
00:28:27.374   -->   00:28:30.147
그리고 아까 전에 말씀드렸던 것처럼 배포, 검색
  

408
00:28:30.172   -->   00:28:35.056
또 의존성 그래프를 비롯한 친절한 인터페이스 그리고 배포까지 등등
  

409
00:28:35.081   -->   00:28:38.595
Poetry는 기존에 제가 문제제기했었던 모든 문제 거기에
  

410
00:28:38.620   -->   00:28:43.390
플러스 알파까지도 제공해주는 정말 강력한 패키지 관리자 였던 것 같습니다
  

411
00:28:44.430   -->   00:28:47.076
그런데 사실 이 발표의 결론은
  

412
00:28:47.100   -->   00:28:51.412
원래 그래서 '여러분 그래서 파이썬에서 패키지 관리하실 때
  

413
00:28:51.437   -->   00:28:55.446
의존성 관리하실 때 Poetry를 쓰세요'가 원래 결론이었습니다
  

414
00:28:55.470   -->   00:28:59.226
왜냐하면 이 발표를 처음으로 준비했을 때가 3월 달에서 4월 달에 했는데
  

415
00:28:59.250   -->   00:29:02.279
저 때도 pipenv는 새 버전의 릴리스가 없었거든요
  

416
00:29:02.304   -->   00:29:05.646
그래서 2018년부터 지금까지 릴리스가 없으니까
  

417
00:29:05.670   -->   00:29:08.871
암묵적으로 메인테인이 잘 안 되는구나라고 생각해서
  

418
00:29:08.895   -->   00:29:12.096
원래 'Poetry 쓰세요'가 이 발표의 결론이였었는데
  

419
00:29:12.120   -->   00:29:16.057
올해 갑자기 pipenv에 대해서 두 개나 버전을 내더라구요
  

420
00:29:16.082   -->   00:29:19.416
심지어 그리고 이번 릴리스는 반응도 되게 좋았어요
  

421
00:29:19.440   -->   00:29:22.375
그래서 결국 결론을 조금 바꾸게 됐죠
  

422
00:29:23.160   -->   00:29:27.756
그래서 어떤 방면에서는 뭐가 더 나은지
그래서 어떤 니즈를 가질 경우에는  

423
00:29:27.780   -->   00:29:33.726
어떤 패키지 매니저를 사용해야 되는지에 대한
답변을 드리는 걸로 결론이 바뀌었습니다  

424
00:29:33.750   -->   00:29:37.881
그리고 그 결론을 도출하기 위해서 지금까지 제가 제기했던 문제들을 해결했던
  

425
00:29:37.906   -->   00:29:42.327
앞선 두 가지 도구 Poetry와 pipenv의 기능면, 관리면
  

426
00:29:42.352   -->   00:29:45.390
그리고 성능면에서 한번 비교를 해보도록 하겠습니다
  

427
00:29:46.650   -->   00:29:50.007
일단 다채로운 기능은 이 Poetry를 따라올 수가 없습니다
  

428
00:29:50.250   -->   00:29:54.170
그리고 개인적으로 Poetry의 기능성이 정말 뛰어나다라고 생각한 이유는
  

429
00:29:54.195   -->   00:29:59.256
'뭐 하나만 걸려라'라고 하는 식으로 하는
산발적인 기능들을 병렬적으로 추가한 게 아니라  

430
00:29:59.280   -->   00:30:03.865
딱 패키지 혹은 프로젝트의 처음 탄생부터 배포까지 겪을 법한 일들을
  

431
00:30:03.890   -->   00:30:06.396
돕기 위한 기능들이 주를 이루기 때문이에요
  

432
00:30:06.421   -->   00:30:09.514
아까 전에 제가 예시로 보여드렸던 킥스타트, 검색,
  

433
00:30:09.539   -->   00:30:11.914
배포 같은 기능들도 같은 맥락이고요
  

434
00:30:12.510   -->   00:30:15.276
그런데 그래서 프로젝트의 발전 상황은 어떠냐
  

435
00:30:15.300   -->   00:30:18.426
버그는 얼마나 있고 얼마나 안정적으로 쓸 수가 있느냐
  

436
00:30:18.450   -->   00:30:22.776
얼마나 빨리 고쳐지고 있느냐 이걸 여쭤보신다면 또 상황이 다릅니다
  

437
00:30:22.800   -->   00:30:25.845
왜냐하면 Poetry의 버그가 정말 압도적으로 많아요
  

438
00:30:25.870   -->   00:30:28.118
워낙에 신생이라서 그런 것도 있는것 같고요
  

439
00:30:28.143   -->   00:30:31.429
역으로 기능이 워낙 많아서 그런 것도 있는 것 같습니다
  

440
00:30:32.100   -->   00:30:33.636
다음으로는 성능 테스트입니다
  

441
00:30:33.660   -->   00:30:36.936
성능 테스트와 관련해서는 또 드릴 말씀이 되게 많은데
  

442
00:30:36.960   -->   00:30:41.766
이번 발표에서는 시간관계상 중요한 핵심 결론만 말씀드리도록 하겠습니다
  

443
00:30:41.790   -->   00:30:47.826
어떤 자세한 결과나 추가적인 설명 혹은 더 많은
실험들은 우측하단 링크에다가 남겨드릴 테니까  

444
00:30:47.850   -->   00:30:54.406
혹시라도 필요하시거나 관심 있는 분들은 따로
들어가서 보시면 정말 정말 감사드릴 것 같습니다  

445
00:30:54.990   -->   00:31:00.096
일단 pipenv와 Poetry의 상황별 성능을 "time"을 이용해서 측정을 했는데
  

446
00:31:00.120   -->   00:31:03.486
기본적으로 Django, Django REST Framework를 설치하고
  

447
00:31:03.510   -->   00:31:07.588
개발용 패키지로 Flake, Django Debug Toolbar
  

448
00:31:07.613   -->   00:31:10.506
그리고 Pytest를 설치하는 과정을 측정했습니다
  

449
00:31:10.530   -->   00:31:13.670
그리고 이 패키지들을 인스톨하고 디펜던시를 추가하고
  

450
00:31:13.695   -->   00:31:17.007
락킹하고 언인스톨하는 과정도 측정했습니다
  

451
00:31:18.240   -->   00:31:21.418
일단 여러번의 실험을 다양한 환경에서 반복시행한 결과
  

452
00:31:21.443   -->   00:31:26.346
공통적으로 인스톨할 때는 pipenv가 더 높은 속도를 보였고요
  

453
00:31:26.370   -->   00:31:32.136
그 이외의 상황 즉 디펜던시를 추가하거나
특정 패키지를 언인스톨하거나 락킹할 때는  

454
00:31:32.160   -->   00:31:35.046
큰 폭으로 Poetry의 성능이 더 우세했습니다
  

455
00:31:35.070   -->   00:31:38.272
그런데 이 실험을 진행할 때 제가 리눅스 환경
  

456
00:31:38.297   -->   00:31:43.225
즉 두 개의 리눅스 환경에서 실험을 더 진행을 해봤었거든요. 처음에
  

457
00:31:43.250   -->   00:31:48.241
CentOS 7.7이랑 Ubuntu 18.04 LTS에서 실험을 진행했었는데
  

458
00:31:48.266   -->   00:31:52.116
나중에 이 테스트를 윈도우즈에서 진행했을 때는 이 차이의 폭이
  

459
00:31:52.140   -->   00:31:54.216
그렇게 크지는 않았습니다
  

460
00:31:54.240   -->   00:31:58.116
여러번 노트북을 달리해서 실험해봐도 같은 결과가 나오는 걸 보면은
  

461
00:31:58.140   -->   00:32:03.966
확실히 pipenv는 윈도우즈에서 사용하기가 좀 더 적합한 툴인 것 같습니다
  

462
00:32:03.990   -->   00:32:09.396
그리고 운영체제에 따라서 성능이 얼마나 차이가
있는지에 대해서도 테스트를 해보고 싶었는데  

463
00:32:09.420   -->   00:32:13.537
동일하거나 비슷한 성능을 갖고 있는 맥북, 리눅스, 윈도우 컴퓨터를
  

464
00:32:13.562   -->   00:32:16.026
다 구하는 게 아무래도 좀 어렵더라고요
  

465
00:32:16.050   -->   00:32:20.076
그래서 아마 컨퍼런스가 시작되고 여러분들이 이 발표를 보실 때쯤에는
  

466
00:32:20.100   -->   00:32:26.166
아마 해당 테스트까지 완료된 어떤 내용을
하단 링크에서 확인하실 수 있을 겁니다  

467
00:32:26.190   -->   00:32:28.116
꼭 남겨 주도록 할게요
  

468
00:32:28.140   -->   00:32:32.706
그리고 마지막으로 pipenv가 올해 릴리즈가 있었다 라고 말씀을 드렸잖아요
  

469
00:32:32.730   -->   00:32:35.761
그런데 pipenv에 최신 버전으로 테스트를 해보면은
  

470
00:32:35.786   -->   00:32:39.456
이전 버전에 비해서 성능이 또 눈에 띄게 좋아졌더라고요
  

471
00:32:39.480   -->   00:32:43.146
당연한 이야기일 수는 있겠지만 버전에 따라서도 성능 개선 있었습니다
  

472
00:32:43.170   -->   00:32:47.196
단지 이제 pipenv의 성능 개선이, 버전에 따라 성능 개선이
  

473
00:32:47.220   -->   00:32:52.171
좀 더 눈에 띄게 더 많은 개선이 있었다 라는점 결론으로 말씀드리겠습니다
  

474
00:32:52.860   -->   00:32:56.316
자 그래서 길었던 저의 이야기의 결론은 다음과 같습니다
  

475
00:32:56.340   -->   00:33:01.926
만약에 이 PIP를 이용한 패킷이 관리의
문제점에 공감하고 있는 어떤 사람이 와서  

476
00:33:01.950   -->   00:33:05.073
'저는 배포나 패키지 트래킹은 아직까지 큰 관심 없어요
  

477
00:33:05.098   -->   00:33:07.476
딱히 가상환경을 따로 쓰고 싶지도 않구요
  

478
00:33:07.500   -->   00:33:09.666
파이썬 버전별로 개발할 필요도 없어요
  

479
00:33:09.690   -->   00:33:14.796
그냥 동일한 프로젝트 환경을 재구성하는
것만 보장할 수 있으면 돼요'라고 물어보신다면  

480
00:33:14.820   -->   00:33:18.029
저는 그냥 '가볍게 pip-tools 쓰시고 requirements.in
  

481
00:33:18.054   -->   00:33:23.828
혹은 setup.py를 requirements.txt랑
커밋해 주세요'라고만 말씀드릴 것 같습니다  

482
00:33:24.690   -->   00:33:28.866
또 만약에 누군가가 '저는 패키지 디펜더시 트레킹은 정말 중요해요
  

483
00:33:28.890   -->   00:33:33.156
동일한 프로젝트 환경을 재생성하는 거는 당연히 당연히 중요하고요
  

484
00:33:33.180   -->   00:33:38.136
가상환경 필요하고, 디펜던시 리졸빙 이슈는 웬만하면 진짜 만나고 싶지는 않아요
  

485
00:33:38.160   -->   00:33:44.496
무난하고, 할 거다 해주는 패키지 관리자를 원해요' 라고 물어보신다면
  

486
00:33:44.520   -->   00:33:48.012
라는 니즈를 갖고 계신다면 저는 그래도
아직까지는 '안정적이고 버그가 비교적 적은  

487
00:33:48.037   -->   00:33:53.671
그냥 좋은 게 좋은. 무난한 pipenv
도 되게 좋습니다' 라고 말씀드릴 것 같습니다  

488
00:33:54.240   -->   00:33:59.226
그리고 마지막으로 누군가가 '프로젝트의
처음부터 끝까지 편리하게 케어받을 수 있는  

489
00:33:59.250   -->   00:34:02.196
패키지 의존성 매니저가 있나요?'라고 물어보신다면
  

490
00:34:02.220   -->   00:34:05.789
저는 Poetry를 쓰시라고 말씀드릴 것 같습니다
  

491
00:34:06.450   -->   00:34:08.736
끝으로 저의 사견을 마지막으로 본 발표를 마치자면
  

492
00:34:08.760   -->   00:34:16.760
저는 진심으로 pipenv의 올해 릴리즈에 대한 감사한 마음을 갖고 있습니다만
  

493
00:34:16.889   -->   00:34:21.748
Poetry에 대한 지속적인 관심과 컨트리뷰션을 저와 함께 이어나가고 싶으신
  

494
00:34:21.773   -->   00:34:24.276
파이써니스타들이 정말 많아지신다면
  

495
00:34:24.300   -->   00:34:28.368
다채로운 기능성을 갖춘, 또 한편으로는 또 안정적인 패키지 관리자가
  

496
00:34:28.393   -->   00:34:32.992
또 하나 만들어지지 않을까? 라고 하는 어떤 행복한 상상을 해보기도 했습니다
  

497
00:34:33.480   -->   00:34:36.096
자 이상으로 저의 발표를 마치도록 하겠습니다
  

498
00:34:36.120   -->   00:34:40.656
끝까지 들어주셔서 진심으로 정말 정말 감사드립니다. 감사합니다


