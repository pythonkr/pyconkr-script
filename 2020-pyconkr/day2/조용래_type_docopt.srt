1
00:00:10,330 --> 00:00:12,429
조용래. Type-Docopt 발표입니다
 

2
00:00:14,470 --> 00:00:19,665
CLI. 즉 커맨드 라인 인터페이스는
개발자들에게 가장 익숙한 인터페이스일 것입니다 

3
00:00:20,050 --> 00:00:23,026
우리는 매일 수많은 CLI를 사용하고 또 만듭니다
 

4
00:00:23,650 --> 00:00:28,642
그림에서 보시는 예시는 파이썬 패키지 매니저인
PIP의 커맨드 라인 인터페이스의 일부입니다 

5
00:00:29,020 --> 00:00:31,996
파이썬을 사용한다면 수없이 써 왔을 프로그램이죠
 

6
00:00:32,320 --> 00:00:36,726
이 프로그램도 우리는 CLI를 통해서 실행을 하고 그 결과를 받습니다
 

7
00:00:37,840 --> 00:00:42,800
사용자와 만나는 모든 인터페이스가 그렇듯이 CLI도 하나의 인터페이스기 때문에
 

8
00:00:42,863 --> 00:00:46,207
사용하기 쉽게 또 관리하기 쉽게 만드는 것은 매우 중요합니다
 

9
00:00:47,050 --> 00:00:52,620
그런데 파이썬으로 프로그램의 커맨드 라인 인터페이스를
정의할 때 여러분 혹시 어떤 라이브러리를 쓰시나요? 

10
00:00:54,220 --> 00:00:58,786
오늘은 직관적이고 아름다운 커맨드 라인 인터페이스를 만들 수 있게 해주는
 

11
00:00:58,810 --> 00:01:01,884
type-docopt 라는 라이브러리에 대해서 소개해 드리려고 합니다
 

12
00:01:03,340 --> 00:01:06,800
안녕하세요. 저는 type-docopt 발표를 맡은 조용래입니다
 

13
00:01:06,902 --> 00:01:09,808
온라인에서는 dreamgonfly라는 닉네임을 사용하고 있어요
 

14
00:01:10,480 --> 00:01:15,166
넥슨코리아에서 데이터 분석가로 일했고 네이버에서 머신러닝 엔지니어로 일하다가
 

15
00:01:15,190 --> 00:01:18,870
현재는 보이스루라는 스타트업에서 R&D팀 팀장으로 일하고 있습니다
 

16
00:01:20,500 --> 00:01:23,984
R&D 팀에서 저는 주로 AI 모델 개발을 받고 있습니다
 

17
00:01:24,580 --> 00:01:29,087
이 발표를 보시는 분들은 다양한 개발 백그라운드를 지니고 있을 겁니다
 

18
00:01:29,470 --> 00:01:32,071
저는 그 중에서 머신러닝 엔지니어 입니다
 

19
00:01:32,650 --> 00:01:36,337
일을 하면서 딥러닝 모델을 개발하고 학습시킬 때가 많은데요
 

20
00:01:36,700 --> 00:01:40,379
하나의 딥러닝 모델을 학습할 때는 아시는 분도 계시겠지만
 

21
00:01:40,404 --> 00:01:44,497
몇 십 개에 달하는 수많은 하이퍼 파라미터를 다룰 필요가 있습니다
 

22
00:01:44,920 --> 00:01:50,248
하지만 하이퍼 파라미터가 많아질수록 이를
정의하고 한눈에 보이게 하는 것은 어려웠는데요 

23
00:01:50,950 --> 00:01:53,473
여기에 대한 불편함을 계속 느꼈고
 

24
00:01:53,498 --> 00:01:58,146
그래서 그 해결방안을 고민하다가 만들어진 게 type-docopt입니다
 

25
00:02:00,550 --> 00:02:02,628
파이썬에서 기본으로 제공되고
 

26
00:02:02,653 --> 00:02:07,010
여러분도 아마 익숙하실 CLI parser는 argparse입니다
 

27
00:02:07,540 --> 00:02:10,672
그렇다면 왜 argparse 말고 다른 parser가 필요할까요
 

28
00:02:11,200 --> 00:02:13,121
argparse의 문제점이 뭘까요?
 

29
00:02:13,960 --> 00:02:16,881
argparse가 동작하는 방식을 잠깐 살펴볼게요
 

30
00:02:17,410 --> 00:02:21,370
argparse를 사용하기 위해서는 먼저 parser 코드를 작성해야 됩니다
 

31
00:02:21,714 --> 00:02:25,760
왼쪽 코드에서 보듯이 argparse에서
 

32
00:02:25,785 --> 00:02:29,362
ArgumentParser라는 클래스의 인스턴스를 먼저 생성 해야되고
 

33
00:02:29,830 --> 00:02:36,126
그 인스턴스에 argument을 하나하나 add_argument라는 메소드로 추가를 하는데
 

34
00:02:36,447 --> 00:02:40,415
그 argument에 내가 받고 싶은 파라미터의 이름과
 

35
00:02:40,840 --> 00:02:46,730
그 타입과 선택 가능한 값들 그리고 헬프 메세지들을 지정을 합니다
 

36
00:02:47,200 --> 00:02:52,216
이렇게 하고 나면 argparse는 작성한 parser 코드들을 바탕으로
 

37
00:02:52,240 --> 00:02:57,997
우리가 터미널에서 프로그램명을 입력하고
 

38
00:02:58,022 --> 00:03:03,139
-h 또는 --help 라고 쳤을 때 나오는
 

39
00:03:03,164 --> 00:03:05,693
헬프 메시지를 자동으로 생성을 해줍니다
 

40
00:03:08,200 --> 00:03:12,317
즉 argparse는 parser 코드를 작성하면
 

41
00:03:12,342 --> 00:03:16,739
그 코드를 헬프 메세지로 변환시켜주는 기능을 갖고 있는 겁니다
 

42
00:03:18,160 --> 00:03:22,160
parser 코드로 작성하면 헬프 메시지를 만들어주는 게 좋아보이나요?
 

43
00:03:23,042 --> 00:03:24,816
아니죠. 좋지 않습니다
 

44
00:03:25,360 --> 00:03:27,797
여러분 더 좋은 방식이 뭔지 아십니까?
 

45
00:03:29,500 --> 00:03:33,460
바로 헬프 메시지를 작성하면 자동으로 parser를 만들어주는 겁니다
 

46
00:03:34,690 --> 00:03:39,541
type-docopt는 사람이 헬프 메시지를 작성하고
 

47
00:03:39,566 --> 00:03:45,236
그 작성한 헬프 메시지를 바탕으로 CLI argument parser를 생성해줍니다
 

48
00:03:45,940 --> 00:03:48,260
이게 type-docopt의 기본적인 개념이에요
 

49
00:03:52,840 --> 00:03:55,574
그럼 왜 헬프 메시지를 써야 될까요?
 

50
00:03:57,400 --> 00:04:03,556
헬프 메세지는 가장 직관적이고 사람이 읽기 쉬운 표현입니다
 

51
00:04:04,750 --> 00:04:08,416
그렇지 않으면 헬프 메시지로서 의미가 없겠죠
 

52
00:04:08,440 --> 00:04:11,924
사람이 읽기 쉽다면 작성하기도 쉬울 겁니다
 

53
00:04:12,160 --> 00:04:16,306
사람이 쉽게 작성한 헬프 메시지에 들어있는 정보를 이용해서
 

54
00:04:16,330 --> 00:04:18,283
CLI parser를 만든다면
 

55
00:04:18,308 --> 00:04:23,884
사람이 쉽게 읽고, 쉽게 쓸 수 있는 CLI 라이브러리를 만들 수 있겠죠
 

56
00:04:25,711 --> 00:04:29,571
더불어 파이썬에서는 모둘을 개발할 때
 

57
00:04:29,596 --> 00:04:34,813
맨 위에 헬프 메시지를 docstring으로 넣는 것을 권장하고 있습니다
 

58
00:04:35,590 --> 00:04:40,668
즉 파이썬의 권장도 따르면서 이 docstring의 헬프 메시지를 통해서
 

59
00:04:42,310 --> 00:04:47,466
이 프로그램이 무엇을 하는 프로그램인지 어떤 argument를 받는지를 기술하고
 

60
00:04:47,950 --> 00:04:52,936
그리고 그것대로 실제로 argument를 받을 수 있게 하는 것이
 

61
00:04:52,960 --> 00:04:55,139
바로 type-docopt의 개념인 것입니다
 

62
00:04:56,920 --> 00:05:02,201
그런데 사실 여기까지는 docopt 라이브러리 아이디어입니다
 

63
00:05:02,677 --> 00:05:05,794
docopt라는 라이브러리는 2012년에 처음
 

64
00:05:05,819 --> 00:05:08,458
방금 말씀드린 아이디어로 만들어졌습니다
 

65
00:05:09,610 --> 00:05:15,508
그렇다면 docopt라는 개념이 이미
있었는데 왜 type-docopt가 필요할까요? 

66
00:05:15,970 --> 00:05:17,759
여기는 세 가지 이유가 있습니다
 

67
00:05:20,470 --> 00:05:23,274
첫 번째는 개발의 방향성이 다르기 때문입니다
 

68
00:05:24,712 --> 00:05:29,782
docopt는 공식적으로 type validation 기능을 구현하는 걸 거부했습니다
 

69
00:05:30,610 --> 00:05:34,786
자기 프로젝트의 범위가 아니라고 판단한 거죠
 

70
00:05:34,810 --> 00:05:38,060
다른 인터페이스처럼 커맨드 라인 인터페이스에서도
 

71
00:05:38,085 --> 00:05:41,231
유저가 입력한 값들이 적절한 형식인지
 

72
00:05:41,263 --> 00:05:45,567
우리가 원하는 값이 맞는지를 검증하는 것은 되게 중요한 일입니다
 

73
00:05:46,919 --> 00:05:50,206
그리고 프로그램에서 유저입력을 쓰기 쉽게 만들기위해
 

74
00:05:50,231 --> 00:05:53,700
들어온 입력을 적절한 타입으로 변환하는 것도 필요한 일이죠
 

75
00:05:55,180 --> 00:05:59,101
하지만 docotp에서는 타입을 지정할 수 없었고
 

76
00:05:59,126 --> 00:06:01,781
모든 argument를 str으로 받고 있습니다
 

77
00:06:02,230 --> 00:06:05,315
그래서 실제로 docopt를 사용하다가
 

78
00:06:05,340 --> 00:06:10,526
너무 많은 불편을 느꼈고 그렇기 때문에
 type-docopt가 탄생하게 됐습니다 

79
00:06:12,526 --> 00:06:14,729
두 번째는 이와 이어지는 이유인데
 

80
00:06:15,610 --> 00:06:17,135
사용성의 문제였습니다
 

81
00:06:19,240 --> 00:06:24,365
우리가 흔히 사용하는 argparse에서는 type validation이랑
conversion 기능을 지원을 합니다 

82
00:06:24,880 --> 00:06:27,911
하지만 docopt에는 타입 지정 기능이 없었기 때문에
 

83
00:06:27,936 --> 00:06:33,755
argparse를 쓰던 사람이 docopt로 
한 번에 넘어오지 못하는 문제가 있었습니다 

84
00:06:34,210 --> 00:06:37,694
그래서 docopt가 argparse의 대안이 되기 위해서는
 

85
00:06:37,719 --> 00:06:40,664
타입 기능이 반드시 필요하다는 생각을 한 거죠
 

86
00:06:41,590 --> 00:06:45,269
그리고 세 번째 이자 가장 중요한 이유일 수도 있는데요
 

87
00:06:45,610 --> 00:06:48,578
docopt가 더 이상 유지 보수 되지 않는다는 것입니다
 

88
00:06:49,150 --> 00:06:53,110
docopt는 한 2년 동안 새로운 commit이 없고
 

89
00:06:53,135 --> 00:06:56,337
정식 릴리즈는 심지어 5년 전에 멈춰 있습니다
 

90
00:06:57,460 --> 00:06:59,028
이런 말을 하는 사람도 있습니다
 

91
00:06:59,053 --> 00:07:03,428
docopt는 이미 완벽하기 때문에 더 이상 개발할 것이 없다
 

92
00:07:03,482 --> 00:07:06,818
실제로 더 docopt 이슈에 올라오는 말들인데요
 

93
00:07:07,131 --> 00:07:09,107
하지만 완벽한 라이브러리가 있을까요?
 

94
00:07:09,209 --> 00:07:14,154
파이썬도 계속 발전을하고 docopt도 파이썬으로 만들어진 프로그램이기 때문에
 

95
00:07:14,179 --> 00:07:16,216
계속 발전할 여지들이 있습니다
 

96
00:07:16,990 --> 00:07:20,349
모든 오픈소스는 유지보수가 필요하죠
 

97
00:07:21,520 --> 00:07:25,707
기존의 오픈소스 라이브러리가 더 이상 발전을 하지 않고
 

98
00:07:25,731 --> 00:07:27,684
풀리퀘스트도 받지 않고
 

99
00:07:27,754 --> 00:07:31,714
또 기존과는 조금 다른 방향성을 추구하는 라이브러리가 필요할 때
 

100
00:07:31,731 --> 00:07:33,011
우리는 어떻게 해야 될까요?
 

101
00:07:35,080 --> 00:07:37,665
바로 우리는 프로젝트를 Fork하죠
 

102
00:07:38,322 --> 00:07:40,157
앞서 말한 이유들 때문에
 

103
00:07:40,142 --> 00:07:45,040
type-docopt는 docopt에서 떨어져 나가 
forked 프로젝트가 될 수밖에 없었습니다 

104
00:07:49,570 --> 00:07:52,874
다른 forked 프로젝트를 잠깐 알아보고 넘어갈까요?
 

105
00:07:55,570 --> 00:07:58,320
두 가지 정도의 비슷한 사례를 가져왔는데요
 

106
00:07:58,960 --> 00:08:03,842
파이썬에서 이미지 처리를 담당하는 PIL이라는 라이브러리가 있었습니다
 

107
00:08:04,420 --> 00:08:08,420
그런데 여기서 fork를 해나가서 Pillow라는 라이브러리가 생겼죠
 

108
00:08:09,190 --> 00:08:13,924
PIL의 설치가 어려웠고 또 릴리즈 주기가 너무 길다는 이유로
 

109
00:08:13,949 --> 00:08:16,636
fork해서 새로운 프로젝트가 만들어집니다
 

110
00:08:16,660 --> 00:08:20,761
현재 Pillow는 약 30만 가까운 프로젝트에서 쓰이고 있는
 

111
00:08:20,786 --> 00:08:24,855
GitHub에서만 그렇게 쓰이고 있는 굉장히 성공한 프로젝트가 되었죠
 

112
00:08:26,260 --> 00:08:31,216
두 번째 예시는 Flask-RESTX라는 프레임워크인데요
 

113
00:08:31,240 --> 00:08:35,271
Flask로 REST 프레임워크를 제공하는 프레임워크입니다
 

114
00:08:37,120 --> 00:08:41,446
그런데 그 이전에 Flask-RESTPlus라는 라이브러리가 있었어요
 

115
00:08:41,470 --> 00:08:44,296
이걸 들어보신 분들도 꽤 많을 것 같은데요
 

116
00:08:44,320 --> 00:08:49,390
그런데 Flask-RESTPlus는 개발 및 유지 보수가 중단이 됐습니다
 

117
00:08:49,840 --> 00:08:54,043
Author가 더 이상 업데이트를 하지 않고 풀리퀘스트도 받지않고
 

118
00:08:54,068 --> 00:08:57,910
새로운 PIP 릴리즈도 하지 않고 있어요
 

119
00:08:58,269 --> 00:09:00,214
그래서 사람들이
 

120
00:09:00,239 --> 00:09:03,370
이걸 fork해서 새로운 프로젝트를 만들게 되었는데요
 

121
00:09:04,270 --> 00:09:07,598
심지어 지금 시점 기준으로 Flask-RESTPlus는
 

122
00:09:11,121 --> 00:09:16,066
프레임워크가 의존하는 라이브러리와 호환성이 깨져가지고
 

123
00:09:16,090 --> 00:09:18,441
현재 최신 버전으로 설치하면은
 

124
00:09:18,426 --> 00:09:22,222
최신 의존 라이브러리들과 호환되지 않아서 실행이 되지 않고 있습니다
 

125
00:09:23,350 --> 00:09:27,748
이런 문제점들 때문에 forked 프로젝트가 탄생하는 거죠
 

126
00:09:29,711 --> 00:09:32,882
type-docopt도 docopt의 forked 프로젝트입니다
 

127
00:09:33,520 --> 00:09:37,660
type-docopt가 docopt에서 바꾸는 부분은 간단합니다
 

128
00:09:38,320 --> 00:09:42,773
헬프 메시지에 파라미터의 타입정보를 추가할 수 있게 해주는 거죠
 

129
00:09:43,629 --> 00:09:45,589
타입 정보를 추가하고
 

130
00:09:45,613 --> 00:09:48,706
또 그 파라미터에서 쓸 수 있는
 

131
00:09:48,731 --> 00:09:51,566
value들의 선택지를 제한할 수 있습니다
 

132
00:09:52,360 --> 00:09:57,289
그래서 이렇게 입력된 정보를 바탕으로
헬프 메시지에 있는 정보를 바탕으로 

133
00:09:57,414 --> 00:10:02,266
type-docopt는 이걸 parser로 변환해서 유저의 입력을 validation하고
 

134
00:10:02,290 --> 00:10:05,499
해당 타입으로 conversion을 해주는 역할을 수행하게 됩니다
 

135
00:10:07,750 --> 00:10:10,734
자 여기까지가 type-docopt의 기본적인 컨셉입니다
 

136
00:10:11,440 --> 00:10:16,986
헬프 메시지를 받고 그걸 parsing해서 arguments로 만들어 주는데요
 

137
00:10:17,230 --> 00:10:22,065
그 헬프 메세지에 특정 argument에 어떤 타입이 들어가고
 

138
00:10:22,090 --> 00:10:26,659
어떤 선택할 수 있는 value들이 있는지 지정할 수 있는 기능을 갖고 있습니다
 

139
00:10:27,220 --> 00:10:29,102
그럼 여기까지가 개괄이었고요
 

140
00:10:29,320 --> 00:10:34,484
그러면 실제로 type-docopt를 어떻게 쓸 수 있는지 그 방법을 알아보려고 합니다
 

141
00:10:37,030 --> 00:10:40,069
그래서 여러분들이 실제로 type-docopt틀 쓸때
 

142
00:10:40,094 --> 00:10:44,147
참고할 수 있는 자료로 쓸 수 있을 겁니다
 

143
00:10:47,380 --> 00:10:52,723
자 먼저 헬프 메시지를 어떻게 작성해야 되는지
Quick example을 통해서 알아볼게요 

144
00:10:54,310 --> 00:10:57,278
맨 윗줄에 프로그램의 역할을
 

145
00:10:57,303 --> 00:11:01,276
한마디로 정리하는 Summary 부분을 제외하고 나면
 

146
00:11:01,300 --> 00:11:03,315
헬프 메시지는 두 부분으로 나뉩니다
 

147
00:11:03,730 --> 00:11:06,284
첫 번째는 Usage 패턴이고요
 

148
00:11:06,550 --> 00:11:08,870
두 번째는 Options description 입니다
 

149
00:11:09,280 --> 00:11:13,014
Options description은 있을 수도 있고 없을 수도 있습니다
 

150
00:11:14,592 --> 00:11:17,490
그래서 이렇게 헬프 메세지를 정의해둔 후
 

151
00:11:18,760 --> 00:11:23,174
type-docopt를 import해서 그 type-docopt에
 

152
00:11:23,199 --> 00:11:25,635
docstring을 인자로 넣으면은
 

153
00:11:27,430 --> 00:11:30,453
유저가 아래처럼 커맨드를 썼을 때
 

154
00:11:30,478 --> 00:11:34,640
커맨드를 파싱에서 dict로 아웃풋 하는 걸 볼 수가 있습니다
 

155
00:11:35,020 --> 00:11:42,402
지금 이 예시에서는 "python example.py transport 1.2.3.4 80"
 

156
00:11:42,582 --> 00:11:46,535
"--timeout 0.5 --protocol tcp" 이렇게 썼는데요
 

157
00:11:46,570 --> 00:11:48,887
이게 어떻게 parsing 되는지를 보시면은
 

158
00:11:50,440 --> 00:11:55,043
dict에서 먼저 'transport'라는 커맨드가 True로 켜져 있고요
 

159
00:11:55,570 --> 00:11:59,359
그 다음에 position argument인 1.2.3.4가
 

160
00:12:01,023 --> 00:12:04,657
'<host>'라는 argument에 들어가 있습니다
 

161
00:12:05,032 --> 00:12:09,711
그리고 마찬가지로 '<port>'라는 argument에 80이 들어가 있고요
 

162
00:12:10,633 --> 00:12:13,492
이제 timeout과 protocol 부분이 중요한데
 

163
00:12:13,517 --> 00:12:17,983
timtout의 경우 0.5라는 값을 집어넣었는데
 

164
00:12:18,008 --> 00:12:20,236
타입이 float로 지정이 돼 있습니다
 

165
00:12:20,260 --> 00:12:25,924
그래서 dict로 아웃풋이 나올 때도 float 형식으로 변환돼서 나오게 되었고요
 

166
00:12:26,050 --> 00:12:30,620
protocol의 경우에는 tcp 또는 udp 둘
중에 하나를 선택할 수 있도록 

167
00:12:30,645 --> 00:12:34,370
헬프 메세지에 정의가 되어 있었고 
그중에 하나를 골라쓴 것입니다 

168
00:12:35,110 --> 00:12:39,235
여기서 baud라는 argument가 있는데
 

169
00:12:39,261 --> 00:12:41,274
이 argument는 지정을 하지 않았지만
 

170
00:12:41,299 --> 00:12:44,180
default value가 9600으로 들어가 있고
 

171
00:12:44,204 --> 00:12:47,911
타입이 int 이므로 int 타입의 9600으로
 

172
00:12:47,936 --> 00:12:50,012
dict에 넣어져 있는 것입니다
 

173
00:12:51,881 --> 00:12:52,795
그럼 이제
 

174
00:12:53,530 --> 00:12:57,475
헬프 메시지에서 Usage 패턴과 Option description을
 

175
00:12:57,500 --> 00:13:00,819
어떻게 만들 수 있는지에 대해서 좀 더 자세히 알아볼게요
 

176
00:13:01,900 --> 00:13:05,267
이 형식이 곧 type-docpot의 기능이 되고요
 

177
00:13:05,890 --> 00:13:08,374
type-docopt가 제공해줄 수 있는
 

178
00:13:10,007 --> 00:13:11,522
feature들의 집합이 됩니다
 

179
00:13:13,840 --> 00:13:16,300
자 먼저 Usage 패턴 포맷입니다
 

180
00:13:20,710 --> 00:13:24,905
가장 간단한 Usage 포맷의 형태는 왼쪽과 같은 그림입니다.
 

181
00:13:25,720 --> 00:13:28,220
일단 'Usage'라는 단어가 필요합니다
 

182
00:13:29,080 --> 00:13:31,705
대문자여도 좋고 소문자여도 좋지만
 

183
00:13:31,730 --> 00:13:35,970
'Usage'라는 단어를 type-docopt가 인식을 해서 parsing을 하게 되고요
 

184
00:13:36,730 --> 00:13:40,253
그 다음에 나오는 단어는 프로그램의 이름이 됩니다
 

185
00:13:40,573 --> 00:13:44,362
그래서 프로그램의 이름을 넣고 그 뒤에
 

186
00:13:44,424 --> 00:13:48,698
그 프로그램이 가질 수 있는 커맨드랄지 argument들을 나열할 수 있는 거죠
 

187
00:13:50,920 --> 00:13:56,248
오른쪽 그림을 보면은 여러 가지 Usage 패턴을 나열한 리스트가 보이는데요
 

188
00:13:57,010 --> 00:14:02,088
같은 프로그램이라도 다른 패턴으로 인터페이스를 사용할 수가 있습니다
 

189
00:14:03,700 --> 00:14:08,424
그래서 각기 다른 Usage 패턴을 나열해서 표기하면
 

190
00:14:08,596 --> 00:14:10,596
type-docopt가 이것을 parsing해서
 

191
00:14:10,621 --> 00:14:13,025
여러 가지 Usage 패턴 중에
 

192
00:14:13,049 --> 00:14:16,635
현재 argument에 맞는 것을 가져와서 parsing을 하게 됩니다
 

193
00:14:18,550 --> 00:14:27,432
그럼 여기에 지금. 대괄호도 있고 꺽쇠도 있는데
 

194
00:14:27,518 --> 00:14:34,486
그리고 대시(-)도 있고 이러한 기호들이 어떤 의미를 하는지 알아보겠습니다
 

195
00:14:36,280 --> 00:14:38,436
먼저 Positional arguments입니다
 

196
00:14:40,024 --> 00:14:46,264
Positional arguments는 꺽쇠로 표현을 하거나 또는 대문자로 표기를 하게 됩니다
 

197
00:14:46,840 --> 00:14:50,394
이렇게 되면은 이 위치에 들어가는 argument가
 

198
00:14:50,419 --> 00:14:54,613
이 positional argument의 값이 되는 거죠
 

199
00:14:58,930 --> 00:15:02,898
두 번째로 Optional elements를 지정할 수가 있습니다
 

200
00:15:03,310 --> 00:15:06,346
값이 있을 수도 있고 없을 수도 있는 거죠
 

201
00:15:06,370 --> 00:15:09,838
이 경우는 대괄호 안에 옵션을 넣어서 표기를 합니다
 

202
00:15:10,840 --> 00:15:15,285
여러 가지 argument를 묶어서 optional이라고 표기를 할 수도 있는데요
 

203
00:15:15,520 --> 00:15:19,934
이런 경우에 각각의 argument들이 optional한 것과 같은 의미가 됩니다
 

204
00:15:24,730 --> 00:15:28,808
그 다음, 둘 중에 하나를 선택하도록 하는
 

205
00:15:29,950 --> 00:15:31,817
그런 형식도 있습니다
 

206
00:15:32,290 --> 00:15:35,618
이걸 Mutually-exclusive elements라고 부르는데요
 

207
00:15:36,070 --> 00:15:41,905
이 경우에는 | 기호를 이용해서 표기하게 됩니다
 

208
00:15:42,460 --> 00:15:48,506
그래서 소괄호가 그리고 꼭 필요한 필수적인 argument라는 것을 뜻하는데요
 

209
00:15:48,940 --> 00:15:52,291
원래 소괄호가 없이 argument가 있어도
 

210
00:15:52,316 --> 00:15:55,494
필수적이라는 것을 뜻하기 때문에 굳이 쓰지 않지만
 

211
00:15:55,900 --> 00:16:00,251
지금 이와 같이 OR 조건에 대한 argument들에서는
 

212
00:16:00,820 --> 00:16:06,226
4개의 옵션을 소괄호로 묶고 그 안에 | 기호를 이용해서
 

213
00:16:06,250 --> 00:16:11,773
넷중에 하나를 꼭 선택할 수 있도록 하는 형식을 보여줍니다
 

214
00:16:14,110 --> 00:16:19,953
그리고 하나의 argument를 여러 번 쓸 수 있도록 하는 방식도 있습니다
 

215
00:16:23,560 --> 00:16:26,086
'...' 으로 표기를 하는 건데요
 

216
00:16:26,110 --> 00:16:30,766
이 예시에서 "<file>..." 이라고 표기된 건
 

217
00:16:30,791 --> 00:16:33,313
'<file>'을 여러 번 쓸 수 있다는 뜻이고
 

218
00:16:33,891 --> 00:16:37,606
'move' 다음에 '(<from> <to>)...'로 표기된건
 

219
00:16:37,630 --> 00:16:41,356
"<from> <to> <from> <to> <from> <to>" 이런식으로
 

220
00:16:41,381 --> 00:16:45,606
여러 번 반복해서 argument 를 쓸 수 있다 라는 것을 뜻합니다
 

221
00:16:48,669 --> 00:16:52,301
자 그런데 옵션이 너무 많으면
 

222
00:16:57,460 --> 00:17:03,676
이것을 Usage 패턴 안에 다 쓰기 어려울 때도 있습니다
 

223
00:17:06,160 --> 00:17:10,589
그런 경우에 이 많은 옵션들을 options 라는거 하나로 묶어놓고
 

224
00:17:10,614 --> 00:17:15,784
그 옵션들에 대한 정보 하나하나를 밑에 나열해서 적어주는 방법이 있는데요
 

225
00:17:16,060 --> 00:17:21,345
이런 경우에 공간이 더 생기기 때문에 더 많은 것들을 적어줄 수가 있고
 

226
00:17:21,369 --> 00:17:24,517
parser 입장에서도 더 많은 정보를 취할 수 있는 방법이 됩니다
 

227
00:17:25,204 --> 00:17:31,000
지금 이 예시 같은 경우에 "my_program [options] <path>" 있는데요
 

228
00:17:31,270 --> 00:17:34,785
이 options에 '--all'이 들어갈 수도 있고
 

229
00:17:34,810 --> 00:17:37,880
'--long'이 들어갈 수도 있고 '--human-readable'이 들어갈 수도 있는
 

230
00:17:38,079 --> 00:17:41,934
여러 가지 가능성을 남겨두는 그런 표현 방식을 취하고 있습니다
 

231
00:17:43,720 --> 00:17:49,785
위에 같은 방식을 아래 같이 써도 같은 의미가 됩니다
 

232
00:17:50,350 --> 00:17:55,990
'--all'과 '--long'과 '--human-readable'이 모두 
대괄호 안에 들어있는 형태여도 같은 의미인 거죠 

233
00:18:00,580 --> 00:18:04,962
자 그 다음. 어떤 argument의 default value도 정할 수가 있습니다
 

234
00:18:05,530 --> 00:18:10,990
Options description 안에 옵션에 대한 설명이 있고
 

235
00:18:11,320 --> 00:18:15,421
그 옵션이 파라미터를 받는지 안 받는지를 지정할 수가 있고요
 

236
00:18:16,030 --> 00:18:18,584
그리고 옵션에 대한 설명이 있고
 

237
00:18:18,609 --> 00:18:22,436
그 뒤에 default 값도 정할 수 있는 공간이 있습니다
 

238
00:18:23,230 --> 00:18:28,503
그래서 대괄호를 쓰고 'default:' 하고 어떤 값을 써주면은
 

239
00:18:28,780 --> 00:18:33,123
실제 그 argument가 오지 않았을 때 default 값을 취해주게 되는 거죠
 

240
00:18:36,850 --> 00:18:39,576
타입을 지정하는 방법도 디폴트랑 비슷합니다
 

241
00:18:39,896 --> 00:18:44,116
default가 'default'라는 키워드를 써가지고
 

242
00:18:44,140 --> 00:18:48,366
표시를 했듯이
타입도 'type'이라는 키워드를 써가지고 표시를 합니다 

243
00:18:49,060 --> 00:18:52,685
기본적으로 내장된 타입. int, float,
 

244
00:18:53,966 --> 00:18:56,958
complex 등등의 타입을 쓸 수가 있고요
 

245
00:19:00,790 --> 00:19:05,375
그게 아니더라도 자신이 지정한 커스텀 타입도 사용할 수가 있습니다
 

246
00:19:08,920 --> 00:19:13,607
예를 들어 이 예시에서는 타입을 Path로 지정하는 예를 들어주고 있는데요
 

247
00:19:15,100 --> 00:19:20,748
Path라는 타입은 빌트인 타입이 아니기 때문에 기본 타입이 아니기 때문에
 

248
00:19:21,190 --> 00:19:23,861
type-docopt에서 기본적으로 인지를 하지는 못합니다
 

249
00:19:24,520 --> 00:19:28,036
하지만 Path라는 타입은 굉장히 유용한 타임이죠
 

250
00:19:28,060 --> 00:19:34,276
보통 argument로 path 정보를 받고 path 정보에 대해
어떤 파일에 

251
00:19:34,300 --> 00:19:37,128
읽거나 그 파일에 쓰는 경우가 흔하니까요
 

252
00:19:38,500 --> 00:19:42,593
그런데 보통은 이걸 다 str으로 받는데 파이썬에서는
 

253
00:19:42,618 --> 00:19:48,256
pathlib 이라는 라이브러리에, 기본 내장된 라이브러리에 Path라는 객체를 제공합니다
 

254
00:19:48,280 --> 00:19:54,123
이 Path 객체를 쓰면 path 오브젝트를 더욱 쉽게 다룰 수가 있는데요
 

255
00:19:54,820 --> 00:19:58,070
이 Path라는 새로운 타입을 지정해주기 위해서
 

256
00:19:58,109 --> 00:20:05,746
docopt의 argument, docopt의 함수인자로 types라는 인자가 있고
 

257
00:20:05,770 --> 00:20:09,801
이 types에 우리가 원하는 타입들의 정보를
 

258
00:20:09,840 --> 00:20:14,316
dict로 기록을 해두면은 key에 매칭되는 타입을 찾아서
 

259
00:20:14,341 --> 00:20:19,238
그 value에 지정된 타입으로 변환을 해주고 또 validation 해줍니다
 

260
00:20:21,490 --> 00:20:25,286
이렇게 type-docopt에서는 자신이 새로 만든
 

261
00:20:25,311 --> 00:20:29,544
타입도 지정할 수 있도록 오픈되어 있습니다
 

262
00:20:31,180 --> 00:20:35,937
마지막으로 소개해드릴 type-docopt의 기능은 choices 기능입니다
 

263
00:20:36,280 --> 00:20:38,272
이건 argparse에도 있는 기능인데요
 

264
00:20:38,972 --> 00:20:43,487
어떤 argument에 대해서 선택 가능한 value들을 지정해놓고
 

265
00:20:43,550 --> 00:20:46,862
그 value들 안이 아니면은 에러를 내뱉는 방식이죠
 

266
00:20:47,740 --> 00:20:51,490
그래서 이것도 default나 타입을 지정한 것과
 

267
00:20:51,488 --> 00:20:53,521
비슷한 방식으로 지정을 할 수가 있습니다
 

268
00:20:53,904 --> 00:20:57,724
대괄호 안에 'choices' 라는 키워드를 넣고
 

269
00:20:57,740 --> 00:21:01,560
그 choice들 하나하나를 띄어쓰기로 구분을 해서
 

270
00:21:01,599 --> 00:21:06,231
표기를 하면 이걸 allowable values로 인식을 해줍니다
 

271
00:21:07,330 --> 00:21:13,936
그리고 default를 지정한 것과 타입을 지정하는 것과도 같이 있을 수가 있고요
 

272
00:21:13,960 --> 00:21:19,546
이 기능을 통해서 유저의 인풋이 내가 지정한 형식이고
 

273
00:21:19,570 --> 00:21:22,765
내가 지정한 value들의 리스트에 속해 있는지를
 

274
00:21:22,790 --> 00:21:25,695
판단해서 인풋 validation을 할 수가 있습니다
 

275
00:21:29,440 --> 00:21:33,791
자 type-docopt가 정말 간단한 라이브러리이기 때문에
 

276
00:21:33,816 --> 00:21:36,018
설명이 되게 쉽게 끝났는데요
 

277
00:21:36,490 --> 00:21:39,216
type-docopt에 대한 설명을 넘어서
 

278
00:21:39,241 --> 00:21:42,474
좀 제너럴한 이야기를 한번 해보고 싶어서
 

279
00:21:42,499 --> 00:21:44,263
에필로그를 준비해 보았습니다
 

280
00:21:45,190 --> 00:21:49,424
혹시 Executable Documentation이라는
개념을 들어본 적이 있으신가요? 

281
00:21:51,550 --> 00:21:55,573
우리는 documentation이 중요하다는 것을 모두가 알고 있죠
 

282
00:21:57,460 --> 00:22:01,647
그런데 documentation을 실제로 쓰는 사람은 좀 드뭅니다
 

283
00:22:02,560 --> 00:22:07,130
왼쪽 카툰에서 보듯 보듯이 documentation을 쓴다는 것은
 

284
00:22:07,690 --> 00:22:12,361
프로그래밍을 하는 사람에게 항상 새 약속과 같은 거죠
 

285
00:22:13,018 --> 00:22:19,125
항상 월초나 연초에는 하려고 하다가 시간이 지나면서 흐지부지되고
 

286
00:22:19,150 --> 00:22:25,775
다시 내년에 하자, 다음 달에 하자 라는 그런 순간에 빠지기가 쉽습니다
 

287
00:22:27,100 --> 00:22:29,168
왜 우리는 documentation을 쓰지 않을까요?
 

288
00:22:29,193 --> 00:22:31,185
여기에는 여러 가지 이유가 있을 텐데요
 

289
00:22:31,750 --> 00:22:35,609
첫 번째는 그게 프로그램의 기능이 안 되기 때문이죠
 

290
00:22:35,980 --> 00:22:40,534
우리는 프로그램에 새로운 기능을 계속 추가해야 되는 그런 압박이 있는데
 

291
00:22:41,110 --> 00:22:46,500
기능에 도움이 안 되는데 documentation을
쓰는 거는 시간과 힘이 들어가는 일입니다 

292
00:22:46,875 --> 00:22:48,316
그래서 안 쓰게 되고요
 

293
00:22:48,340 --> 00:22:52,668
두 번째는 documentation 형식이 되게 자유분방하죠
 

294
00:22:53,020 --> 00:22:59,221
정해져 있지 않기 때문에 형식이 없는 documentation을 쓸 때
 

295
00:22:59,246 --> 00:23:03,652
더 많은 부담감을 느끼고 어려워집니다. 탬플릿이 없거든요
 

296
00:23:04,390 --> 00:23:07,804
그 다음 세 번째. 이게 가장 큰 이유라고 생각하는데요
 

297
00:23:08,590 --> 00:23:13,410
사실 documentation을 썼다가도 프로그램은 계속 변하잖아요
 

298
00:23:13,720 --> 00:23:15,845
근데 프로그램이 변하게 되면
 

299
00:23:15,829 --> 00:23:19,360
그 documentation에 썼던 말들이 거짓말이 되는 경우가
 

300
00:23:19,570 --> 00:23:20,836
굉장히 흔합니다
 

301
00:23:20,860 --> 00:23:23,039
그래서 documentation을 읽고
 

302
00:23:23,165 --> 00:23:26,406
그거대로 프로그램을 실행하고 사용하려고 하는데도
 

303
00:23:26,431 --> 00:23:27,826
그대로 되지 않아서
 

304
00:23:27,850 --> 00:23:33,459
오히려 documentation을 읽지 않으니만 못한 결과가 나오는때도 상당히 많죠
 

305
00:23:33,940 --> 00:23:38,150
그래서 documentation은 이런 문제점들이 있어서
 

306
00:23:38,221 --> 00:23:41,877
사람들이 잘 쓰지 않을 때도 많고
 

307
00:23:41,901 --> 00:23:46,244
그리고 썼다 해도 무용지물이 되는 경우도 많습니다
 

308
00:23:48,298 --> 00:23:53,166
그래서 저는 Executable documentation이라는
개념이 되게 중요하다고 생각하는데요 

309
00:23:55,719 --> 00:23:59,680
우리가 프로그래밍을 할 때는
Human readable한 영역이 있고 

310
00:23:59,705 --> 00:24:01,611
Executable한 영역이 있습니다
 

311
00:24:01,990 --> 00:24:03,982
Human readable한 영역은
 

312
00:24:04,006 --> 00:24:08,318
우리가 보는 문서
또는 우리가 읽는 주석 

313
00:24:08,860 --> 00:24:10,490
이런 것들이 있을 수 있겠죠
 

314
00:24:13,390 --> 00:24:16,522
그리고 Executable 영역에서는
 

315
00:24:16,569 --> 00:24:20,600
우리가 작성하는 코드와 그리고 바이너리 파일들이 있을 수 있습니다
 

316
00:24:20,980 --> 00:24:23,103
그것들은 우리가 읽지를 못하죠
 

317
00:24:23,128 --> 00:24:27,136
바이너리 파일은 읽지를 못하고 코드는 읽을 수는 있겠지만
 

318
00:24:27,160 --> 00:24:32,941
그 가독성 여부에 따라서 사람이 읽을 수
있는 코드도 있고 그렇지 않은 코드도 있을 겁니다 

319
00:24:33,644 --> 00:24:38,176
Executable Documentation이란 이 사이에 있는 겁니다
 

320
00:24:38,200 --> 00:24:42,046
휴먼도 읽을 수 있으면서 컴퓨터도 읽을 수 있고
 

321
00:24:42,070 --> 00:24:45,523
그래서 실행 가능한 그런 documentation을 말합니다
 

322
00:24:46,240 --> 00:24:52,396
documentation이 프로그램의 일부가 될 때
Executable documentation이라 할 수 있겠죠 

323
00:24:52,420 --> 00:24:54,916
자 그러면 여기에는 어떤 예시들이 있을까요?
 

324
00:24:54,940 --> 00:24:58,080
첫 번째로 가장 많이 나오는 얘기가 테스트입니다
 

325
00:24:58,480 --> 00:25:03,237
테스트는 Executable documentation의 가장 좋은 예 중에 하나예요
 

326
00:25:03,700 --> 00:25:08,116
우리가 프로그램을 만들고 그 프로그램에 대한 테스트를 만들면은
 

327
00:25:08,140 --> 00:25:13,429
테스트를 읽는것 만으로도 그 프로그램이 어떤
동작을 할 것인지 예상을 할 수가 있습니다 

328
00:25:16,180 --> 00:25:20,225
그리고 이 테스트는 이대로 동작할 거라는 믿음이 있죠
 

329
00:25:20,250 --> 00:25:25,070
왜냐하면은 그대로 동작하지 않으면은 이 테스트가 실패할 것이고
 

330
00:25:25,095 --> 00:25:27,539
그러면은 테스트를 통과하지 못할 테니까요
 

331
00:25:28,480 --> 00:25:33,081
그래서 파이썬에서도 테스트 라이브러리가 당연히 여러가지가 있지만
 

332
00:25:33,106 --> 00:25:36,073
모두 Executable documentation 역할을 할 수 있습니다
 

333
00:25:36,610 --> 00:25:39,196
Doctest라는 라이브러리가 있죠
 

334
00:25:39,220 --> 00:25:49,290
이 Doctest는 실제로 어떤 함수 또는 모듈의 docstring을 테스트로 사용합니다
 

335
00:25:49,480 --> 00:25:53,339
그래서 그 docstring의 테스트 형식에 맞춰서
 

336
00:25:53,364 --> 00:25:59,144
테스트를 써놓으면 테스트를 돌려서 통과 여부를 결정해주는 그런 라이브러리고요
 

337
00:26:00,010 --> 00:26:02,572
Pytest는 파이썬의 함수들로
 

338
00:26:02,597 --> 00:26:07,775
테스트를 작성 해놓으면 테스트를 돌려주는 라이브러리죠
 

339
00:26:08,830 --> 00:26:12,976
프로그램의 작동 방식을 기술하면서 사람도 읽을 수 있고
 

340
00:26:13,000 --> 00:26:19,351
또 컴퓨터도 실제로 실행시켜볼 수 있다는 점에서 
테스트는 Executable documentation이 됩니다 

341
00:26:22,300 --> 00:26:25,760
그리고 Swagger라는 걸 들어보신 분들 있을 거예요
 

342
00:26:26,260 --> 00:26:32,649
Swagger는 HTTP프레임워크를 만들 때
 

343
00:26:32,674 --> 00:26:34,636
HTTP API를 만들 때
 

344
00:26:34,660 --> 00:26:38,877
Swagger의 형식대로 지정을 해놓으면은
 

345
00:26:38,955 --> 00:26:41,228
그 형식을 읽어서
 

346
00:26:41,950 --> 00:26:48,246
실제로 Request를 날려볼 수 있고 Response를
받아볼 수 있는 웹페이지 형태로 만들어주는 툴입니다 

347
00:26:49,390 --> 00:26:52,780
이 Swagger도 Executable documentation의 예가 됩니다
 

348
00:26:53,260 --> 00:26:59,369
이 Swagger 페이지를 읽으면은 사람이 이 HTTP API가
 

349
00:26:59,400 --> 00:27:03,346
어떤 역할을 하고 어떤 기능을 하고 있는지 읽어볼 수 있고
 

350
00:27:03,370 --> 00:27:05,182
그리고 실제로 실행시켜볼 수도 있거든요
 

351
00:27:07,150 --> 00:27:14,196
그래서 Swagger만 있으면은 HTTP API의
documentation을 거의 작성할 필요가 없어지는 장점이 있죠 

352
00:27:18,160 --> 00:27:22,246
type-docopt도 이와 같은 예시 중의 하나라고 볼 수가 있습니다
 

353
00:27:22,270 --> 00:27:25,455
이 docstring은 human readable 합니다 헬프 메세지이니까요
 

354
00:27:25,573 --> 00:27:28,971
헬프 메시지가 human readable 하도록 만들어졌으니까요
 

355
00:27:29,502 --> 00:27:34,187
그런데 type-docopt는 이 헬프 메시지를 parsing을 해서
 

356
00:27:34,212 --> 00:27:36,360
executable한 parser를 만들어줍니다
 

357
00:27:37,270 --> 00:27:41,238
그래서 human readable한 동시에 executable 하게 되는 거죠
 

358
00:27:41,920 --> 00:27:45,916
이 docsting만 읽어도 프로그램의 동작 방식을 이해할 수가 있고
 

359
00:27:45,940 --> 00:27:50,533
그리고 실제로 그 방식대로 동작을 하도록 parser가 만들어주기 때문에
 

360
00:27:51,100 --> 00:27:53,107
거짓말할 염려가 없게 되고요
 

361
00:27:54,340 --> 00:28:00,436
또 CLI 기능이라는 새로운 기능을 프로그램에 추가할 수 있게 되면서
 

362
00:28:00,460 --> 00:28:04,116
이 헬프 메시지를 작성하게 되는 요인도 생기는 거죠
 

363
00:28:06,640 --> 00:28:12,725
그래서 제가 끝내기 전에 하고 싶은 말은
Executable Documentation이 더 많이 필요하다는 겁니다 

364
00:28:14,020 --> 00:28:17,737
우리는 테스트를 작성하는 걸 당연히 중요하다고 느끼고 있지만
 

365
00:28:17,762 --> 00:28:23,621
그것은 프로그램이 깨지거나 그 동작을 보장하는 것 이상으로
 

366
00:28:23,691 --> 00:28:27,916
그것이 사람이 읽을 수 있는 documentation 역할을 할 수 있기 때문에
 

367
00:28:27,940 --> 00:28:29,744
더욱더 필요하게 되는 거고요
 

368
00:28:30,400 --> 00:28:35,176
그리고 HTTP API를 만든다면 Swagger를 쓰는 것이 좋고
 

369
00:28:35,200 --> 00:28:41,236
CLI를 만든다면 type-docopt 같은 헬프 메세지 
parsing 라이브러리를 쓰는 것이 좋다고 생각합니다 

370
00:28:44,890 --> 00:28:46,991
그래서 짧은 발표였지만
 

371
00:28:47,016 --> 00:28:53,483
뭔가 이 발표에서 여러분이 가져갈 수 있게 
결론을 내보자면 아마 이런 것일 것입니다 

372
00:28:55,450 --> 00:28:58,426
마틴 파울러의 이러한 유명한 명언이 있죠
 

373
00:28:58,870 --> 00:29:06,479
컴퓨터가 이해하는 코드는 누구라도 작성할 수 있지만 
사람이 이해하는 코드는 좋은 프로그래머만이 작성할 수 있다 

374
00:29:07,060 --> 00:29:08,810
여러분도 이걸 기억해서
 

375
00:29:08,841 --> 00:29:13,044
사람과 컴퓨터가 모두 이해하는 
코드를 작성해 주시길 바랍니다 

376
00:29:13,700 --> 00:29:18,578
그 첫 번째 출발점이 "pip install type-docopt"가 됐으면 좋겠네요
 

377
00:29:19,390 --> 00:29:21,359
여기까지입니다. 감사합니다


