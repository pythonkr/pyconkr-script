1
00:00:10,720 --> 00:00:14,656
안녕하세요 파이콘 코리아 2020에서

2
00:00:15,100 --> 00:00:18,896
직렬화 포맷 개량과 라이브러리 구현이란 주제로
발표하게된

3
00:00:18,921 --> 00:00:21,976
플라네타리움 이도건이라고 합니다

4
00:00:22,000 --> 00:00:23,506
만나서 반갑습니다

5
00:00:24,640 --> 00:00:29,499
본격적으로 발표를 시작하기 전에
간단히 저의 소개를 하자면

6
00:00:29,524 --> 00:00:33,616
Github에서 Moreal라는 닉네임으로
활동하고 있고

7
00:00:33,640 --> 00:00:38,983
플라네타리움에서 오픈소스 소프트웨어
엔지니어로 개발하고 있습니다

8
00:00:39,996 --> 00:00:43,441
오픈소스 활동을 정말 좋아하는 사람 중 한 명입니다

9
00:00:44,440 --> 00:00:49,221
우선 직렬화 포맷 개량과을 하게 된
배경을 먼저 이야기하고자 합니다

10
00:00:50,080 --> 00:00:55,197
그 배경은 김재석님이 파이콘 2018에서 발표하신

11
00:00:55,298 --> 00:00:59,962
Nekoyume 파이썬으로 만든
블록체인 기반 롤플레잉 게임

12
00:00:59,987 --> 00:01:02,947
이라는 발표로 다시 거슬러 올라갑니다

13
00:01:04,060 --> 00:01:10,661
해당 발표에서 발표하셨던 Nekoyume라는
게임은 현재 다른 이름으로 계속 개발 진행 중인데요

14
00:01:12,610 --> 00:01:16,008
현재는 나인 크로니클이라는 이름으로 바꾸고

15
00:01:16,033 --> 00:01:19,978
Unity 기반의 블록체인 RPG 게임으로
만들어나가고 있습니다

16
00:01:20,800 --> 00:01:24,628
또한 이전과 다르게 Libplanet이라는
이름의

17
00:01:24,653 --> 00:01:27,557
블록체인 엔진을 만들어서 사용하고 있습니다

18
00:01:28,420 --> 00:01:33,177
Libplanet는 중앙서버 없이
게이머간에 P2P 통신을 통해

19
00:01:33,202 --> 00:01:37,741
게임 네트워크를 운영할 수 있는
네트워크 스토리지 라이브러리인데요

20
00:01:38,320 --> 00:01:44,749
P2P 네트워크에서 데이터 영속성과 
치트 방지 등을 제공해야 되다 보니

21
00:01:44,820 --> 00:01:47,437
블록체인 기술을 구현할 필요가 있었습니다

22
00:01:48,820 --> 00:01:54,312
그리고 Libplanet은 LGPL로 배포되는
100% 오픈소스 프로젝트이고요

23
00:01:56,800 --> 00:02:01,354
그리고 블록체인과 직렬화의 관계에 대해서
이야기해보고자 합니다

24
00:02:02,710 --> 00:02:09,249
블록체인에서는 안에서 다루는 거의 모든 데이터에
암호학적 해시와 디지털 서명을 사용합니다

25
00:02:10,300 --> 00:02:16,425
그리고 이러한 암호학적 해시나 디지털
서명에 입력으로 사용할 평문을 얻기 위해서

26
00:02:17,620 --> 00:02:22,245
직렬화를 하고 암호학적 해시와 디지털 서명의 결과는

27
00:02:22,270 --> 00:02:26,004
데이터의 무결성 검수하기 위한 용도로 사용됩니다

28
00:02:26,770 --> 00:02:30,660
그렇게 해시나 서명이 다를 경우

29
00:02:30,685 --> 00:02:34,156
입력이 동등하지 않다는 가정을 세울 수 있는데

30
00:02:34,180 --> 00:02:40,155
이 가정을 세울 수 없을 경우 항상 입력을 동봉하여
함께 들고 다녀야 하고

31
00:02:40,180 --> 00:02:44,416
계산을 줄이기 위해 사용하는 해시의
의미가 퇴색되기 때문에

32
00:02:44,440 --> 00:02:46,547
좋지 않은 결과를 얻을 것입니다

33
00:02:47,350 --> 00:02:53,056
이전 슬라이드에서 말한 가정을 지키기 위해

34
00:02:53,080 --> 00:02:56,396
블록체인에서 사용된 직렬화 포맷은
의미와 주변의 관계가 1:1일 필요가 있습니다

35
00:02:57,100 --> 00:03:00,490
예를 들면 설명하기 위해 블록체인에서 사용되는

36
00:03:00,515 --> 00:03:06,163
트랜잭션이라는 구조체의 필드와 값의
일부를 가져와 테이블로 띄워보왔습니다

37
00:03:07,150 --> 00:03:12,884
각각 "Nonce", "PublicKey", "Signer"
"Timestamp" 같은 피드들을 가지고 왔는데요

38
00:03:13,990 --> 00:03:17,818
이를 직렬화의 포맷 중 가장 널리 사용되는

39
00:03:17,843 --> 00:03:21,310
직렬화의 대명사 JSON으로 표현해 보았습니다

40
00:03:23,140 --> 00:03:29,926
이전 슬라이드의 테이블에 있던 필드와 값들을
모두 그대로 가져왔고

41
00:03:29,950 --> 00:03:34,559
보기 쉽게 indent를 넣고 순서 또한
동일하게 넣었습니다

42
00:03:35,770 --> 00:03:40,418
이렇게 직렬화 하였을 때 값을
sha1sum으로 해싱한 결과도

43
00:03:40,443 --> 00:03:42,684
아래에 같이 표기했습니다

44
00:03:46,430 --> 00:03:51,407
이 이야기 결론부터 얘기하자면 저희는 JSON을 택할 수 없었습니다

45
00:03:52,930 --> 00:03:59,750
그 이유는 JSON은 같은 의미를 위 방식과
다르게 표현할 수도 있기 때문입니다

46
00:04:01,995 --> 00:04:07,034
이번에도 역시 예로 들었던 트랜잭션에 필드와 값을

47
00:04:07,059 --> 00:04:09,503
JSON으로 표현해 보았습니다

48
00:04:11,020 --> 00:04:14,098
하지만 이번에는 순서를 조금 바꿔보았습니다

49
00:04:15,129 --> 00:04:18,402
필드와 값의 쌍을 그대로 놔둔 채 말이죠

50
00:04:20,080 --> 00:04:25,306
이렇게 표현한 JSON은 sha1sum으로
해싱하면 입력이 달라졌기 때문에

51
00:04:25,330 --> 00:04:29,525
이전 슬라이드에서는 다른 결과를
보여주는 것을 볼 수 있습니다

52
00:04:30,760 --> 00:04:33,541
마지막으로 한 가지 예를 더 들어보겠습니다

53
00:04:34,180 --> 00:04:39,856
이번에는 순서는 동일하게 하는 대신
탭, 스페이스 개행 문자와 같은

54
00:04:39,880 --> 00:04:42,320
White Space 문자를 모두 없애보았습니다

55
00:04:43,060 --> 00:04:47,950
이 또한 JSON문법에 맞는 표현 방식이고
해싱 또한 잘될 것입니다

56
00:04:48,640 --> 00:04:55,030
하지만 이 역시 입력이 달라졌기 때문에
sha1sum 해시가 달라지는 것을 볼 수 있었습니다

57
00:04:56,560 --> 00:05:00,802
저희가 원하는 과정, 해시와 서명이
다르면 입력도 다르다

58
00:05:01,090 --> 00:05:07,465
이를 만족하는 직렬화 포맷은 Bijection 
즉 전단 상수의 특성을 지닐 필요가 있었습니다

59
00:05:09,850 --> 00:05:12,928
이해를 돕기 위해 슬라이드에 이미지를 첨부 했는데요

60
00:05:14,200 --> 00:05:20,160
한 의미에 대해서 한 표현만 대응하는
그런 1:1 관계를 만족해야만 했습니다

61
00:05:22,030 --> 00:05:26,053
반면 JSON은 세 가지 예를 들어가며 살펴보았듯이

62
00:05:26,084 --> 00:05:29,982
한 의미에 대해서 여러 가지 방법으로
표현될 수 있었습니다

63
00:05:31,171 --> 00:05:37,687
다시 말해 슬라이드의 그림과 같이 한 의미에
대해서 N 개의 표현이 존재한다는 것이죠

64
00:05:39,405 --> 00:05:44,147
때문에 JSON은 직렬화 포맷으로
채용하기 어려웠습니다

65
00:05:45,700 --> 00:05:49,934
JSON 외에도 pickle, BSON, 
msgpack 과 같은

66
00:05:49,959 --> 00:05:52,879
다른 직렬화 포맷도 살펴봤지만

67
00:05:52,903 --> 00:05:56,067
모두 입력과 출력의 관계가 1:N이었습니다

68
00:05:57,070 --> 00:06:02,773
그 이유는 주로 dictionary에서 키 값의
순서를 스펙에서 정의 하지 않거나

69
00:06:03,040 --> 00:06:09,344
문자의 표현 방식 등을 제한하지 않아
여러 가지 형태로 표현될 수 있었기 때문입니다

70
00:06:10,232 --> 00:06:14,005
그래서 이전에 있던 다른 사람들은 어떻게 했을지

71
00:06:14,030 --> 00:06:20,319
Libplanet과 비슷한 문제를 푸는 프로젝트에는
무엇이 있을지 찾아보기로 했습니다

72
00:06:21,370 --> 00:06:25,205
그래서 잘 생각해보니 등잔 밑이 어둡다고

73
00:06:26,073 --> 00:06:29,432
우리가 많이 쓰고 있는 비트토렌트가 떠올랐습니다

74
00:06:30,940 --> 00:06:34,940
P2P 분산 네트워크 기술을 사용하고

75
00:06:35,572 --> 00:06:41,767
받을 파일이 같은 파일인지 아니면 
다른 파일인지를 해시를 이용해 체크하는 등

76
00:06:41,837 --> 00:06:48,407
목표는 다르지만 Libplanet과 많이 겹치는
문제들을 이미 푼 프로젝트였으니까요?

77
00:06:50,650 --> 00:06:56,923
비트토렌트는 bencode 혹은 bencoding이라고
불리는 직렬화 포맷을 사용했습니다

78
00:06:58,939 --> 00:07:00,992
비트토렌트에서 쓰기 위해서

79
00:07:01,017 --> 00:07:04,546
2001년에 함께 만들어졌던 직렬화 포맷이었고

80
00:07:04,570 --> 00:07:10,851
생긴 이유도 저희가 겪고 있는 문제와 같이
1:N 대응 때문에

81
00:07:10,913 --> 00:07:16,506
당시 많이 쓰이던 XML이나 pickle 같은
직렬화 포맷을 사용할 수 없었기 때문이었습니다

82
00:07:17,530 --> 00:07:23,566
비트토렌트는 토렌트 메타데이터를
직렬화 할때 bencode을 사용하여 직렬화 하고

83
00:07:23,590 --> 00:07:26,925
그 토렌트 파일을 해시하여 매그닛 주소로 사용합니다

84
00:07:27,850 --> 00:07:34,096
1∶1 대응이 되는 덕분에 같은 파일은
같은 토렌트 파일 및 매그닛 표현되어

85
00:07:34,120 --> 00:07:39,448
잘 겹치고 더 공유가 더 잘 되는 그런 장점을
가지게 되었지요

86
00:07:41,140 --> 00:07:46,546
자 Bencode 저희가 원하던 일대일대응이
되는 직렬화 포맷을 드디어 찾았습니다

87
00:07:47,050 --> 00:07:49,385
그래서 바로 사용하려고 하였으나

88
00:07:51,175 --> 00:07:52,423
Bencode는 아무래도

89
00:07:52,448 --> 00:07:56,846
비트트렌트와 함께 2001년에 만들어진
직렬화 포맷이였기 때문에

90
00:07:56,940 --> 00:07:59,151
실질적인 한계가 있었습니다

91
00:08:00,040 --> 00:08:03,227
우선 빈 값인 None을 지원하지 않았고

92
00:08:03,485 --> 00:08:07,727
TRUE나 FALSE 같은 불논리 값 또한
지원하지 않았습니다

93
00:08:09,820 --> 00:08:12,523
그리고 문자는 모두 바이트 배열이었고

94
00:08:12,547 --> 00:08:18,687
유니코드를 쓰기 위해서는 직접 알아서
인코딩해야 하는 그런 불편함이 있었습니다

95
00:08:21,580 --> 00:08:27,166
하지만 그냥 그렇게 된 것이 아니라 파이썬은
bool타임이 들어온 것이 2002년부터였고

96
00:08:27,190 --> 00:08:33,229
그때는 파이썬 3가 나오게 되기 전이었기 때문에
기본 문자열이 바이트 배열이였기 때문이었습니다

97
00:08:34,630 --> 00:08:39,950
이런 점들로 미루어 보았을 때 그것은 
정말 말 그대로 시대적 한계인 것이죠

98
00:08:41,050 --> 00:08:45,143
그래서 Bencode를 확장한 직렬화 포맷을
정의하기로 했습니다

99
00:08:46,030 --> 00:08:49,217
확장하였기 때문에 Bencodex라고
이름을 붙였고

100
00:08:49,242 --> 00:08:54,070
전 슬라이드에서 언급했던 Bencode의
시대적 한계를 해결하고자 하였습니다

101
00:08:55,330 --> 00:09:00,736
그리고 Bencode로 인코딩된 값을
Bencodex로도 디코딩할 수 있게

102
00:09:00,760 --> 00:09:02,970
하위 호완성도 지키고자 하였고요

103
00:09:04,870 --> 00:09:10,216
그리고 비트토렌트에서 첫 구현체를 파이썬으로 만들었던 것처럼

104
00:09:10,240 --> 00:09:14,747
파이썬으로 Bencodex의 첫 구현체를
만들어보기로 하겠습니다

105
00:09:15,520 --> 00:09:19,121
이 부분에서는 구현 특징에 대해 이야기하고

106
00:09:19,160 --> 00:09:22,696
그렇다면 Bencodex는 어떻게 1:1 대응을 보장하는지

107
00:09:22,720 --> 00:09:26,965
그리고 스펙, 구현, 테스팅과 활용 등에
대해서 이야기해보고자 합니다

108
00:09:27,370 --> 00:09:31,580
우선 다행히도 Bencodex의 모든 자료형은

109
00:09:31,605 --> 00:09:37,932
파이썬에서 None, bool, int, bytes,
list, dict 같은

110
00:09:38,120 --> 00:09:41,088
built-in 자료형들만으로도 구현이
가능했습니다

111
00:09:42,100 --> 00:09:45,404
슬라이드의 테이블로 정의해 놓은 것처럼 말이죠

112
00:09:46,870 --> 00:09:51,526
또한 파이썬에는 marshal, pickle,
json 등과 같이

113
00:09:51,550 --> 00:09:55,628
표준 라이브러리에 포함된 직렬화 모듈에서 사용되는

114
00:09:55,653 --> 00:09:59,457
사실상의 표준 de facto standard
interface 가 있습니다

115
00:10:00,790 --> 00:10:04,946
dump와 load 같은 method이름이
그런 것인데요

116
00:10:05,890 --> 00:10:10,335
그렇기 때문에 Bencodex 파이썬도
이를 따라 구현하였고

117
00:10:10,390 --> 00:10:15,171
사용자 입장에서 보다 친숙한 경험을
얻을 수 있을 것입니다

118
00:10:17,243 --> 00:10:21,610
또한 PEP 484의 type hint를 지원하고

119
00:10:21,635 --> 00:10:28,188
mypy type checker를 통해 runtime
이전에 오류를 방지할 수 있도록 하였습니다

120
00:10:30,340 --> 00:10:35,326
예를 들어 위와 같은 코드를 작성하고
mypy로 타입 검사를 하게 되면

121
00:10:35,350 --> 00:10:38,998
주석으로 달아놓은 것과 같은
에러 메세지와 함께

122
00:10:39,023 --> 00:10:42,115
잘못된 순서로 적었으면 사전에 알 수 있습니다

123
00:10:43,360 --> 00:10:46,805
만약 Type Hint 추구하지 않았다면
 이는 어려웠을 것이고

124
00:10:46,830 --> 00:10:50,539
runtime에 되어서야 실수를 알아챌 것입니다

125
00:10:51,610 --> 00:10:54,195
그리고 이런 type hint를 제공하면서

126
00:10:54,220 --> 00:10:57,563
타입 검사에서 파이썬 자료형 가운데

127
00:10:57,850 --> 00:11:02,279
Bencodex로 부호화 가능한 것들만
허용하는 type

128
00:11:02,304 --> 00:11:06,021
BValue를 만들어서 지원하려고 하였지만

129
00:11:06,076 --> 00:11:09,818
아쉽게도 실제로는 그냥 Any로 정리되어 있습니다

130
00:11:11,380 --> 00:11:16,020
그 이유는 Mypy에서 recursive 
type을 미지원하기 때문입니다

131
00:11:16,690 --> 00:11:20,783
BValue는 bool이나 int 같은
스칼라 값 외에도

132
00:11:20,808 --> 00:11:25,558
List나 dict 같은 복잡한 값도
포함하고 있습니다

133
00:11:26,320 --> 00:11:32,757
이를 타입으로 표현하면 슬라이드와 같이
sequence나 mapping의 type을 이용하여

134
00:11:32,920 --> 00:11:37,606
타입 정의 안에 BValue라는 type을
다시 사용할 수 있어야 합니다

135
00:11:37,630 --> 00:11:41,997
이렇게 정의하는 type 안에서 정의하려고 하는

136
00:11:42,022 --> 00:11:46,306
type을 체험할 수 있게 하는 것을 
recursive type이라고 하는데

137
00:11:46,330 --> 00:11:49,696
이것을 Mypy에서는 아직 미지원하고 있습니다

138
00:11:49,720 --> 00:11:53,204
그렇기 때문에 아쉽게도 Any로 남겨둘 수밖에 없었죠

139
00:11:54,310 --> 00:12:00,052
하지만 이 문제는 mypy repository에
있는 731번 이슈에서

140
00:12:01,030 --> 00:12:05,942
계속 status가 closed되지 않고
계속 이야기가 오가고 있으며

141
00:12:05,967 --> 00:12:09,740
그렇기 때문에 해결 가능성도 있다고 생각합니다.

142
00:12:10,540 --> 00:12:14,094
본 이슈가 해결이 되면 맨 처음 의도대로

143
00:12:14,125 --> 00:12:18,985
BValue 재정리해서 다시 릴리즈할 예정입니다

144
00:12:20,260 --> 00:12:25,010
그렇다면 Bencodex는 JSON과 
어떤 것이 다르기에

145
00:12:25,035 --> 00:12:27,886
입력과 출력의 관계에 있어서

146
00:12:27,910 --> 00:12:31,761
1:1 관계를 만족하는지에 대해서 얘기해보고자 합니다

147
00:12:32,980 --> 00:12:38,315
일단 Bencodex의 부모되는 Bencode가
그런 특징을 띠고 있는데요

148
00:12:39,040 --> 00:12:43,399
Bencode는 정규화 특징을 지닌
직렬화 포맷입니다

149
00:12:44,320 --> 00:12:51,030
여기서 말하는 정규화라는 것은 데이터들이
어떤 데이터, 한 데이터에 대해서

150
00:12:51,400 --> 00:12:55,439
오직 하나 만의 정규화된 결과를 가진다는 뜻입니다

151
00:12:57,190 --> 00:13:01,002
이것을 좀 더 예를 들면서 설명을 해보자면

152
00:13:01,027 --> 00:13:05,519
Bencodex는 사전 키 정렬 순서 정의합니다

153
00:13:06,972 --> 00:13:11,307
bytes와 string을 키로 사용할 수 있는데

154
00:13:11,480 --> 00:13:13,565
bytes를 먼저 앞에 오게 하고

155
00:13:13,840 --> 00:13:16,784
그 다음에 unicode string을
뒤에 오게 합니다

156
00:13:17,530 --> 00:13:21,092
그리고 bytes와 unicode string 끼리

157
00:13:21,117 --> 00:13:24,623
서로 각각 정렬 하도록 하죠

158
00:13:26,470 --> 00:13:31,563
그리고 정수를 표현할 때도 만약,
 정수 42를 표현한다고 가정을 해봅시다

159
00:13:32,227 --> 00:13:38,078
그러면 42 앞에 0을 붙여도 그것은
저희는 42라고 말할 수도 있고

160
00:13:38,740 --> 00:13:43,677
그냥 42, 4 2 두 글자만 적어도
저희는 42라는 것을 알 수 있습니다

161
00:13:44,650 --> 00:13:46,915
하지만 이것을 표기할 때

162
00:13:49,009 --> 00:13:52,485
무조건 앞에 0을 붙이지 못하고

163
00:13:52,510 --> 00:13:57,688
42 두 글자로만 표현해야 되는
그런 제약을 많이 걸어놓습니다

164
00:13:59,181 --> 00:14:05,478
이런 식으로 여러 가지 표현 방식을
하나로 정의해 놓왔기 때문에

165
00:14:06,340 --> 00:14:12,394
항상 같은 의미에 대해서는 같은 결과를
하나의 결과만을 얻을 수 있는 것이니까요

166
00:14:14,980 --> 00:14:22,925
그래서 Bencodex 파이썬에서 dictionary 
키를 정렬하는 부분 코트를 가져와 보았습니다

167
00:14:25,435 --> 00:14:29,326
본 슬라이드에 띄워놓은 코드가 그 코드인데요

168
00:14:29,350 --> 00:14:31,576
간단히 정렬하는 부분까지만 보자면

169
00:14:33,640 --> 00:14:37,006
해당 키가 unicode인지 아닌지를 검사해서

170
00:14:37,030 --> 00:14:42,264
그 flag를 dictionary에 있는
key-value for문 앞에

171
00:14:43,270 --> 00:14:48,160
하나 더 추가해서 세 개의 요소를 갖고 있는
tuple로 만듭니다

172
00:14:49,840 --> 00:14:52,769
그리고 그것을 sort하죠

173
00:14:54,910 --> 00:15:01,036
그랬을 때 앞에다가 unicode인지 아닌지
여부를 flag로 하나 더 달아놓았기 때문에

174
00:15:01,060 --> 00:15:04,778
자연스럽게 unicode string이 뒤로 가고

175
00:15:04,803 --> 00:15:09,091
그 다음에  bytes  string이 앞에오는
결과를 얻을 수 있을 것입니다

176
00:15:11,230 --> 00:15:15,595
그렇다면 이렇게 구현을 했을 때
bencodex 명세 적혀 있는

177
00:15:15,620 --> 00:15:18,643
그런 정규화된 그런 결과들을 제대로

178
00:15:18,668 --> 00:15:23,043
잘 인코딩하고 디코딩할 수 있는지에 대해서

179
00:15:24,214 --> 00:15:27,199
검사를 해보기 위해서 저희가 테스트를 짤 것입니다

180
00:15:28,390 --> 00:15:34,640
하지만 정확히 그 명세에 잘 따랐는지
검사하는 것은 사실 많이 힘든 일입니다

181
00:15:35,800 --> 00:15:41,716
그렇기 때문에 bencodex 명세가 포함된
repository에서는

182
00:15:41,740 --> 00:15:46,255
그것을 좀 더 쉽게 하기 위해서
test suite도 함께 제공합니다

183
00:15:47,710 --> 00:15:53,622
bencodex 스펙 repository에서는
본 스크린샷에서 볼 수 있듯이

184
00:15:53,647 --> 00:15:59,936
bencodex 명세서를 따라서 잘 구현했는지 여부를
확인할 수 있는 test suite를 함께 제공합니다

185
00:16:01,570 --> 00:16:06,655
bencodex 파이썬에서 테스트 코드를 작성할 때

186
00:16:06,687 --> 00:16:13,421
해당 test suite를 가셔와서 사용하는
코드를 일부분 가져와 봤습니다

187
00:16:14,920 --> 00:16:18,880
bencodex 파이썬 repository에
가보시면

188
00:16:19,779 --> 00:16:25,646
해당 스펙 repository를 submodule로 
받아서 사용하고 있는 것을 볼 수 있는데요

189
00:16:26,530 --> 00:16:29,866
그래서 그 안에 있는 test suite 디렉토리
하위에 있는

190
00:16:29,890 --> 00:16:32,132
방금 전 슬라이드에서 보았던

191
00:16:33,093 --> 00:16:40,569
기대되는 결과와 입력 값들을 해싱해서
테스트에 사용하는 코드입니다

192
00:16:41,980 --> 00:16:45,776
만약에 그렇게 작성된 테스트 코드들이 모두 잘 통과된다면

193
00:16:45,823 --> 00:16:51,112
bencodex 명세에 적혀 있던 내용들을
잘 구현했다는 이야기기때문에

194
00:16:51,158 --> 00:16:52,908
믿고 사용할 수 있을 것 같습니다

195
00:16:54,070 --> 00:16:57,898
지금까지 bencodex 명세에 따라서

196
00:16:57,929 --> 00:17:01,210
파이썬으로 구현해보는 이야기를 하였습니다

197
00:17:01,930 --> 00:17:04,758
하지만 이런 bencodex 구현체에는

198
00:17:04,783 --> 00:17:09,033
파이썬 말고도 C#으로 작성한 .NET 구현제가 있고

199
00:17:09,550 --> 00:17:12,526
그 다음에 TypeScript 구현체가 있고

200
00:17:12,636 --> 00:17:14,878
그 다음에 Haskell 구현체가 있습니다

201
00:17:15,849 --> 00:17:19,434
그리고 TypeScript 구현체를 이용해서 만든

202
00:17:20,677 --> 00:17:25,723
Bencodex 뷰어는 bencodex 웹 기반 
시각화 도구도 있습니다

203
00:17:26,800 --> 00:17:31,573
전 슬라이드에서 말씀드렸듯이 Haskell 구현체를 이용해서

204
00:17:31,604 --> 00:17:37,377
bencodex로 인코딩된 바이너리 파일을
웹브라우저에서도 볼 수 있게 해놨습니다

205
00:17:38,560 --> 00:17:43,388
그래서 실제 게임에서 운영 중인 블록체인 데이터

206
00:17:43,413 --> 00:17:47,178
혹은 상태 데이터를 볼 때 자주 사용하곤 합니다

207
00:17:48,700 --> 00:17:53,416
또한 이 프로젝트도 LGPL로 배포된
오픈소스 프로젝트이고

208
00:17:53,440 --> 00:17:56,393
이 발표를 듣고 관심 있으신 분들은

209
00:17:56,418 --> 00:18:00,275
디자인 개선이나 기능추 가 등에 기여하실 수도 있습니다

210
00:18:01,870 --> 00:18:05,393
또한 Github에서 Bencodex를 검색해보면

211
00:18:05,462 --> 00:18:09,049
관련된 구현체 및 프로젝트들을 확인해볼 수 있습니다

212
00:18:09,400 --> 00:18:12,829
하지만 참고로 이 중에서 세 번째로 나오는 프로젝트는

213
00:18:12,884 --> 00:18:16,337
Bencodex가 아닌 Bencoding과 
관련된 프로젝트입니다

214
00:18:16,384 --> 00:18:20,626
라이브러리 구현체들은 스펙을
관리하는 repository에서

215
00:18:20,650 --> 00:18:23,866
LIBRARIES.tsv 파일에서 관리하고 있습니다

216
00:18:23,890 --> 00:18:28,304
실제로 붙여서 사용할 수 있을지 찾아보려 할 때

217
00:18:28,329 --> 00:18:32,719
이전 슬라이드 같이 Github에서 검색해서
찾아볼 수도 있지만

218
00:18:33,340 --> 00:18:37,786
이렇게 한 파일에서 정리해 놓으면
찾기 더 수월 하니깐요

219
00:18:37,810 --> 00:18:42,196
취미로 사용하고 있는 언어로 구현해 보기에도
난이도도 그렇게 높지 않아서

220
00:18:42,220 --> 00:18:46,966
흥미가 생기시는 분들은 사이드 프로젝트로 만들어보시고

221
00:18:46,990 --> 00:18:51,904
스펙 repository에 PR로 업데이트해서
보내주셔도 될 것 같습니다

222
00:18:52,450 --> 00:18:54,942
지금까지 발표 들어주셔서 감사합니다

223
00:18:55,480 --> 00:18:59,237
이번 파이콘 발표는 사전 녹화로 진행됐기 때문에

224
00:18:59,269 --> 00:19:04,246
본 발표와 관련된 질문을 하시고 싶으신 분들께

225
00:19:04,270 --> 00:19:09,041
라이브로 바로 받기는 어려울 것 같아 제 트위터 계정이나 이메일

226
00:19:09,066 --> 00:19:13,756
혹은 플라네타리움 디스코드
developer채널에 놀러오셔서

227
00:19:13,780 --> 00:19:17,789
질문 남겨주시면 답변드리도록 하겠습니다

228
00:19:18,340 --> 00:19:19,340
감사합니다



