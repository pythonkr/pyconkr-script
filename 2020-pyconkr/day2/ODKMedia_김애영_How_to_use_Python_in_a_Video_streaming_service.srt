1
00:00:10,300 --> 00:00:14,773
안녕하세요
<스트리밍 서비스에서 파이썬 쓰는 법>이라는 주제로

2
00:00:14,798 --> 00:00:18,328
발표하게 된 ODK Media의 김애영입니다

3
00:00:19,330 --> 00:00:24,586
여러분은 스트리밍 서비스를 만들어야 된다
라고 하면 어떤 게 떠오르시나요?

4
00:00:24,610 --> 00:00:29,641
재생해줄 영상, 영상을 클릭하기 전에 보여줄 포스터

5
00:00:29,950 --> 00:00:33,653
여러가지 메타 정보들을 포함한 서비스 API

6
00:00:33,700 --> 00:00:40,306
그리고 결제가 필요하다면 결제 시스템,
당연히 스토리지 관리도 중요할 것이고

7
00:00:40,330 --> 00:00:47,759
보안 이슈라던지 버퍼링 이슈,
기타 에셋들이나 비디오를 재생해줄 플레이어

8
00:00:48,340 --> 00:00:53,394
그리고 광고, CDN 등 다양한 키워드들이 떠오르실텐데요

9
00:00:53,830 --> 00:00:58,033
실제로 저도 ODK Media에 입사하기 전에는 이런 키워드들이

10
00:00:58,058 --> 00:01:03,978
실제로 스트리밍 서비스에서 어떻게 구성되는지
궁금했던 기억이 있습니다

11
00:01:04,540 --> 00:01:09,496
스트리밍 서비스는 일반적인 웹서비스에 필요한 리소스 외에도

12
00:01:09,520 --> 00:01:12,657
특히 미디어와 관련된 작업들이 중요한데요

13
00:01:13,180 --> 00:01:18,398
오늘 발표에서는 각 파트들을 파이썬으로 어떻게 구성하고 있는지

14
00:01:18,730 --> 00:01:24,144
또 운영상 어떤 에피소드가 있었는지 간단히 공유 드리겠습니다

15
00:01:24,460 --> 00:01:29,202
일단 발표를 시작하기에 앞서서
스트리밍 서비스를 운영하고 있는

16
00:01:29,295 --> 00:01:33,586
ODK Media라는 회사에 대한 소개를 간단히 드릴텐데요

17
00:01:34,180 --> 00:01:38,312
ODK Media는 2011년에 시작되어서

18
00:01:38,337 --> 00:01:41,711
미국 LA 인근에 현재 본사를 두고 있고요

19
00:01:42,070 --> 00:01:46,359
한국, 중국, 베트남 콘텐츠를 북미 포함하여서

20
00:01:46,384 --> 00:01:49,726
전세계적으로 스트리밍하고 있는 서비스입니다

21
00:01:50,434 --> 00:01:56,254
본사는 미국에 있지만 엔지니어링 팀의
대부분은 한국 사무실에서 일을 하고 있고요

22
00:01:56,800 --> 00:01:59,620
또 오피스 간에 시차와 좀 있다 보니까

23
00:01:59,645 --> 00:02:03,768
저 개인적으로는 글로벌 기업에서 일하는 느낌도 사뭇 납니다

24
00:02:04,180 --> 00:02:06,719
영어도 주로 그래서 많이 쓰이고 있고요

25
00:02:07,180 --> 00:02:13,508
밑에 보여드렸다시피 저희가 지금 서비스 하는
서비스 이름이 세 가지 정도가 있는데요

26
00:02:13,720 --> 00:02:19,126
이 중에서 가장 오래된
그리고 ODK Media라는 이름에서 알 수 있듯이

27
00:02:19,150 --> 00:02:22,400
가장 먼저 시작됐던 온디맨드코리아는

28
00:02:22,425 --> 00:02:27,064
한국 TV 프로그램, 영화, 뉴스, K-POP 같은

29
00:02:27,089 --> 00:02:33,196
한국의 컨텐츠를 해외에 가장 빠른 속도로
업데이트해서 제공하는 스트리밍 서비스입니다

30
00:02:35,080 --> 00:02:41,150
웹이나 앱 뿐만 아니라 스마트TV와 같은
플랫폼에서도 서비스되고 있고요

31
00:02:42,380 --> 00:02:45,740
<여섯시 내 고향>, <놀면 뭐하니>

32
00:02:45,786 --> 00:02:49,726
그 외에 각종 뉴스라든지 주말 드라마까지

33
00:02:49,750 --> 00:02:55,796
한국 TV를 통해서 방송되는
대부분의 프로그램을 시청하실 수 있습니다

34
00:02:57,340 --> 00:03:01,488
안타까운 점은 대상 지역이 북미로 한정되어 있다 보니까

35
00:03:01,746 --> 00:03:04,402
한국에서는 서비스를 이용하실 수는 없고요

36
00:03:05,320 --> 00:03:10,609
그리고 온디맨드차이나
그리고 가장 최근에 오픈했던 온디맨드비엣

37
00:03:10,913 --> 00:03:13,459
역시 온디맨드코리아와 같은

38
00:03:13,484 --> 00:03:18,842
각 나라의 드라마, 예능 같은 콘텐츠를
제공하는 스트리밍 서비스입니다

39
00:03:19,420 --> 00:03:23,255
이외에도 온디맨드코리아 고객을 대상으로 하는

40
00:03:23,280 --> 00:03:30,904
온디맨드코리아샵, 테일러콘텐츠
그리고 잡지와 같은 서비스를 함께 운영하고 있습니다

41
00:03:31,330 --> 00:03:35,220
ODK Media의 개발팀에 대한 소개도 간단히 드릴텐데요

42
00:03:35,980 --> 00:03:41,175
앞에서 언급드렸다시피 서비스의 벡엔드 대부분이
파이썬으로 이루어진 만큼

43
00:03:41,470 --> 00:03:46,399
전체 개발팀의 42%를 파이썬 개발자가 구성하고 있고요

44
00:03:46,774 --> 00:03:50,914
코드 품질을 유지하기 위해서
여러가지 룰을 지키고 있습니다

45
00:03:51,370 --> 00:03:55,426
각 팀 내에서 활발하게 코드 리뷰를 진행하면서

46
00:03:55,450 --> 00:03:59,426
코드 품질을 향상시키고 또 테스트 작성을 통해

47
00:03:59,451 --> 00:04:02,676
테스트 커버리지를 높게 유지하고 있습니다

48
00:04:03,280 --> 00:04:07,740
ODK Media는 자유로운 원격 근무가 가능한 근무환경인데요

49
00:04:08,320 --> 00:04:12,038
현재는 COVID 이슈로 더 권장 드리고 있고

50
00:04:12,070 --> 00:04:16,132
그 이전부터도 풀 리모트 형태로의 근무가 가능했습니다

51
00:04:17,020 --> 00:04:20,824
발표자인 저도 COVID 이슈가 생기기 전인

52
00:04:20,849 --> 00:04:26,730
작년 11월부터 이미 원격 근무로
전환하여서 진행을 하고 있고요

53
00:04:27,850 --> 00:04:30,490
그리고 무제한으로 휴가 사용이 가능합니다

54
00:04:30,910 --> 00:04:34,245
진짜 말 그대로 무제한으로 사용이 가능합니다

55
00:04:34,600 --> 00:04:40,936
각자 컨디션에 맞게 혹은 사정에 맞게
필요한 만큼 휴가 사용이 가능합니다

56
00:04:40,960 --> 00:04:46,069
풀 리모트 환경을 증거로 제출하려고

57
00:04:46,690 --> 00:04:50,533
사무실 사진이라든지 이런 걸 좀 구해보고 싶었는데

58
00:04:51,010 --> 00:04:54,283
실제로 지금 모두가 다 리모트 중이셔가지고

59
00:04:54,308 --> 00:04:58,006
사무실 사진을 찍어주신 주실 직원분이 안 게셨어요

60
00:04:58,030 --> 00:05:01,178
그래서 이 짤로 대체를 합니다

61
00:05:01,256 --> 00:05:05,756
마지막으로 개발팀 내에
지식 공유도 활발히 이루어지고 있는데요

62
00:05:06,850 --> 00:05:13,366
파이콘에서도 매년 진행되고 있는
라이트닝 토크에서 아이디어를 얻어서

63
00:05:13,390 --> 00:05:19,408
"Lightning Talk in Engineering"
줄여서 LTE라는 이름의

64
00:05:19,508 --> 00:05:23,536
발표시간을 2주마다 한 번씩 가지고 있습니다

65
00:05:24,340 --> 00:05:30,436
또 팀 내에서 혹은 사내에서 필요에 의해
스터디를 만들어서 진행하기도 합니다

66
00:05:31,810 --> 00:05:38,986
앞에서 소개드렸던 Lightning Talk in Engineering
LTE는 작년 가을쯤 시작됐는데요

67
00:05:39,010 --> 00:05:43,783
여기 보이시는 게 최근에 진행했던
라이트닝 토크 주제들입니다

68
00:05:44,920 --> 00:05:48,826
개발과 관련된 주제가 아니어도 상관없기 때문에

69
00:05:48,865 --> 00:05:52,013
굉장히 다양한 주제들이 진행이 되고 있고

70
00:05:52,232 --> 00:05:56,317
보이시는 것 같이 뭐 <연금 101> 보이시죠

71
00:05:56,342 --> 00:05:58,560
연금과 관련된 내용도 있었고

72
00:05:59,080 --> 00:06:04,876
최근에는 <디지털 영상의 구조와 역사>와 같은
내용도 진행되고 있습니다

73
00:06:06,040 --> 00:06:08,926
아주 다채로운 주제들이 진행되고 있어서

74
00:06:08,950 --> 00:06:14,231
개발팀뿐만이 아니라 회사 전체로
진행 대상이 확대되고 있습니다

75
00:06:14,920 --> 00:06:19,216
이제 본격적으로 스트리밍 서비스의
각 파트너를 소개해 드릴게요

76
00:06:20,080 --> 00:06:25,276
스트리밍 서비스를 운영하고 있는
ODK Media의 서비스 구조를

77
00:06:25,300 --> 00:06:27,046
제가 좀 간략하게

78
00:06:27,070 --> 00:06:31,421
그리고 파이썬 사용처 위주로 재구성을 해봤는데요

79
00:06:31,900 --> 00:06:37,900
서비스를 구성하고 있는 파트들은 크게
서비스 백엔드 그리고 비디오 백엔드

80
00:06:38,380 --> 00:06:41,051
그리고 데이터 백엔드로 나눌 수 있습니다

81
00:06:42,280 --> 00:06:45,998
유저단과 가장 가까이 운영되는 서비스 파트와

82
00:06:46,023 --> 00:06:51,905
스트리밍 서비스에서 가장 중요한
미디어 에셋을 관리하는 비디오 파트

83
00:06:52,420 --> 00:06:56,068
그리고 서비스에서 수집된 데이터를 가공하여서

84
00:06:56,093 --> 00:07:00,576
새로운 사업 결정이나 기능 추가에
활용하는 데이터 파트입니다

85
00:07:02,920 --> 00:07:07,170
먼저 설명드릴 부분은 서비스 백엔드에 대한 부분인데요

86
00:07:07,780 --> 00:07:14,506
서비스 백엔드는 서비스 전체 필요한 여러 가지
비즈니스 조직과 관련된 기능을 담당합니다

87
00:07:15,310 --> 00:07:20,776
뒤에서 말씀드릴 비디오 파트를 통해
받아오는 비디오 관련된 정보

88
00:07:20,800 --> 00:07:26,120
그 외에 썸네일 링크라든지
추가적으로 필요한 메타 정보들이 있겠죠

89
00:07:26,740 --> 00:07:34,497
그리고 유저 정보, 유저의 시청기록과 같이
서비스 전반에 필요한 API를 제공하는 파트입니다

90
00:07:35,380 --> 00:07:38,637
또 CMS 파트를 위한 API도 제공하고요

91
00:07:40,090 --> 00:07:45,636
서비스 백엔드는 보시는 것과 같이
필요에 따라서 서비스가 나눠져 있는데요

92
00:07:46,060 --> 00:07:49,200
가장 코드 베이스가 큰 Service API와

93
00:07:50,599 --> 00:07:53,596
이와 별도의 도메인이라고 판단되었고

94
00:07:53,620 --> 00:07:59,909
또 배포 의존성을 줄이기 위해서 분리했던
결제 관련된 시스템 Billing API

95
00:08:00,430 --> 00:08:06,766
그리고 유저의 시청기록 정보를 기록하는
Watching history API가 있습니다

96
00:08:06,790 --> 00:08:12,430
유저가 해당 비디오를 어디까지 봤는지
이와 같은 것을 기록하는 곳이기 때문에

97
00:08:13,180 --> 00:08:16,789
유저가 시청을 하는 동안, 시청이 이루어지는 동안

98
00:08:16,814 --> 00:08:20,866
주기적으로 매 수 초마다 기록을 쌓기 때문에

99
00:08:20,890 --> 00:08:26,632
성능 이슈를 고려하여서 Waching history는
파이썬이 아닌 고로 짜여 있습니다

100
00:08:27,700 --> 00:08:31,856
참고로 파이썬을 사용하는 백엔드는
모두 Django로 되어 있고요

101
00:08:32,350 --> 00:08:38,342
이중에 이야기를 해볼 부분은
Service API와 Admin API 관련된 부분입니다

102
00:08:39,100 --> 00:08:43,654
태초에 ODK Media는
워드프레스로 시작됐던 비즈니스인데요

103
00:08:44,289 --> 00:08:50,664
블로그형 서비스인 워드프레스를 커스터마이징하면서
서비스 볼륨이 점점 커졌기 때문에

104
00:08:51,340 --> 00:08:58,300
워드프레스 기반으로 쌓여진 PHP 백엔드가
파이썬으로 포팅이 이뤄진 형태였습니다

105
00:08:58,930 --> 00:09:03,916
하지만 언어 포팅만 이루어지고
데이터베이스 스키마는 그대로였기 때문에

106
00:09:03,940 --> 00:09:07,768
백엔드 개발에 있어서 힘든 점도 있었는데요

107
00:09:08,470 --> 00:09:13,606
워드프레스는 보시는 것과 같이
블로그 포스팅을 위한 서비스이기 때문에

108
00:09:13,630 --> 00:09:16,348
데이터베이스 구조가 굉장히 단순합니다

109
00:09:17,980 --> 00:09:22,558
이 구조 자체에 스트리밍 서비스와 관련된
모델을 담다 보니까

110
00:09:22,583 --> 00:09:25,186
자연스럽지 못한 부분들이 있었죠

111
00:09:25,210 --> 00:09:28,874
블로그에서 글에 해당하는 포스트 모델의

112
00:09:28,899 --> 00:09:33,022
프로그램의 정보나
프로그램이 가지고 있는 에피소드 정보

113
00:09:33,310 --> 00:09:37,091
그리고 에피소드에 출연한 출연진들 정보까지

114
00:09:37,116 --> 00:09:42,755
한 테이블에 담게 되면서
보시는 것과 같은 데이터 구조를 가지게 되었습니다

115
00:09:43,780 --> 00:09:46,522
그리고 예상하시겠지만 이런 데이터 구조는

116
00:09:46,547 --> 00:09:51,678
코드단에서도 좀 자연스럽지는 않은 흐름을
가지고 가게 되었는데요

117
00:09:53,290 --> 00:09:56,875
각각 다른 성질의 데이터가 한 테이블에 있다 보니까

118
00:09:56,900 --> 00:09:59,969
실행단에서 항상 어떤 타입의 데이터인지

119
00:09:59,993 --> 00:10:03,727
체크하고 변형해야 한다든지 하는 문제가 있었습니다

120
00:10:05,710 --> 00:10:09,936
레거시에 익숙한 개발자가 아니면
좀 이해하기 힘든 고민이기도 했죠

121
00:10:10,870 --> 00:10:13,432
그래서 새로 만들기도 했습니다

122
00:10:13,960 --> 00:10:19,772
새로운 코드로 새로운 스키마와 함께
아예 새로운 백엔드를 구성하기로 했는데요

123
00:10:20,230 --> 00:10:23,644
이 시점에서는 개발 쪽 요소뿐만 아니라

124
00:10:23,972 --> 00:10:27,854
사업적 요소도 같이 고려해서 진행이 됐습니다

125
00:10:28,540 --> 00:10:33,256
당시 ODK Media는 한국 콘텐츠를 서비스하는 ODK

126
00:10:33,280 --> 00:10:40,126
그리고 중국 컨텐츠를 서비스하는 ODC
외에도 또 다른 문화권의 콘텐츠를 서비스하고자

127
00:10:40,150 --> 00:10:42,884
사업 확장을 꾀하고 있던 시기인데요

128
00:10:43,600 --> 00:10:47,803
그러니까 저희는 앞으로도 더 여러 가지의 도메인을 가진

129
00:10:47,828 --> 00:10:51,765
비슷한 서비스를 운영해야 한다는 점을 고려해야 했습니다

130
00:10:52,420 --> 00:10:56,529
저희가 생각하기에 선택지라 할 만한 것들은
이런 게 있었는데요

131
00:10:57,250 --> 00:11:00,562
흔히 비디오 스트리밍 서비스라고 말하면

132
00:11:00,587 --> 00:11:05,266
가장 먼저 떠올릴 만한
넷플릭스나 유튜브와 같은 서비스는

133
00:11:05,290 --> 00:11:09,141
글로벌 고객을 대상으로 하지만
하나의 서비스를 운영하죠

134
00:11:09,850 --> 00:11:14,107
그리고 같은 역할을 하는 백엔드는
하나의 소스일 겁니다

135
00:11:15,670 --> 00:11:21,302
그리고 현재 ODK Media는
각 서비스에 따라 백엔드가 분리되어 있는데요

136
00:11:21,760 --> 00:11:25,713
ODC를 위한 백엔드 하나
ODK를 위한 백엔드 하나

137
00:11:25,738 --> 00:11:27,635
이런 식으로 운영을 하고 있고

138
00:11:27,931 --> 00:11:32,266
아주 비슷한 역할을 하지만
서비스에 따라 분리되어 있었습니다

139
00:11:33,730 --> 00:11:37,995
그러나 앞에서 말씀드렸듯이
이 서비스들이 확장됨에 따라

140
00:11:38,020 --> 00:11:41,128
점점 백엔드는 복제되기 시작할 것이고

141
00:11:41,500 --> 00:11:46,632
이는 한정된 개발팀의 인원으로는
감당하기 힘들겠다는 생각을 했습니다

142
00:11:47,020 --> 00:11:52,832
그래서 세 번째 선택지인
멀티서비스형 단일 백엔드를 구성하기로 했습니다

143
00:11:54,160 --> 00:11:59,386
종합적으로 개발과 관련된 니즈와
사업과 관련된 니즈를 합쳐봤을 때

144
00:11:59,710 --> 00:12:02,764
이런 정도의 목표면 좋겠다고 생각을 했는데요

145
00:12:03,580 --> 00:12:06,353
서비스별로 조금씩 다른 기능이나

146
00:12:06,378 --> 00:12:11,283
서비스가 지원될 수 있어야 하기 때문에
기능 추가에 유연할 것

147
00:12:11,800 --> 00:12:16,331
그리고 모두가 참여할 수 있을 정도로
낮은 진입장벽을 가질 것

148
00:12:16,781 --> 00:12:22,390
재사용성에 용이하고 기술 부채를
방어할 수 있도록 짤 것 정도였습니다

149
00:12:23,230 --> 00:12:26,167
그래서 저희가 마이그레이션을 실제로 할 때

150
00:12:26,192 --> 00:12:31,308
첫 번째로 세웠던 원칙은
파이썬을 파이써닉하게 짜는 것이었습니다

151
00:12:32,110 --> 00:12:38,116
알고 계시는 PEP나
파이썬 Django 가이드에서 권장하는 문법과 같이

152
00:12:38,140 --> 00:12:44,515
기본에 충실한 코드를 짜는 게 보다 파이썬스러운
코드를 짤 수 있는 방법이라고 생각했습니다

153
00:12:45,370 --> 00:12:49,756
또 기존 코드가 파이썬으로 짜여져 있기는 했지만

154
00:12:49,780 --> 00:12:53,506
포팅 당시 시간적 여유가 많지 않았기 때문에

155
00:12:53,531 --> 00:12:57,233
많은 리팩토링을 거치지 못한 코드였고

156
00:12:57,430 --> 00:13:01,890
새로운 백엔드에서는
이런 부분들을 처음부터 해소할 수 있도록

157
00:13:01,915 --> 00:13:05,617
좀 책임 구조를 단순하게 가져가려고 했습니다

158
00:13:07,180 --> 00:13:11,416
그리고 서비스 백엔드는
모두 REST API로 구성되어 있기 때문에

159
00:13:11,440 --> 00:13:14,611
DRF를 자연스럽게 선택하게 됐습니다

160
00:13:15,580 --> 00:13:21,431
그리고 DRF 역시 기본에 충실한 코드를
짜자는 것이 첫 번째 원칙이었습니다

161
00:13:23,020 --> 00:13:29,402
Django REST Framework가 제공하는
바퀴가 꽤 많은데 그런 바퀴들을 최대한 활용해서

162
00:13:29,560 --> 00:13:35,520
즉 준비된 모듈을 통해서
적은 코드로 많은 기능을 구현하고자 했습니다

163
00:13:37,510 --> 00:13:40,728
미리 정의되어 있는 모델과 시리얼라이저

164
00:13:40,753 --> 00:13:45,744
그리고 뷰셋을 통해
적은 노력으로 API 구성이 가능해지도록 해야

165
00:13:46,017 --> 00:13:48,915
비슷한 기능을 여러 서비스에 제공해야 할 때

166
00:13:48,940 --> 00:13:52,571
개발 효율성을 올릴 수 있겠다는 판단에서 였습니다

167
00:13:53,050 --> 00:13:56,784
마지막으로는 테스트 작성에 신경을 많이 썼습니다

168
00:13:57,460 --> 00:14:02,608
현재 서비스 백엔드의 테스트 커버리지는
96%를 유지하고 있고요

169
00:14:03,136 --> 00:14:09,425
테스트 커버리지는 안정적인 리팩토링이나
배포를 위해서 필요하다고 생각했고

170
00:14:10,000 --> 00:14:14,242
현재는 신규로 작성된 코드인데 테스트가 없을 경우

171
00:14:14,267 --> 00:14:17,265
CI 자체에서 Failure 알람을 주기도 합니다

172
00:14:18,220 --> 00:14:21,829
또 개발팀 내부에서의 테스트 코드 활성화를 위해

173
00:14:22,240 --> 00:14:27,568
앞에서 소개드렸던 라이트닝 토크에서
테스트 관련된 내용을 진행하기도 했고요

174
00:14:28,150 --> 00:14:30,829
서비스 백엔드에 기여하는 누구라도

175
00:14:30,854 --> 00:14:37,400
테스트 코드 작성까지의 과정이 자연스러울 수 있도록
하는 의미에서 진행했습니다

176
00:14:37,810 --> 00:14:41,005
이렇게 마이그레이션이 잘 이루어지면

177
00:14:41,294 --> 00:14:44,419
이 오른쪽과 같은 형태가 되는 건데요

178
00:14:45,250 --> 00:14:49,289
이 마이그레이션 작업은
현재 진행 중인 프로젝트이기 때문에

179
00:14:49,314 --> 00:14:53,132
최종적으로 저희가 그리고 있는
서비스 백엔드의 모습입니다

180
00:14:53,650 --> 00:14:57,039
같은 리소스와 같은 코드 베이스를 이용하고

181
00:14:57,064 --> 00:15:02,681
각각의 서비스에 필요한 API만
나눠서 제공하는 형태로 바뀌게 됩니다

182
00:15:03,820 --> 00:15:07,648
이 작업이 완료되려면 기존에 분리되어 있던

183
00:15:07,673 --> 00:15:10,843
ODK와 ODC가 나눠가지고 있는 유저

184
00:15:11,023 --> 00:15:16,156
그리고 콘텐츠와 같은 데이터의 마이그레이션이
현재 먼저 진행되어야겠죠

185
00:15:16,180 --> 00:15:17,437
진행되고 있고요

186
00:15:17,920 --> 00:15:21,045
이렇게 최종적인 형태를 갖추게 되면

187
00:15:21,107 --> 00:15:25,912
ODK나 ODC에 공통적으로
제공하고 싶은 영상 콘텐츠가 있을 때

188
00:15:26,530 --> 00:15:30,069
나눠서 관리하지 않아도 된다는 이점이 생깁니다

189
00:15:32,560 --> 00:15:38,067
여기까지 서비스 백엔드에 대해서
저희가 어떻게 현재 백엔드 모습을 갖추고 있는지

190
00:15:38,260 --> 00:15:39,794
설명을 드렸고요

191
00:15:40,120 --> 00:15:44,588
다음은 비디오 백엔드에 대한 이야기입니다

192
00:15:45,880 --> 00:15:49,630
스트리밍 서비스 콘텐츠의 핵심인 비디오 파트인데요

193
00:15:50,080 --> 00:15:55,606
비디오 파트는 외부에서 가져온
비디오 데이터를 변환하고 쪼개어서

194
00:15:55,630 --> 00:15:59,122
스토리지에 보관하는 트랜스코더 파이프라인과

195
00:15:59,650 --> 00:16:03,962
외부에 서비스되기 위한
Video API를 운영하고 있습니다

196
00:16:05,080 --> 00:16:08,158
파이프라인 구조에 대한 설명을 드리기 전에

197
00:16:08,183 --> 00:16:11,751
간단히 콘텐츠 수급과정에 대한 설명을 드릴 텐데요

198
00:16:12,640 --> 00:16:17,982
먼저 ODK Media는
실제로 라이브 중인 방송이 종료되면

199
00:16:18,007 --> 00:16:21,655
최대한 곧바로 서비스하는 것을 목표로 하고 있습니다

200
00:16:23,050 --> 00:16:26,096
그런데 실제로 라이브되는 방송화면은

201
00:16:26,121 --> 00:16:30,487
속보 배너라든지
다음 프로그램을 안내하는 아이콘과 같은

202
00:16:30,480 --> 00:16:33,042
추가적인 오버레이가 붙어 있기도 하고

203
00:16:33,370 --> 00:16:35,002
또 방송사 자체에서

204
00:16:35,027 --> 00:16:40,366
특정 분량을 편집하고 보내줘야 하는 경우가 있어서

205
00:16:40,390 --> 00:16:43,733
방송이 송출된 후에 수정과정이 좀 필요한데요

206
00:16:44,260 --> 00:16:50,002
이 과정을 지금 파이프라인에서는
Post-editing이라는 이름으로 그려놨고요

207
00:16:50,620 --> 00:16:55,916
그러다 보니 저희가 원하는 만큼 빠른 시간 내에는
전달하기가 힘들 때가 있습니다

208
00:16:57,220 --> 00:17:02,476
이를 위해서 저희는 Unedited
즉 수정 과정이 진행되지 않은

209
00:17:02,500 --> 00:17:05,176
버전을 먼저 서비스에 오픈하고

210
00:17:05,200 --> 00:17:11,575
추후에 전달받은 수정본을 교체하는 방식으로
이렇게 서비스를 운영하고 있습니다

211
00:17:15,130 --> 00:17:21,637
이렇게 수급 받아진 콘텐츠는 
내부 파이프라인을 통해서 변환작업을 거치게 됩니다

212
00:17:21,940 --> 00:17:24,885
트랜스코더라고 부르는 파이프라인을 따라서

213
00:17:24,910 --> 00:17:30,555
비디오 데이터와 서비스의 화질이
여러 개로 서비스되기 때문에

214
00:17:30,579 --> 00:17:34,836
각 화질 별로 변환을 하고
세그멘테이션

215
00:17:34,861 --> 00:17:39,250
즉 분할 과정을 거쳐서 스토리지에 저장이 되는데요

216
00:17:40,450 --> 00:17:44,950
여기서 말하는 세그멘테이션
즉 분할 과정이 왜 필요한지

217
00:17:44,975 --> 00:17:47,965
궁금하신 분들이 계실 거라고 생각됩니다

218
00:17:48,820 --> 00:17:52,890
HLS이라는 라이브 스트리밍 프로토콜 때문인데요

219
00:17:53,350 --> 00:18:00,370
애플에서 내놓은 프로토콜이고 스트리밍 데이터를
시간 단위로 잘게 쪼개서 전송하는 방식입니다

220
00:18:00,550 --> 00:18:04,104
즉 1기가짜리 비디오를 그대로 전송하는 게 아니라

221
00:18:04,750 --> 00:18:08,562
한 9조에서 10초짜리로
아주 짧은 클립으로 쪼개어서

222
00:18:08,587 --> 00:18:11,296
연속적으로 재생이 되는 형태입니다

223
00:18:12,010 --> 00:18:17,017
아마 스트리밍 서비스 네트워크 탭을 열어보시면

224
00:18:17,042 --> 00:18:21,642
가장 먼저 보이는 파일 포맷이 m3u8 포맷일 텐데요

225
00:18:21,910 --> 00:18:27,878
m3u8이 하는 역할은 재생해야 할
ts 파일들의 리스트를 가지고 있습니다

226
00:18:28,210 --> 00:18:33,444
그래서 m3u8을 통해서 ts 파일들의 정보를 얻고

227
00:18:33,970 --> 00:18:37,477
그 다음 ts 파일들을 하나씩 순서대로

228
00:18:37,502 --> 00:18:42,563
받아와서 재생시키는 형태로 스트리밍이 진행됩니다

229
00:18:43,660 --> 00:18:48,324
그래서 여기서 말하는 ts 파일들과 같이
잘게 쪼갠 클립들을

230
00:18:48,820 --> 00:18:52,773
쪼개야 하는 과정이
세그멘테이션 과정이라고 할 수 있습니다

231
00:18:53,320 --> 00:18:56,577
각 파트별로 좀 더 자세히 살펴보면

232
00:18:56,602 --> 00:19:00,280
트랜스코더는 파이프라인 구축을 위해 사용되는 도구로

233
00:19:00,289 --> 00:19:02,554
당연히 파이썬으로 구현이 되어 있고요

234
00:19:03,550 --> 00:19:08,964
파이썬의 파이프라인 구축 모듈로
Luigi라는 모듈이 있는데요

235
00:19:09,430 --> 00:19:13,953
이 Luigi의 모듈의 구조를 참고하여서
구현이 되었습니다

236
00:19:14,350 --> 00:19:17,217
그래서 트랜스코더의 일정 부분은

237
00:19:17,242 --> 00:19:22,342
2017년 파이콘 한국의 라이트닝 토크에서
소개된 적이 있고요

238
00:19:22,840 --> 00:19:27,707
궁금하신 분들은 이 발표 자료의 링크 통해서
한 번 보셔도 좋을 것 같습니다

239
00:19:28,150 --> 00:19:31,876
혹시 안 보실 것 같아서
그냥 간단히 제가 이미지를 첨부했고요

240
00:19:31,900 --> 00:19:37,548
라이트닝 토크에서 어떻게 구현되었는지
소개되었던 모습입니다

241
00:19:38,110 --> 00:19:43,492
발표하시는 분은 현재 비디오 파트의 팀장님이시고요
허락 받고 사용했습니다

242
00:19:43,899 --> 00:19:46,634
라이트닝 토크에서도 언급이 되듯이

243
00:19:46,665 --> 00:19:49,384
비디오 관련 도메인이 로우 레벨로 갈수록

244
00:19:49,392 --> 00:19:52,454
굉장히 복잡하고 어려운 부분이 많다 보니까

245
00:19:53,080 --> 00:19:55,548
이를 최대한 파이썬으로 랩핑해서

246
00:19:55,573 --> 00:19:58,275
누구든지 파이프라인 구축이나

247
00:19:58,300 --> 00:20:02,658
유지 보수에 참여할 수 있도록
의도하며 구현이 되었고요

248
00:20:03,730 --> 00:20:07,409
이 트랜스코더 자체에 대한
구조 설명을 간단히 드릴게요

249
00:20:07,870 --> 00:20:12,229
트랜스코더의 구조는 간단히 살펴보면
이런 식으로 동작합니다

250
00:20:13,030 --> 00:20:17,662
영상 하나를 1080 화질로 변환되어야 하는
Job을 등록하면

251
00:20:18,070 --> 00:20:24,609
그 Job이 등록되는 과정에서 Requires에 있는
Job이 하나씩 알아서 생성이 되게 됩니다

252
00:20:25,000 --> 00:20:29,367
여기서 Requires라는 건
선행되어야 하는 작업을 의미하고요

253
00:20:30,265 --> 00:20:34,335
그래서 흐름상으로는
각 태스크가 가지고 있는 선행작업

254
00:20:34,382 --> 00:20:37,452
즉 Requires에 있는 Job이 먼저 실행되고

255
00:20:37,477 --> 00:20:40,655
나중에 본래의 Job이 실행되는 구조입니다

256
00:20:41,440 --> 00:20:45,256
그렇게 태스크 간의 관계를 태스크가 관리하게 되면

257
00:20:45,280 --> 00:20:50,746
예외 처리라든지 각종 처리가
각 태스크 안에서 이뤄지기 때문에

258
00:20:50,770 --> 00:20:53,942
독립적이고 전체 파이프라인의 흐름을

259
00:20:53,967 --> 00:20:57,842
맨 앞에 있는 Post Job이
신경쓰지 않아도 되기 때문에

260
00:20:57,912 --> 00:21:00,646
코드 작성 시에도 원하는 Job만으로도

261
00:21:00,671 --> 00:21:04,513
파이프라인을 걸 수 있는 간편함이 있습니다

262
00:21:04,960 --> 00:21:10,639
Post Job과 Pre Job이 어떻게 동작하는지를
코드로 간단히 구현해 봤는데요

263
00:21:10,930 --> 00:21:15,484
Luigi를 쓰시는 분들이라면
익숙하실 코드일 수도 있습니다

264
00:21:15,911 --> 00:21:19,542
앞에서 보여드렸듯
Post Job과 Pre Job이 있을 때

265
00:21:19,567 --> 00:21:24,723
각 Job이 실행되기 전
먼저 실행되어야 하는 Job을 requires에 적고

266
00:21:25,330 --> 00:21:28,986
각 Job이 실행해야 하는 일을
command에 적습니다

267
00:21:30,190 --> 00:21:34,979
그리고 Pre Job의 경우 중복 체크를 위한
데코레이터가 들어 있는데요

268
00:21:35,680 --> 00:21:39,508
영상 변환이 모두 병렬로 처리되다 보니까

269
00:21:39,533 --> 00:21:44,914
각 영상별로 똑같은 작업을 하는 Pre Job이
등록될 때가 있거든요

270
00:21:45,370 --> 00:21:51,221
그런 경우 불필요하게 여러 번 실행되지 않도록
방지하기 위함입니다

271
00:21:54,580 --> 00:22:01,626
예시를 들어드리면 영상이 서비스에서 서빙되는
화질별로 변환이 됐을 때

272
00:22:01,870 --> 00:22:07,726
그러니까 똑같은 소스 영상을 가지고
각각의 화질로 변환을 하려고 했을 때

273
00:22:07,750 --> 00:22:13,575
이 Pre Job의 Pre-Pre Job은
해당 영상이 변환이 가능한지

274
00:22:13,600 --> 00:22:18,256
깨지지는 않았는지와 같은 검증 작업이
가장 먼저인데요

275
00:22:18,280 --> 00:22:23,545
그 검증 작업은 사실상 소스가 되는 영상을
검증하는 것이기 때문에

276
00:22:23,858 --> 00:22:28,045
화질별로 나눠졌을 때
Pre-Pre Job이 하는 역할은 동일합니다

277
00:22:28,450 --> 00:22:31,317
같은 소스에 대해 검증을 하는 거죠

278
00:22:31,870 --> 00:22:36,291
이 경우의 같은 Job을 여러 번 실행하지 않고

279
00:22:36,580 --> 00:22:39,626
해당 duplicate 데코레이터를 통해서

280
00:22:39,651 --> 00:22:43,478
한 번만 실행되도록 하는 작업을 하게 됩니다

281
00:22:43,595 --> 00:22:47,141
그러면 보시는 것과 같이 영상 검증이 완료되면

282
00:22:47,166 --> 00:22:50,866
각 화질별로 변환 작업이 완료되고

283
00:22:50,891 --> 00:22:52,938
그 후의 Job이 쭉 실행되겠죠

284
00:22:54,340 --> 00:22:58,363
그리고 아까 파이프라인에서 보셨던
트랜스코더 작업이 끝나면

285
00:22:58,388 --> 00:23:04,066
서비스에 직접 제공되는
Video API가 있는데요

286
00:23:04,090 --> 00:23:08,043
Video API 역시
Django REST Framework 기반으로 되어 있고요

287
00:23:08,791 --> 00:23:12,393
비디오 파이프라인 현황 조회나 내부 고객

288
00:23:12,425 --> 00:23:15,676
즉 가공이 완료된 콘텐츠를 가지고

289
00:23:15,700 --> 00:23:19,067
서비스 메타를 제작하는 직원 분들을 위한

290
00:23:19,092 --> 00:23:23,332
영상 에셋 조회 기능이나
관리 기능을 제공하고 있습니다

291
00:23:24,190 --> 00:23:27,946
여기까지 비디오 파트에 대한 설명을 드렸고요

292
00:23:27,970 --> 00:23:33,436
다음은 마지막인 데이터 파트에 대한 소개입니다

293
00:23:33,460 --> 00:23:38,280
서비스 파트와 비디오 파트에서
서비스 운영에 필요한 데이터를 제공하고

294
00:23:38,620 --> 00:23:42,893
유저가 서비스를 이용하게 되면
여러 가지 로그들이 쌓이게 되죠

295
00:23:43,390 --> 00:23:47,499
이 쌓여진 로그를 이용해서 새로운 인사이트를 얻고

296
00:23:47,524 --> 00:23:51,929
합리적인 의사결정을 만들어내기 위한 파트라고
보시면 될 것 같습니다

297
00:23:52,960 --> 00:23:57,405
데이터 파트는 단순히 데이터를 수집하는 일만
진행하는 것은 아니고

298
00:23:57,700 --> 00:24:01,981
어떤 데이터를 수집할지
즉 이벤트 정의 단계부터

299
00:24:02,006 --> 00:24:07,301
이벤트 수집 그리고 머신 러닝 프로젝트까지
다양한 일들을 진행하고 있습니다

300
00:24:08,050 --> 00:24:12,448
역시 데이터 쪽도 파이프라인에 대한 얘기를 하기 전에

301
00:24:12,473 --> 00:24:17,315
스트리밍 서비스에서 다루는 데이터에 대해서
간단히 살펴볼 텐데요

302
00:24:17,346 --> 00:24:23,510
여러분들이 생각하시기에는
스트리밍 서비스에서 일반적인 웹서비스와 달리

303
00:24:23,877 --> 00:24:27,205
어떤 데이터들을 더 추가로 다룰 것 같으신가요?

304
00:24:28,687 --> 00:24:35,695
대답을 들을 수는 없지만
일단 대답해주시기를 기다려보겠습니다

305
00:24:36,850 --> 00:24:42,946
네 대부분 다 짐작하셨겠지만
당연히 스트리밍 서비스 답게

306
00:24:42,970 --> 00:24:46,485
비디오와 관련된 로그들이 추가로 수집이 되는데요

307
00:24:47,110 --> 00:24:51,735
저희가 서비스하고 있는 비디오의 뷰 아워라고 하는

308
00:24:51,760 --> 00:24:57,766
시청시간 뭐 비디오별 시청시간일 수도 있고
유저별 혹은 카테고리별

309
00:24:57,790 --> 00:25:01,375
여러가지 분류에 따른 시청 시간 데이터를 수집하고

310
00:25:02,770 --> 00:25:06,230
자막 재생과 관련된 이벤트 로그도 수집합니다

311
00:25:06,645 --> 00:25:11,626
어떠한 자막을 켰는지 그리고 언제 켰는지와 같이

312
00:25:11,650 --> 00:25:14,501
여러 가지 이벤트로 로그들을 수집하고

313
00:25:14,800 --> 00:25:18,331
그 외에도 여러 가지 시청과 관련된 부분들

314
00:25:18,604 --> 00:25:23,243
예를 들면 10초 앞으로 가기
혹은 배속 이벤트

315
00:25:23,268 --> 00:25:25,947
저희는 배속 재생이 가능하기 때문에

316
00:25:25,972 --> 00:25:30,955
배속 이벤트가 언제 이루어졌는지
같은 로그들도 수집합니다

317
00:25:31,600 --> 00:25:37,428
그리고 영상이 재생되던 중
버퍼링이 발생하면 그 로그도 기록합니다

318
00:25:38,950 --> 00:25:44,386
이렇게 일반적인 웹서비스에서 수집하는
유저나 서비스 관련된 데이터 외에도

319
00:25:44,410 --> 00:25:48,777
비디오 로그가 추가적으로 수집이 됩니다

320
00:25:52,331 --> 00:25:56,266
이렇게 다양한 소스에서 데이터가 모이게 되고

321
00:25:56,290 --> 00:26:00,526
보시는 것과 같이 일단 데이터 소스가 다양하죠

322
00:26:00,550 --> 00:26:05,253
서비스 단에서 올 때도 있고
GA나 파이어베이스와 같이

323
00:26:05,370 --> 00:26:07,917
수집 툴에서 모이는 로그도 있습니다

324
00:26:08,710 --> 00:26:11,639
그리고 빌링 결제단에서

325
00:26:11,664 --> 00:26:14,999
혹은 CDN 로그도 수집이 되는데요

326
00:26:15,310 --> 00:26:17,692
이렇게 수집된 데이터들은

327
00:26:17,731 --> 00:26:21,958
유저의 서비스 이용 현황이나
여러 가지 데이터 분석 외에도

328
00:26:22,750 --> 00:26:26,539
CDN 사용 정도를 파악하거나 이상치 파악

329
00:26:26,577 --> 00:26:30,453
너무 비정상적으로 사용되고 있는 건 없는지와

330
00:26:30,478 --> 00:26:33,867
같이 모니터링을 위한 용도로도 쓰이고 있습니다

331
00:26:36,790 --> 00:26:41,243
데이터 수집은 수집 단계부터 익스트렉트 단계부터

332
00:26:41,268 --> 00:26:45,032
각 소스에 맞춰서 익스트렉트 단계가 나뉠 것이고요

333
00:26:45,520 --> 00:26:51,796
그 다음에는 포맷에 맞춰서 변환하는 작업
트랜스폼 단계가 필요하고

334
00:26:51,820 --> 00:26:54,488
그 후 저장되어 사용됩니다

335
00:26:54,940 --> 00:26:57,736
저희는 BigQuery에 저장을 하고 있고요

336
00:26:58,300 --> 00:27:03,995
그 저장된 데이터는 Tableau와 같은
분석 툴에서 쓰이거나

337
00:27:04,390 --> 00:27:07,358
머신러닝 프로젝트에 응용이 되기도 합니다

338
00:27:07,750 --> 00:27:12,109
이런 데이터 파이프라인은
Luigi를 통해서 구축이 되어 있는데요

339
00:27:12,520 --> 00:27:16,277
Luigi는 앞에서 소개드렸던 비디오 파이프라인

340
00:27:16,302 --> 00:27:19,465
트랜스코더가 참고했다는 그 모듈입니다

341
00:27:20,080 --> 00:27:25,366
그래서 진행되는 구조 자체는
트랜스코더와 많이 다르지 않기 때문에

342
00:27:25,390 --> 00:27:29,163
따로 실행구조에 대한 설명을 덧붙이지는 않았습니다

343
00:27:30,580 --> 00:27:32,439
파이프라인 개발에 있어서

344
00:27:32,464 --> 00:27:36,814
마주하는 여러 가지 이슈들을 해결하고자
사용을 하고요

345
00:27:37,810 --> 00:27:43,997
스포티파이의 Luigi 그리고
에어비앤비의 Airflow가 대표적으로 꼽힙니다

346
00:27:44,710 --> 00:27:48,053
그리고 데이터 파트에서 Luigi를 사용했던 이유는

347
00:27:48,350 --> 00:27:51,998
당시의 데이터팀의 규모가 크지 않았기 때문에

348
00:27:52,023 --> 00:27:57,106
직접 짜야 하거나
비교적 복잡한 부분이 많은 Airflow보다는

349
00:27:57,130 --> 00:28:03,137
Luigi가 적당하다고 판단됐고요
그렇게 Luigi를 계속 쓰고 있습니다

350
00:28:03,730 --> 00:28:11,130
하지만 이렇게 구성된 Luigi 파이프라인이
가끔 에러로 인해서 제대로 동작하지 않을 때가 있었는데요

351
00:28:11,530 --> 00:28:17,209
많은 이유가 있었지만 카테고라이징을 해보면
이 정도의 원인이 있었습니다

352
00:28:17,800 --> 00:28:22,966
외부에서 가져와야 되는 형식
즉 아까 파이프라인의 소스를 통해서

353
00:28:22,990 --> 00:28:28,083
가져오는 형식이 바뀌면서
익스트럭트 단계부터 꼬인다던지

354
00:28:28,562 --> 00:28:32,913
혹은 Luigi의 설정 문제로
Luigi 자체 설정 문제로

355
00:28:32,938 --> 00:28:38,163
파이프라인이 흘러가지 못하고
특정 단계에 무한 펜딩된다든지

356
00:28:38,710 --> 00:28:44,956
혹은 그냥 코드 자체에 에러가 있다든지
가져와야 하는 로그파일이 생성되지 않아서

357
00:28:44,980 --> 00:28:47,651
가져오지 못하는 등의 문제가 있었습니다

358
00:28:48,160 --> 00:28:54,675
이 중에 외부 원인을 제외하고는 테스트를 작성하면
미연에 방지할 수 있는 내용이라고 판단했고요

359
00:28:55,030 --> 00:29:00,428
그래서 데이터 파이프라인에도
원래는 없었던 테스트를 붙이기로 했습니다

360
00:29:00,700 --> 00:29:06,801
결과적으로 이렇게 일반적인 유닛 테스트와는 달리
통합 테스트를 짜게 됐는데요

361
00:29:07,269 --> 00:29:11,449
먼저 데이터 파이프라인을
정상적으로 통과했을 경우인

362
00:29:11,474 --> 00:29:15,176
BigQuery 데이터를
Expected Output으로 잡습니다

363
00:29:15,520 --> 00:29:21,105
그리고 Expected Output이 나오게 됐던
Input을 테스트 데이터로 제공합니다

364
00:29:22,030 --> 00:29:27,136
테스트는 주입된 Input을
본래 Luigi 파이프라인을 통해서

365
00:29:27,160 --> 00:29:30,256
BigQuery에 새로운 Test Output을 만들고

366
00:29:30,280 --> 00:29:36,201
다음 단계에서 생성된 Test Output과
Expected Output이 같은지 비교합니다

367
00:29:37,300 --> 00:29:41,386
이때 두 테이블을 비교하고자
필드별로 비교를 하는 것은

368
00:29:41,410 --> 00:29:46,876
필드값이 너무 많기도 하고
유지 보수에도 용이하지 않다고 판단되어서

369
00:29:46,900 --> 00:29:49,720
해쉬된 값으로 두 테이블을 비교합니다

370
00:29:50,620 --> 00:29:55,659
이렇게 앞에서 보여드렸던 테스트는
유닛 테스트 모듈을 이용해서 작성이 됐고요

371
00:29:56,020 --> 00:29:59,684
보셨던 것처럼 온전히 유닛 테스트의 구조는 아니고

372
00:29:59,709 --> 00:30:02,191
커스터마이징된 부분도 많이 있습니다

373
00:30:02,770 --> 00:30:07,746
그리고 현재는 통합 테스트뿐 아니라
다양한 유닛 테스트가 추가되고 있고요

374
00:30:08,350 --> 00:30:14,787
데이터 파이프라인도 테스트 커버리지가
 점점 높아짐에 따라 안정성이 같이 확보되고 있습니다

375
00:30:16,960 --> 00:30:21,475
그리고 이 Luigi with Test 내용은
저희 아까 소개시켜드렸던

376
00:30:21,500 --> 00:30:26,116
개발팀 라이트닝 토크에서 먼저 다뤄졌던 내용이고요

377
00:30:26,140 --> 00:30:32,452
데이터팀에서 발표해주신 덕분에 제가 수월하게
발표 자료에도 내용을 추가할 수 있었습니다

378
00:30:33,340 --> 00:30:37,574
마지막으로 데이터 파트는
머신러닝 프로젝트도 진행 중인데요

379
00:30:38,020 --> 00:30:40,301
현재 서비스 중인 기능으로는

380
00:30:40,326 --> 00:30:44,754
사용자의 시청기록을 기반으로 한
추천 서비스가 있습니다

381
00:30:45,280 --> 00:30:48,795
다른 스트리밍 서비스에서도
많이 제공하고 있는 기능이죠

382
00:30:49,930 --> 00:30:53,116
그 외에는 개발 중인 기능들인데요

383
00:30:53,140 --> 00:30:57,577
얼굴 인식이나 이미지 분류 등과 같은 기술을 이용해서

384
00:30:57,602 --> 00:31:00,077
새로운 기능을 현재 개발하고 있습니다

385
00:31:00,580 --> 00:31:03,650
이렇게 스트리밍 서비스의 전반적인 구조와

386
00:31:03,675 --> 00:31:07,790
파이썬이 사용되고 있는 부분들에 대해
설명을 드렸는데요

387
00:31:08,350 --> 00:31:12,365
아 짧은 시간 안에 여러 파트의 내용을 담다 보니까

388
00:31:12,390 --> 00:31:16,146
내용이 많이 깊어지지 못한 점이 좀 아쉽습니다

389
00:31:16,780 --> 00:31:21,420
그리고 아예 소개시켜드리기가 어려웠던
프론트 파트의 경우에도

390
00:31:21,445 --> 00:31:23,834
되게 흥미로운 이야기들이 많이 있는데요

391
00:31:24,280 --> 00:31:26,920
비디오 플레이어를 어떻게 개발하는지

392
00:31:26,967 --> 00:31:31,153
영상 시청중 재생되는 광고는 어떻게 제어하는지와

393
00:31:31,178 --> 00:31:35,387
같은 내용들을 기회가 되면
또 자세한 이야기를 어디선가

394
00:31:35,412 --> 00:31:37,787
들려드릴 수 있지 않을까 생각합니다

395
00:31:38,500 --> 00:31:42,367
혹시 오늘 발표와 관련해서
궁금하셨던 사항이 있으시면

396
00:31:42,392 --> 00:31:47,703
맨 마지막 장에 안내되는 메일을 통해서
문의 주시면 답장 드리겠습니다

397
00:31:49,150 --> 00:31:53,759
마지막으로 ODK Media는
현재 파이써니스타를 채용하고 있고요

398
00:31:54,010 --> 00:31:59,775
공식 홈페이지를 통해서 회사에 대한
소개와 채용 안내도 확인해보시기 바라겠습니다

399
00:32:00,460 --> 00:32:05,100
네 지금까지 긴 발표 들어주셔서 진심으로 감사드리고

400
00:32:05,125 --> 00:32:08,117
저는 ODK Media의 김애영이었습니다

401
00:32:08,410 --> 00:32:09,523
감사합니다



