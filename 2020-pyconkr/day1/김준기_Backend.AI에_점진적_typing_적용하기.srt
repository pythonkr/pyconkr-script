1
00:00:11,070 --> 00:00:16,039
네 안녕하세요. 저는 Lablup에서
CTO를 맡고 있는 김준기라고 합니다 

2
00:00:16,102 --> 00:00:19,609
올해 6년차 파이콘 발표를 맡게 되었는데
 

3
00:00:19,634 --> 00:00:24,790
이번 세션에서는 그동안 제가 계속 많이
얘기를 했던 asyncio를 벗어나서 

4
00:00:24,815 --> 00:00:29,180
조금 다른 주제로 Type Annotation을 Backend.AI 프로젝트에 적용을 해온
 

5
00:00:29,205 --> 00:00:31,775
이야기를 나누는 시간을 갖도록 하겠습니다
 

6
00:00:32,620 --> 00:00:38,899
네 저는 그동안 뭐 계속 매년 발표 때마다
써왔던 장표인데 조금 조금씩 업데이트가 되고 있습니다 

7
00:00:38,924 --> 00:00:45,150
그래서 그동안 이제 파이콘에서 발표했던
aiotools 프로젝트도 계속 유지보수를 하고 

8
00:00:45,175 --> 00:00:47,356
Backend.AI에 활용을 하고 있고
 

9
00:00:47,380 --> 00:00:52,987
또 aiodocker라고 해서 2016년 파이콘에서 스프린트를 진행을 하면서
 

10
00:00:53,012 --> 00:00:55,996
aiohttp와 asyncio의 개발자였던
 

11
00:00:56,021 --> 00:00:59,986
앤드루 스베트로프라는 분과 함께 작업을 했었는데
 

12
00:01:00,010 --> 00:01:06,076
그분께 이제 프로젝트를 이어받는 권한을 얻게 돼서
aiodocker 프로젝트도 같이 진행을 하고 

13
00:01:06,100 --> 00:01:10,248
이러한 것들을 바탕으로 Backend.AI를 계속해서 개발해오고 있습니다
 

14
00:01:11,200 --> 00:01:15,518
그동안 6년간의 파이콘 이거는 6년째로 발표하는 건데
 

15
00:01:15,543 --> 00:01:20,855
5년 전 2015년 누리꿈 스퀘어에서 열렸던 파이콘
 

16
00:01:20,880 --> 00:01:24,403
그때 받았던 파이콘 쿠키입니다 오른쪽 상단에 보이는 것이
 

17
00:01:25,067 --> 00:01:29,340
받았을 때 안타깝게도 한쪽이 살짝 부러진 상태로 받아서 사진을 저렇게 찍었고
 

18
00:01:29,710 --> 00:01:36,520
또 2016년에 가운데에 있는 큰 사진은 앤드루 스베트로프분과 함께
 

19
00:01:36,545 --> 00:01:39,766
aiohttp 스프린트를 진행했던 사진입니다
 

20
00:01:39,791 --> 00:01:43,466
제가 뒤에서 이렇게 V자를 그리고 있는 모습을 보실 수가 있고
 

21
00:01:43,513 --> 00:01:48,466
2017년에는 사진을 찾아봤는데 제가 찍힌 사진이 지금 바로 안 나와서
 

22
00:01:48,490 --> 00:01:53,271
제가 찍은 사진 중에 보니까 큰 네임월 만들어놨던데
 

23
00:01:53,296 --> 00:01:55,786
제 이름 찍혔던 사진이 남아 있었고
 

24
00:01:56,080 --> 00:02:02,478
2018년도 같은 경우에는 튜토리얼, 스프린트, 스피커, 개인후원, 스폰서해서
 

25
00:02:02,680 --> 00:02:05,922
뱃지 5관왕을 달성했던 셀카가 하나 남아 있고
 

26
00:02:06,109 --> 00:02:08,976
작년에도 계속 참여를 했던
 

27
00:02:09,046 --> 00:02:13,194
나름대로 파이콘에 오래 참여를 해왔던 그런 경험이 있습니다
 

28
00:02:13,900 --> 00:02:17,562
그래서 이제 그동안 계속 Backend.AI를 개발하면서
 

29
00:02:17,587 --> 00:02:22,606
특히 파이썬에서 최근 화두가 됐던
큰 줄기의 개발 흐름이 

30
00:02:22,630 --> 00:02:26,866
asyncio하고 그다음에 type annotation 관련된 기술들이 있는데요
 

31
00:02:26,890 --> 00:02:30,946
그중에서 asyncio에 주로 집중을 해서 많이 얘기를 해왔습니다
 

32
00:02:30,970 --> 00:02:34,430
이번 발표에서는 type annotation에
대한 얘기를 좀 더 해볼까 합니다 

33
00:02:35,290 --> 00:02:40,876
그래서 이 발표에서는 전체적으로 타입 주석을
어떻게 사용하는지에 대해서 간단하게 소개를 드리고 

34
00:02:42,220 --> 00:02:47,454
이 타입 주석 자체를 튜토리얼처럼 어떻게
사용하는지를 일일이 다 설명을 드리기보다는 

35
00:02:47,860 --> 00:02:52,664
실제 제가 Backend.AI 에서 이거를 활용하면서 어떤 문제들이 있었고
 

36
00:02:52,805 --> 00:02:56,896
요런 케이스에는 이렇게 해야 되더라,
이런 것들을 같이 쓰면 좋더라 

37
00:02:56,920 --> 00:03:02,404
뭐 그런 실무적인 해결 방법에 대해서 
이야기하는 그런 시간을 갖도록 하겠습니다 

38
00:03:02,920 --> 00:03:05,980
그 다음에는 타입 주석을 활용하는 개발환경
 

39
00:03:06,005 --> 00:03:10,816
코루틴과 제네레이터, 특히 asyncio 관련돼서 타입 주석을 어떻게 넣는지
 

40
00:03:10,840 --> 00:03:13,668
다음에 프로토콜을 이용해서 복잡한 타입이나
 

41
00:03:13,693 --> 00:03:17,296
일반적인 케이스로 해결이 안 되는 그런 문법을
 

42
00:03:17,320 --> 00:03:20,545
type annotation 한다든지 이런 거에 대해서 소개를 드리고
 

43
00:03:20,570 --> 00:03:24,496
제네릭으로 플러그인 시스템 만든 거를 간단한 예제코드로 보여드리고
 

44
00:03:24,520 --> 00:03:28,012
또 그 다음에 동적으로 웹상에서
 

45
00:03:28,037 --> 00:03:31,690
API 요청을 통해서 받는 어떤 데이터를 검증한다든지
 

46
00:03:31,715 --> 00:03:36,256
이런 직렬화된 데이타를 다루기 위해서는 동적인 타입 검사도 필요하게 되는데
 

47
00:03:36,280 --> 00:03:39,673
그런 부분에서는 어떤 도구들을 활용해서 하고 있는지
 

48
00:03:39,970 --> 00:03:43,360
그걸 이용한 디자인 패턴 같은 것들을 하나 소개를 드리고
 

49
00:03:43,510 --> 00:03:47,275
그다음에 향후 파이썬 버전에 추가될 타입 관련 기능을
 

50
00:03:47,338 --> 00:03:49,838
간단하게 소개를 하는 걸로 마치도록 하겠습니다
 

51
00:03:52,210 --> 00:03:56,692
그래서 파이썬이라고 하시면은 보통 어 이거는 타입이 없는 언어 아니냐
 

52
00:03:56,717 --> 00:04:01,857
혹은 굉장히 타입에 대해서 자유로운 언어 아니냐 라고 생각을 하고
 

53
00:04:02,076 --> 00:04:07,996
우리가 덕 타이핑, 그냥 아무데나 끼워 맞추는
대로 맞춰지기만 하면 돌아가는 타입 시스템이다 

54
00:04:08,020 --> 00:04:09,616
라고 쉽게 생각을 하는데요
 

55
00:04:09,640 --> 00:04:15,585
물론 덕 타이핑이라는 용어 자체는 맞습니다만
조금 더 자세히 들여다보는 이런 특징들이 있습니다 

56
00:04:16,085 --> 00:04:19,156
파이썬은 사실 강한 타입 언어입니다
 

57
00:04:19,180 --> 00:04:23,530
강한 타입이라는 거는 오브젝트의 타입 자체가 변하는 일은 없어요
 

58
00:04:23,555 --> 00:04:29,416
예를 들어서 숫자 1은 그냥 죽었다 깨어나도 1이고
이게 갑자기 str이 된다거나 이런 일이 없습니다 

59
00:04:29,440 --> 00:04:35,446
마찬가지로 문자열 'a' 같은 경우도 이게 막 갑자기
뭔가 다른 타입으로 바뀐다던가 이런 일은 없습니다 

60
00:04:35,470 --> 00:04:41,146
다만 파이썬이 왜 다이나믹 타입이라고 얘기를 하느냐 라면은 변수가
 

61
00:04:41,170 --> 00:04:43,756
아니라 오브젝트에만 타입이 있다 보니까
 

62
00:04:43,780 --> 00:04:50,446
변수 자체는 임의의 다른 오브젝트를
가리킬 수 있도록 런타임에 내가 코드상에서 

63
00:04:50,470 --> 00:04:51,646
아무 때나 바꿀 수가 있어요
 

64
00:04:51,670 --> 00:04:55,574
뭐 b=1 했다가 b='a'다 이러면은
 

65
00:04:55,599 --> 00:04:59,426
얘는 int 오브젝트를 가르켰다가 'a'라는
문자열 오브젝트를 가리켰다가 

66
00:04:59,451 --> 00:05:01,576
이런 식으로 막 바뀔 수가 있습니다
 

67
00:05:01,600 --> 00:05:03,412
그러니까 b에는 타입이 없어요
 

68
00:05:04,030 --> 00:05:07,501
이 1이라는 오브젝트와 문자열 'a'라는 오브젝트에만 타입이 있는겁니다
 

69
00:05:08,080 --> 00:05:12,886
그러다 보니까 이게 코딩을 처음 하는 사람들이
 

70
00:05:12,910 --> 00:05:17,136
이 변수에다 타입을 일일이 적어주지 않아도 된다는 점에서는
 

71
00:05:18,035 --> 00:05:21,076
쉽게 접근할 수 있게 해주는 장점이 있지만
 

72
00:05:21,100 --> 00:05:23,764
단점으로는 코드 규모가 커지다 보면은
 

73
00:05:23,789 --> 00:05:27,196
IDE라든지 이런 통합 개발환경에서
 

74
00:05:27,859 --> 00:05:32,529
뭐 예를 들면 뭐 self 다음에 .을 찍었을 때 자동완성이 돼야 되는데
 

75
00:05:32,554 --> 00:05:35,325
자동완성을 하기 위해서는 self 아래 어떤 변수들이 있고
 

76
00:05:35,350 --> 00:05:38,950
그 변수들이 어떤 타입인지 이런 거에 대한 정보가 있어야 되는데
 

77
00:05:38,975 --> 00:05:42,166
그런 것들에 대한 그 보장이 불가능하다 보니까
 

78
00:05:42,190 --> 00:05:46,502
그런 도구에서 자동화된 어떤 타입추론 하기가 어려운 부분들이 있습니다
 

79
00:05:46,900 --> 00:05:52,610
이런 것들을 개선하고자 타입 주석이라는
개념을 이제 파이썬에서는 도입을 해오고 있는데요 

80
00:05:52,750 --> 00:05:58,306
그래서 PEP라고 해서 파이썬에서 여러 가지 뭐 언어 관련된 표준이라든지
 

81
00:05:58,330 --> 00:06:01,726
스탠다드 혹은 어떤 컨벤션 같은 것들을 정하는
 

82
00:06:01,750 --> 00:06:04,787
혹은 뭐 표준 라이브러리의 새로운 기능 같은 것들을 정하는
 

83
00:06:04,812 --> 00:06:06,466
그런 표준규약 문서들이 있습니다
 

84
00:06:06,491 --> 00:06:09,976
그중에 Type Hints 관련된 문서가 나왔고
 

85
00:06:10,000 --> 00:06:13,889
이거를 통해서 대략 파이썬 한 3.5버전부터
 

86
00:06:13,914 --> 00:06:17,031
계속 타입 관련된 기능들이 추가되어 오고 있습니다
 

87
00:06:17,062 --> 00:06:22,259
그래서 이거는 주석이기 때문에 런타임에 실제로 어떤 영향을 끼치지 않습니다
 

88
00:06:22,284 --> 00:06:25,816
그래서 타입 주석을 막 틀리게 적어놔도 코드는 돌아가고요
 

89
00:06:25,840 --> 00:06:28,936
다만 이거를 잘 annotation을 해놓음으로써
 

90
00:06:28,960 --> 00:06:34,499
IDE라든지 뭐 타입검사 도구들이 자동화된
추론이 가능하게 해주는 그런 효과가 있습니다 

91
00:06:35,170 --> 00:06:38,745
그래서 실제로 제가 Backend.AI를 작성을 할 때도
 

92
00:06:38,770 --> 00:06:43,786
처음 프로토타입은 뭐 한 300줄, 500줄 이정도에서 시작을 했는데
 

93
00:06:43,810 --> 00:06:48,316
지금은 제가 재보니까 대략 7만 줄이 넘는 코드가 되었구요
 

94
00:06:48,340 --> 00:06:52,666
한 5년 정도 개발 끝에
그러다 보니 앞으로도 아마 더 늘어날 건데 

95
00:06:52,690 --> 00:06:57,886
지금 머릿속에 있는 로드맵만 해도 아마 십만줄은 그냥 넘어가지 싶은데
 

96
00:06:57,910 --> 00:07:01,589
이런 상황이 되면 이거를 여러 사람이 협업을 할 때
 

97
00:07:01,614 --> 00:07:05,686
그 타이핑 정보가 없으면은 굉장히 어려워지는 부분들이 많이 있습니다
 

98
00:07:05,710 --> 00:07:11,356
예를 들면 이제 Lua 같은 게임 개발하시는
분들이 많이 사용하는 스크립트 언어가 있는데요 

99
00:07:11,381 --> 00:07:14,209
그런 언어들 같은 경우에도
 

100
00:07:14,982 --> 00:07:18,796
Lua 자체는 타입을 명시하지 않아도 돌아가는 언어지만
 

101
00:07:19,530 --> 00:07:23,206
별도로 Lua 코드로 AI엔진 같은 것을 짜다가
 

102
00:07:23,230 --> 00:07:25,558
막 수만줄 수십만줄의 코드가 되니까
 

103
00:07:25,583 --> 00:07:30,112
이게 유지보수가 안 돼서 타입 문법을 임의로 붙이는
 

104
00:07:30,137 --> 00:07:35,020
그런 작업을 게임회사별로 하는 그런 경우들이 있다고 이제 듣기도 했습니다
 

105
00:07:35,890 --> 00:07:41,476
그런 것들이 있고요
특히 이 타입체크가 유용한 경우가 언제냐면 

106
00:07:41,593 --> 00:07:45,725
어떤 값이 None, 그러니까 NULL값이 될 수 있는 경우에
 

107
00:07:45,750 --> 00:07:50,268
이게 NULL인 경우에 대해서 처리를 했느냐 안 했느냐를
 

108
00:07:50,293 --> 00:07:52,756
타입 검사도구가 검증을 해줄 수가 있습니다
 

109
00:07:52,780 --> 00:07:56,626
그래서 실제로는 None이 들어올 수 있는 어떤 변수인데
 

110
00:07:56,650 --> 00:08:00,860
그걸 None 아니라고 가정하고 코드를 짜놨다가
런타입의 None이 조건에 딱 걸려서 

111
00:08:00,885 --> 00:08:05,582
뭔가 에러가 난다든지 이런 것들을 사전에 방지할 수 있는 그런 효과가 있고요
 

112
00:08:05,770 --> 00:08:10,674
관련해서 여러분들이 한번 그 온라인으로 찾아보고 읽어보면 좋을 만한 글이
 

113
00:08:10,699 --> 00:08:16,214
밑에 링크로 드랍박스의 기술 블로그에 대략 한 4백만줄 정도 되는
 

114
00:08:16,240 --> 00:08:19,379
파이썬 코드에 타입 체킹을 추가를 하면서
 

115
00:08:19,404 --> 00:08:23,550
어떤 효과들을 얻었는지 어떤 점들이
어려웠는지 그것을 또 정리한 좋은 글이 있습니다 

116
00:08:23,575 --> 00:08:25,974
이런 글들도 함께 읽어보시면 좋겠습니다
 

117
00:08:26,800 --> 00:08:30,723
또 이제 타입 주석을 붙이는 방법에는 여러 가지가 있는데요
 

118
00:08:31,223 --> 00:08:34,576
기본적으로는 함수의 인자와 반환 타입을 지정할 수가 있습니다
 

119
00:08:34,600 --> 00:08:40,490
그래서 특히 이제 mypy가 사실상 표준 타입 체커 현재 활용이 되고 있는데
 

120
00:08:40,810 --> 00:08:47,382
이 타입 체커 같은 경우에는 함수의 리턴값이 지정돼 있는 경우에만
 

121
00:08:47,407 --> 00:08:52,275
리턴 형식이 지정되어 있는 경우에만
본문의 타입검사를 수행한다는 특징이 있습니다 

122
00:08:52,299 --> 00:08:55,066
이거는 타입검사를 점진적으로
 

123
00:08:55,090 --> 00:08:59,146
쭉 붙여 나가다 보면 처음부터 모든
코드에 다 타입을 붙여 놓을 수 없기 때문에 

124
00:08:59,170 --> 00:09:05,476
요즘 뭐 가장 흔히 하는 게 함수의 인자부터
타입을 붙이고 리턴 값에 타입을 붙이고 

125
00:09:05,500 --> 00:09:07,846
그러다가 타입 검사기 한 번 돌려서
 

126
00:09:07,870 --> 00:09:12,916
함수 바디 같은 데 있는 타입 에러들을 조금씩
고친다든지 뭐 이런 식으로 진행을 하게 되는데요 

127
00:09:14,650 --> 00:09:18,525
그 과정에서 주의를 하셔야 될 게 반환 타입이 있어야만
 

128
00:09:18,550 --> 00:09:21,456
작동을 한다 라는 거를 주의를 해주셔야 되겠습니다
 

129
00:09:21,753 --> 00:09:26,142
클래스나 인스턴스 변수 뭐 일반 그 바디 본문에 있는
 

130
00:09:26,167 --> 00:09:28,666
변수에도 타입을 지정을 하실 수가 있고요
 

131
00:09:28,690 --> 00:09:31,752
조금 특이한 문법 중의 하나가
 

132
00:09:31,777 --> 00:09:36,307
파이썬에서는 변수에 할당을 하지 않으면 그 변수를 선언이 되지 않습니다
 

133
00:09:36,550 --> 00:09:40,987
근데 선언되지 않은 변수에 대해서 미리 타입만 지정을 해놓을 수가 있습니다
 

134
00:09:41,012 --> 00:09:45,496
그래서 이 맨 아래쪽에 있는 somecode2 에
 

135
00:09:45,521 --> 00:09:50,770
예제를 보시게 되면 Queue에다가 asyncio.Queue라는 타입을 붙여놨는데
 

136
00:09:50,864 --> 00:09:55,465
그 줄이 실행되는 시점에는 q는 존재하지 않는 변수고
 

137
00:09:55,490 --> 00:09:59,191
런타임에는 그냥 아무 동작하지 않는 문장으로 해석이 됩니다
 

138
00:09:59,216 --> 00:10:03,825
그런데 q에다가 실제로 오브젝트를 할당한 경우에만
 

139
00:10:03,850 --> 00:10:08,596
변수가 존재하게 되고 다만 이거를 타입 체커나 IDE들 같은 경우에는
 

140
00:10:08,620 --> 00:10:12,674
q의 타입이 이거다 라는 거를 미리 알 수 있게 해주는 그런 용도로 사용이 됩니다
 

141
00:10:13,120 --> 00:10:18,436
이거를 많이 쓰는 경우는 타입 정의가 길어져가지고 한 줄에 다 못 쓰는 경우에
 

142
00:10:18,460 --> 00:10:22,905
타입정의만 따로 이렇게 몰아서 써놓을 수 있는
그런 개념이라고 보시면 되겠습니다 

143
00:10:24,880 --> 00:10:29,315
그리고 실제로 그 복잡한 파이썬코드를 많이 다루다 보면은
 

144
00:10:29,340 --> 00:10:36,152
뭐 dict가 굉장히 편하게 많은 경우에 
쓸 수 있는 데이터 구조이긴 하지만 

145
00:10:36,190 --> 00:10:41,869
조금 더 명시적인 필드 목록을 제공하는 그런
구조체를 활용하고자 하는 수요들이 생기게 됩니다 

146
00:10:42,220 --> 00:10:47,146
그래서 대표적으로 많이 쓰는 게 파이선에서는
collections 패키지의 namedtuple인데 

147
00:10:47,170 --> 00:10:52,486
이 namedtuple은 그냥 필드 목록만 변수명으로 정의를 할 수가 있는데
 

148
00:10:52,510 --> 00:10:58,336
이거를 typing 패키지에 있는 NamedTuple을 상속을 받는 식으로 구현을 하게 되면
 

149
00:10:58,360 --> 00:11:03,736
class variable에 타입을 붙이는 형태로 훨씬 더
직관적인 형태의 구조체 선언이 가능해집니다 

150
00:11:05,380 --> 00:11:10,440
그리고 이제 또 파이썬 3.7인가에서 들어온 기능으로 알고 있는데
 

151
00:11:10,465 --> 00:11:14,536
typing 패키지에 있는 TypedDict라는
 

152
00:11:14,560 --> 00:11:16,363
클래스를 상속받아서 정의를 하게 되면
 

153
00:11:16,388 --> 00:11:19,903
얘는 dict로 동작을 하고 런타임에는
 

154
00:11:21,434 --> 00:11:24,766
x랑 y라는 키가 항상 존재하는지
 

155
00:11:24,790 --> 00:11:28,679
그 외의 다른 키를 읽어가는지 혹은 할당하는지에 대해서
 

156
00:11:28,704 --> 00:11:32,116
타입체커가 에러를 내도록 하는 그런 역할을 해주게 됩니다
 

157
00:11:32,140 --> 00:11:34,616
그래서 런타임에는 그냥 dict지만
 

158
00:11:34,624 --> 00:11:38,804
이제 타입 체커한테 그런 부가정보를
제공하는 역할을 한다 라고 보실수 있고요 

159
00:11:39,030 --> 00:11:44,357
그 다음에 이것도 파이썬 3.7에서 기본으로 추가된 dataclass라고 불리는
 

160
00:11:44,382 --> 00:11:48,916
말하자면 C의 구조체와 유사한 목적으로 사용할 수 있는
 

161
00:11:48,940 --> 00:11:53,625
그런 class decorator가 있는데 
이것도 마찬가지 문법을 지원을 하고 

162
00:11:53,650 --> 00:11:56,228
원래 이 dataclass에 처음 영감을 줬던
 

163
00:11:56,253 --> 00:12:00,212
attrs이라는 써드 파티 패키지가 있습니다
 

164
00:12:00,490 --> 00:12:04,066
그래서 거기에 auto_attribs라는 옵션 주게되면
 

165
00:12:04,090 --> 00:12:10,318
마찬가지로 instance variable들의 type annotation을 인식해서
 

166
00:12:10,343 --> 00:12:12,617
자동으로 필드를 정의를 해서 사용하게 됩니다
 

167
00:12:13,090 --> 00:12:18,406
이것들 모두 다 annotation이기 때문에 형태로 런타임에는
사실 뭐 아무렇게나 해도 코드는 돌아가요 

168
00:12:18,430 --> 00:12:24,286
근데 마찬가지로 스태틱 타입 체커들이
미리 정확한 필드명으로 사용하는지를 검증해주고 

169
00:12:24,310 --> 00:12:28,935
정확한 타입을 할당하고 읽어가는 지를 검사해준다고 보시면 되겠습니다
 

170
00:12:30,670 --> 00:12:35,806
이 타입 주석을 제대로 활용을 하려면 개발환경 세팅하는 것도 되게 중요합니다
 

171
00:12:37,450 --> 00:12:42,175
그래서 요즘 가장 많이 쓰시는 개발환경이 Visual Studio Code인데
 

172
00:12:42,200 --> 00:12:45,839
여기에 이제 공식적으로 제공되는 파이썬 플러그인 있습니다
 

173
00:12:45,864 --> 00:12:48,496
이걸 이용하면은 내부적으로
 

174
00:12:48,521 --> 00:12:51,668
Language Server 라든지 이런 것들이 다 자동으로 세팅이 돼서
 

175
00:12:51,942 --> 00:12:56,434
파이썬 코드에서도 이런 굉장히 훌륭한 자동완성 기능을 잘 쓰실 수가 있고요
 

176
00:12:57,130 --> 00:13:00,473
그다음에 저 같은 경우는 좀 하드코어하게 되게
 

177
00:13:00,498 --> 00:13:04,292
vim을 터미널에서 쓰는 거를 선호를 하는데
 

178
00:13:04,317 --> 00:13:06,268
뭐 그렇게 된 거는 여러 가지 이유가 있습니다만
 

179
00:13:06,293 --> 00:13:10,949
주로 서버에서만 돌릴 수 있는 프로그램을 개발을 많이 하다 보니까
 

180
00:13:10,974 --> 00:13:15,226
vim을 주개발환경으로 계속 사용을 하고 있는데
 

181
00:13:15,250 --> 00:13:20,046
요즘에는 vim도 뭐 그냥 Syntax Highlighting 정도 되고
 

182
00:13:20,071 --> 00:13:23,171
자동 Auto Indent 되고 요런 정도에서 벗어나서
 

183
00:13:23,196 --> 00:13:25,875
Language Server Protocol 이라는 거를 마이크로소프트가 이제
 

184
00:13:25,900 --> 00:13:28,210
표준화를 하고 오픈소스화를 하면서
 

185
00:13:28,235 --> 00:13:31,828
이제 python-language-server라는 오픈소스 패키지를
 

186
00:13:31,853 --> 00:13:34,066
자기 가상환경 안에 같이 깔아두면
 

187
00:13:34,090 --> 00:13:38,506
그 가상환경에 설치돼 있는 모든 패키지라든지 소스를 다 인식을 해서
 

188
00:13:38,530 --> 00:13:41,192
자동완성을 해주는 그런 기능들이 작동을 하게 됩니다
 

189
00:13:41,217 --> 00:13:44,482
그래서 vim 이나 emacs 같은 환경에
 

190
00:13:44,545 --> 00:13:47,863
LSP plugins을 각 에디터에 맞춰서 깔고
 

191
00:13:47,888 --> 00:13:51,450
그 LSP 플러그인이 자기의 가상환경에 있는
 

192
00:13:51,475 --> 00:13:54,016
python-language-server 패키지를 활용하도록
 

193
00:13:54,040 --> 00:13:56,051
그렇게 configuration을 하시게 되면
 

194
00:13:56,076 --> 00:13:59,732
지금 밑에 제가 실제로 작성하는 코드인데 이렇게
 

195
00:13:59,757 --> 00:14:03,038
asyncio의 loop 같은 것들도 메소드들이 쭉 자동완성이 되고
 

196
00:14:03,063 --> 00:14:05,991
이런식으로 작동하는 것을 보실 수가 있습니다
 

197
00:14:07,720 --> 00:14:11,884
그리고 뭐 PyCharm 같은 경우는 뭐 말할 것도 없이
 

198
00:14:11,909 --> 00:14:16,666
상용이지만 가장 많이 쓰이고 유명한 파이썬용 통합 IDE인데요
 

199
00:14:16,690 --> 00:14:21,229
여기서도 이제 2015년 파이선 3.5가 나온 이후로
 

200
00:14:21,254 --> 00:14:25,182
계속 type annotation 관련된 기능들을 정밀하게 지원을 해주고 있습니다
 

201
00:14:27,670 --> 00:14:31,920
실제로 제가 그 Backend.AI를 개발하면서
 

202
00:14:33,263 --> 00:14:35,835
Coroutine이나 Generator를 굉장히 많이 사용을 했는데
 

203
00:14:35,860 --> 00:14:40,344
여기에서 어떠한 타입 주석 예제들이 있었는지
 

204
00:14:40,369 --> 00:14:42,508
이런 것들을 살펴보도록 하겠습니다
 

205
00:14:43,030 --> 00:14:47,076
파이썬 내에서 즉 typing을 하다 보면은 많이 헷갈리는 게
 

206
00:14:47,101 --> 00:14:50,077
어떤 경우는 Generator고 어떤 경우는 Iterator고
 

207
00:14:50,102 --> 00:14:54,419
어떤 경우는 Iterable이고 어떤 경우에는 Sequence고
 

208
00:14:54,444 --> 00:15:00,397
이제 막 이런 것들을 어디에 어느 것을 어느 경우에
붙여야 되는지가 좀 헷갈리는 경우가 많이 있어요 

209
00:15:01,300 --> 00:15:04,675
사실은 거의 인터페이스가 호환이 되기 때문에
 

210
00:15:04,700 --> 00:15:08,896
Iterable 자리에 Iterator를 그냥 써도 동작을 하고
 

211
00:15:08,920 --> 00:15:14,380
Generator 자리에다가 Iterator로 타입 주석을 해도
사실 그냥 되는 경우가 많이 있습니다 

212
00:15:14,620 --> 00:15:17,790
이제 저는 개념적으로 개인적으로 차이를 두는 거는
 

213
00:15:17,815 --> 00:15:20,713
Iterator나 Iterable 같은 경우는
 

214
00:15:20,738 --> 00:15:24,826
어느 정도 유한한 시퀀스에 대해 적용하고
 

215
00:15:24,850 --> 00:15:30,136
정말 길이가 정해지는 list로 대체를 할
수 있는 경우에는 Sequence 타입을 사용을 하고 

216
00:15:30,160 --> 00:15:35,355
그 외에 런타임에 어떤 그 뭐라고 해야 되나
 

217
00:15:35,380 --> 00:15:39,950
시간제한이 없는 실행에 제약이 없는 조건에서 뭔가 값을 연속으로
 

218
00:15:39,975 --> 00:15:43,186
스트리밍을 한다 라는 개념이 더 강하게 작용할 때는
 

219
00:15:43,210 --> 00:15:45,016
Generator 타입을 적용하고
 

220
00:15:45,040 --> 00:15:47,836
요런 식으로 코드를 작성을 하고 있습니다
 

221
00:15:48,670 --> 00:15:53,115
그래서 generator나 coroutine을 보게 되면은
 

222
00:15:53,140 --> 00:15:57,016
가장 큰 특징이 yield 라는 문장을 사용을 하게 되는데
 

223
00:15:57,040 --> 00:15:59,735
실제 타입을 정의할 때 보면은
 

224
00:15:59,760 --> 00:16:03,856
이 파이썬에서 Generic 타입을 정할땐 이 꺽쇠 문법을 사용해서
 

225
00:16:03,880 --> 00:16:10,544
그 뒤에 이 타입이 참조를 하는 다른 서브 타입들을 지정을 하게 됩니다
 

226
00:16:11,294 --> 00:16:16,573
yield 할 때 yield라는 문장은
사실은 yield 문장의 리턴값도 받을 수가 있어요 

227
00:16:16,598 --> 00:16:20,598
그 리턴값을 받는 거는 그 generator를 부른 쪽에서
 

228
00:16:20,637 --> 00:16:24,332
send 하는 매소드를 활용해서 이용을 하게 됐는데
 

229
00:16:24,730 --> 00:16:30,316
그 yield를 해서 내가 넘겨주는 값과 나를 부른 쪽에서 전달해주는 값의
 

230
00:16:30,340 --> 00:16:33,244
타입을 YieldType과 SendType으로 적을 수가 있고
 

231
00:16:33,269 --> 00:16:35,847
전체 끝났을 때 리턴하는 타입으로 적을 수가 있습니다
 

232
00:16:36,070 --> 00:16:40,513
AsyncGenerator는 특징이 리턴 타입이 빠져 있다 라는 게 특징이 있고
 

233
00:16:40,538 --> 00:16:46,116
Iterator 같은 경우에는 그냥 내가 일방적으로
값을 내놓는 개념이기 때문에 YieldType만 존재를 합니다 

234
00:16:46,720 --> 00:16:51,891
여기에 Generator, 파이썬의 coroutine은 generator를 기반으로 구현이 됐기 때문에
 

235
00:16:51,923 --> 00:16:54,923
동일한 서브 타입을 사용을 하지만
 

236
00:16:54,948 --> 00:16:59,219
거기에 __awaitable__ 이라는 메소드가
더 추가된 형태다 라고 보시면 되겠습니다 

237
00:17:00,700 --> 00:17:05,918
그래서 뭐 이렇게 제가 async 함수나 이게 기본함수에 따라서
 

238
00:17:05,973 --> 00:17:08,918
각종 뭐 inspect function이라든지 뭐 callable 이라든지
 

239
00:17:08,943 --> 00:17:13,906
이런 타입 체크 하는 함수들이 런타임에
어떻게 적용이 되는지를 이를 정리를 한 거고요 

240
00:17:13,930 --> 00:17:19,156
일반 함수 같은 경우에는 calleble은 True다. type은 function이다
 

241
00:17:19,180 --> 00:17:22,456
함수를 호출한 경우에는 그 리턴값이 그냥 리턴 형식이다
 

242
00:17:22,480 --> 00:17:27,676
그런데 async인 경우에는 함수를 호출했을 때 coroutine이 반환되기 때문에
 

243
00:17:27,700 --> 00:17:31,004
그 리턴값이 바로 다이렉트 타입이 아니고
 

244
00:17:31,029 --> 00:17:34,779
coroutine 형식의 타입이 잡힌다 
이런 것들의 차이가 있습니다 

245
00:17:36,369 --> 00:17:40,816
거기에 뭐 yield 문장이 들어가서
Generator가 붙게 되면 조금 더 복잡해지는데 

246
00:17:40,840 --> 00:17:44,675
약간 다른 언어들하고 개념적으로 다른 부분은
 

247
00:17:46,840 --> 00:17:52,396
iscoroutine은 실제 async로 정의된
함수에 대해서만 True를 반환을 하고 

248
00:17:52,420 --> 00:17:55,887
일반 generator에 대해서는 coroutine이 아니다 라고 판정을 한다 그래서
 

249
00:17:55,912 --> 00:18:01,006
이런 부분이 용어가 헷갈릴 수가 있는
부분이기 때문에 그런 부분만 주의를 하면 되고 

250
00:18:01,030 --> 00:18:06,583
나머지는 뭐 테이블에 보시는 것처럼 어느 정도
예상할 수 있는 범위 내에서 직관적으로 동작을 합니다 

251
00:18:06,608 --> 00:18:09,490
한 가지 주의를 해야 될 거는
 

252
00:18:09,515 --> 00:18:14,716
어떤 함수가 async 함수인지를 체크하는 거는 iscoroutinefunction을 써야되고
 

253
00:18:14,740 --> 00:18:18,646
결과물로 그 함수를 호출했을 때 나오는 그 결과물이
 

254
00:18:18,671 --> 00:18:22,935
실제 실행 중인 coroutine인지를 검증할 때는 iscoroutine 써야 된다
 

255
00:18:22,960 --> 00:18:27,346
이 두 가지가 말하자면 interchangable 하게 사용되는 경우들이 있는데
 

256
00:18:28,510 --> 00:18:34,066
그 실제로는 다른 종류의 오브젝트기 때문에
하나는 함수고 하나는 함수를 호출한 결과거든요 

257
00:18:34,090 --> 00:18:38,386
그런 부분을 주의를 해야 되는 경우들이 있습니다
 

258
00:18:38,410 --> 00:18:42,195
그리고 그 contextmanager를 사용할 때
 

259
00:18:43,657 --> 00:18:48,196
원래는 뭐 __enter__, __exit__ 메소드를 직접 구현 하는 클래스를
 

260
00:18:48,220 --> 00:18:50,806
만드는 것이 원래는 정석이지만
 

261
00:18:50,830 --> 00:18:56,866
간단하게 yield을 한 번만 하는 함수를 decorator로
감싸서 contextmanager를 활용을 하는 경우들이 있습니다 

262
00:18:56,890 --> 00:19:02,319
그래서 이 경우에는 asynccontextmanager 라는 것도 활용을 할 수가 있는데
 

263
00:19:02,830 --> 00:19:08,176
이 경우에는 감싸지는 함수의 리턴 형식이
Iterator 또는 AsyncIterator 형식이어야 합니다 

264
00:19:10,057 --> 00:19:15,313
저는 처음에 이거를 작성할 때 리턴값에 AsyncContextManager를 했더니
 

265
00:19:15,338 --> 00:19:18,256
사실은 이게 감싸져서 ContextManager가 되는 건데
 

266
00:19:18,280 --> 00:19:20,912
감싸지기 전에 ContextManager이면
 

267
00:19:20,944 --> 00:19:24,946
contextmanager의 인풋 타입하고 어긋나기 때문에 에러가 나게 됩니다
 

268
00:19:24,970 --> 00:19:29,415
이런 부분은 제가 삽질을 했던 부분이라
그런 주의사항이 있다 

269
00:19:29,440 --> 00:19:33,065
그래서 Iterator를 감싸는거다 라는 거를 이해하고 계시면 되겠습니다
 

270
00:19:35,440 --> 00:19:39,930
그리고 Protocol로 그 부분적 타입 정의하는 내용이 있는데요
 

271
00:19:39,955 --> 00:19:44,176
이거 같은 경우에는 예를 들면 뭐 Closable
 

272
00:19:44,200 --> 00:19:49,673
이런 식으로 'close' 메소드가 있는 어떤 임의의
오브젝트다 라는 거를 Protocol로 정의를 할 수가 있고 

273
00:19:49,982 --> 00:19:54,904
임의의 클래스가 Closable이냐 아니냐 라는 거를
 

274
00:19:54,929 --> 00:19:58,779
isinstance 같은걸로 검증을 한다던지
이런 것들이 가능해집니다 

275
00:19:59,170 --> 00:20:02,693
하나의 오브젝트가 여러 프로토콜을 구현할 수 있고요
 

276
00:20:03,357 --> 00:20:05,857
그래서 뭐 Iterable, Iterator, Callable, Sized,
Hashable 

277
00:20:05,882 --> 00:20:08,380
뭐 이런 것들이 다 거기에 해당을 하게 되고
 

278
00:20:08,544 --> 00:20:13,856
이거를 이용을 하면은 타입을 조합해서 정의하는
 

279
00:20:13,881 --> 00:20:16,317
Mixin 같은 패턴을 쓰는 게 가능해집니다
 

280
00:20:16,750 --> 00:20:22,786
제가 개인적으로 가장 유용하게 발견을 했던 케이스는 뭐였냐면
 

281
00:20:23,864 --> 00:20:30,182
Callable를 정리를 할 때 원래는 타이핑 패키지에
있는 Callable 클래스를 가져와서 

282
00:20:30,207 --> 00:20:35,089
거기에 Generic 형태로 인자 목록과 리턴값을 지정하는 식으로
 

283
00:20:35,114 --> 00:20:37,783
함수의 어떤 시그니처로 정의를 할 수가 있는데요
 

284
00:20:37,808 --> 00:20:40,478
그 경우에 keyword argument를 표현할 방법이 없습니다
 

285
00:20:40,503 --> 00:20:43,229
문법적으로 저 꺽쇠 안에다가 뭔가
 

286
00:20:43,254 --> 00:20:47,086
keyword argument만을 표현하기 위한 거를 넣을 방법이 없어요
 

287
00:20:47,110 --> 00:20:49,391
그래서 이런 경우에 내가 꼭 keyword argument를
 

288
00:20:49,416 --> 00:20:53,536
시그니쳐로 명시적으로 타입을 정의를 하고 싶다
 

289
00:20:53,560 --> 00:20:58,486
그런 경우에는 프로토콜에 __call__
메소드를 정의하는 형태로 

290
00:20:58,510 --> 00:21:04,056
이제 정의를 할 수가 있고 이 경우에는 타입체커가 그런
keyword argument까지 다 인식을 해서 검사를 해주게 됩니다 

291
00:21:05,860 --> 00:21:11,602
그 다음에 이제 제가 또 실무 레벨에서 고민을 했던 문제 중에
 

292
00:21:12,305 --> 00:21:14,326
Generic을 활용하는 부분입니다
 

293
00:21:14,350 --> 00:21:16,906
그래서 플러그인 시스템을 구현을 하는데
 

294
00:21:16,930 --> 00:21:20,186
플러그인 개별 기능을 제공하는 Plugin이 있고
 

295
00:21:20,211 --> 00:21:25,820
같은 종류의 플러그인을 모아서 그 플러그인들을
로딩해주고 초기화해주고 이런 것을 담당하는 

296
00:21:25,851 --> 00:21:30,736
PluginContext라는 그런 객체로 두 개로 두었는데
 

297
00:21:30,760 --> 00:21:35,386
예를 들면 내가 어떤 Hooking을 하는 플러그인을 만들겠다
 

298
00:21:35,410 --> 00:21:40,144
함수의 어떤 특정 지점을 훅킹하는 플러그인을 만들어서 쓰고 싶은데
 

299
00:21:40,214 --> 00:21:46,471
보면 이제 훅킹을 하기 위한 어떤 Plugin들이 있고
이 플러그인들을 관리하기위한 HookPluginContext가 있게 되요 

300
00:21:47,830 --> 00:21:52,008
HookPluginContext는 임의의 다른 Plugin이 아니라
 

301
00:21:52,033 --> 00:21:54,867
HookPlugin 유형의 Plugin만 받고 싶은 거에요
 

302
00:21:54,892 --> 00:21:58,846
이런 관계를 제약을 줘서 정의를 하고 싶을 때
 

303
00:21:58,870 --> 00:22:02,229
여기 예제에 있는 것처럼 typing 패키지에 있는
 

304
00:22:02,254 --> 00:22:05,506
TypeVar과 Generic을 활용을 하실 수가 있고
 

305
00:22:05,530 --> 00:22:08,236
특히 TypeVar을 정의를 하실 때
 

306
00:22:08,260 --> 00:22:12,783
그 bound 라는 옵션을 줘서 내가 어떤 특정 유형의
 

307
00:22:12,814 --> 00:22:16,006
그 어떤 base class 만 허용을 하겠다
 

308
00:22:16,030 --> 00:22:17,614
이런 것들을 정의를 하실 수가 있습니다
 

309
00:22:17,639 --> 00:22:21,154
그래서 최소한 이거는 Plugin 이어야 하고
 

310
00:22:21,179 --> 00:22:23,520
그런데 그중에서도 HookPlugin 이어야 한다
 

311
00:22:23,545 --> 00:22:26,654
뭐 이런 관계들을 이렇게 예제로 보시는 것처럼
 

312
00:22:26,679 --> 00:22:29,420
정의를 해서 사용을 하는 것도 가능하게 됩니다
 

313
00:22:30,834 --> 00:22:36,271
다음에 마지막으로 다룰 내용 중에 하나는 동적 타입 검사 기법입니다
 

314
00:22:36,657 --> 00:22:40,246
지금은 기존에 존재하던 파이썬 코드에다가
 

315
00:22:40,270 --> 00:22:44,925
변수나 클래스나 이런 데다가 타입을 매기는 방법을 봤었는데
 

316
00:22:44,950 --> 00:22:48,980
실제로는 우리가 뭐 간단한 HTTP 서버를 만든다 하더라도
 

317
00:22:49,324 --> 00:22:55,306
Request/Response를 통해서 JSON이라든지 뭐 어떤 뭐 GraphQL이라던지
 

318
00:22:55,330 --> 00:22:58,055
GraphQL은 그래도 자체 타입 검사 기능이 있지만
 

319
00:22:58,080 --> 00:23:00,376
MessagePack 같은 것을 주고받는다든지
 

320
00:23:00,401 --> 00:23:04,526
이런 식의 동적인 직렬화 타입을 이용하는 경우들이 생깁니다
 

321
00:23:05,380 --> 00:23:09,946
런타임에 타입을 검사하는 게 여러 방법이, 라이브러리들이 있는데요
 

322
00:23:09,970 --> 00:23:13,115
그 중에서 대표적으로 많이 쓰는게
typeguard 라는 프로젝트가 있습니다 

323
00:23:13,140 --> 00:23:16,396
이거는 type annotation이 나오기 훨씬 전부터 있었던 거고
 

324
00:23:16,420 --> 00:23:21,436
이와 같은 경우에는 타입 주석을 런타임에 읽어들여서 검사를 하는
 

325
00:23:21,460 --> 00:23:26,986
그런데 이거는 파이썬 코드 부분에 런타임 타입 검사를 넣는 개념에 가깝고
 

326
00:23:27,010 --> 00:23:32,474
실제로 직렬화 데이타에 대해서 편리하게 쓸
수 있는 건 trafaret하는 라이브러리가 있습니다 

327
00:23:32,499 --> 00:23:37,366
이거는 제가 aiohttp 프로젝트에서
사용이되서 알게 된 라이브러리고요 

328
00:23:37,390 --> 00:23:40,288
밑에 예제 코드 보시는 것처럼 dict인데
 

329
00:23:40,313 --> 00:23:44,326
그 키들을 TypedDict 처럼 정의를 할 수 있는데
 

330
00:23:44,350 --> 00:23:48,770
그 TypedDict는 그냥 런타임에 그냥 dict로만 동작을 하는 반면에
 

331
00:23:48,795 --> 00:23:53,238
이거 같은 경우에는 check라는 메소드가 제공이 돼서
 

332
00:23:53,263 --> 00:23:55,816
거기다가 어떤 임의의 인풋데이터를 넣으면
 

333
00:23:55,840 --> 00:23:58,636
실제로 데이터를 그 타입에 맞춰서
 

334
00:23:58,661 --> 00:24:01,567
검증하고 변환해주는 역할을 다 자동으로 해주게됩니다
 

335
00:24:03,070 --> 00:24:08,596
이거를 이용하게 되면은 API 서버를
짤 때 REST API를 만든다 라고 했을 때 

336
00:24:08,620 --> 00:24:11,907
JSON으로 들어오는 인풋 들을 자동으로 검증하고
 

337
00:24:11,932 --> 00:24:15,994
이거를 구조화된 구조체 변수로 뽑아주는 부분을
 

338
00:24:16,572 --> 00:24:21,142
어떤 정형화된 형태로 딱 만들어놓고 재사용할 수 있는 형태로 쓸 수가 있습니다
 

339
00:24:21,430 --> 00:24:27,796
실제로 지금 이 슬라이드에서 보여드리고 있는 코드는
Backend.AI에서 굉장히 많이 사용을 하고 있는 패턴이고요 

340
00:24:27,820 --> 00:24:32,341
그래서 이 trafaret의 특징이 체크해서 이제 어떤 에러가 발생을 했을 때
 

341
00:24:32,366 --> 00:24:36,640
그 dict 형태로 에러 정보를 쫙 정리해서 뽑아주는 기능이 있습니다
 

342
00:24:36,665 --> 00:24:39,976
필드 하나만 에러가 나면 그 필드에 대한 정보가 나오고
 

343
00:24:40,000 --> 00:24:44,345
두 개, 세 개에 대해서 에러가 나면은
그거에 대한 정보가 여러 필드로 나온다든지 

344
00:24:44,370 --> 00:24:49,071
이러한 것들을 요약정보를 예쁜 문자열로 잘뽑아주고요
 

345
00:24:49,096 --> 00:24:54,256
그런 걸 이용하면은 클라이언트 쪽에서 에러 정보를
 

346
00:24:54,280 --> 00:24:59,026
받아서 '여러분이 이러이러한 필드를 고쳐야 됩니다'
 

347
00:24:59,050 --> 00:25:01,690
이런 것들을 이제 구현하는데 좀 편리하게 쓸 수가 있습니다
 

348
00:25:02,080 --> 00:25:08,119
그런데 Django 같은 프레임워크를 쓰게 되면은
Form 이라는 클래스가 이런 역할을 대신해 주게 되는데 

349
00:25:08,165 --> 00:25:11,579
aiohttp 라든지 이런 말하자면
 

350
00:25:11,604 --> 00:25:15,646
경량 프레임워크를 써서 이런 과정을 직접 구현을 해야 되는 경우에
 

351
00:25:15,670 --> 00:25:19,099
유용하게 사용하실 수 있는 그런 기능이라고 보실 수 있겠습니다
 

352
00:25:20,800 --> 00:25:23,729
그리고 또 제가 활용하고 있는 부분은
 

353
00:25:23,754 --> 00:25:27,496
etcd의 어떤 Key-Value. Nested Key-Value Structure 라든지
 

354
00:25:27,520 --> 00:25:31,205
아니면은 TOML 이라고 불리는 어떤 컨피그레이션 파일을 읽어들였을때
 

355
00:25:31,230 --> 00:25:33,976
이것도 어떤 Nested dict 형태로 나오게 되는데
 

356
00:25:34,000 --> 00:25:39,286
그런 Nested dict 각각의 필드의 존재 유무와 디폴트 값과
 

357
00:25:39,310 --> 00:25:45,076
그 다음에 타입과 이런 것들을 다 한 번에 검사를 해서
 

358
00:25:45,100 --> 00:25:50,326
내가 실제로 이 config에는 항상 이런 키가 있어라는 걸 가정하고 코딩을
 

359
00:25:50,350 --> 00:25:54,496
할 수 있게끔 도와주는 그런 형태로 또 사용을 하고 있고요
 

360
00:25:54,520 --> 00:26:00,046
또 이제 밑에 링크를 했는데 그 제가 trafaret에서 제공되지 않는
 

361
00:26:00,070 --> 00:26:05,070
validator, converter들도 자체적으로 추가로 정의를 해서 사용하고 있습니다
 

362
00:26:07,241 --> 00:26:09,306
그래서 마지막 슬라이드입니다
 

363
00:26:09,595 --> 00:26:14,180
앞으로 파이썬에서 계속 type annotation이 강화가 되는 방향으로 갈 것 같고요
 

364
00:26:14,680 --> 00:26:18,344
특히 mypy 프로젝트의 이슈 트래커를 들여다보게 되면
 

365
00:26:18,383 --> 00:26:24,429
귀도 반 로섬 님께서 열심히 관련 이슈들을
트래킹을 하고 있는 모습을 볼 수가 있습니다 

366
00:26:25,172 --> 00:26:28,140
크게 다음에 도입된 기능으로는
 

367
00:26:28,165 --> 00:26:33,100
모듈 로딩할 때 원래는 타입주석이 다 evaluation 됩니다
 

368
00:26:33,125 --> 00:26:36,562
그런데 그런 경우에 문제가 뭐냐면 클래스 안에서
 

369
00:26:36,587 --> 00:26:38,851
그 클래스 타입을 쓸 수가 없어요
 

370
00:26:38,876 --> 00:26:41,444
왜냐하면 클래스 정의가 끝나지 않은 상태기 때문에
 

371
00:26:41,469 --> 00:26:45,106
이런 어떤 forward reference 문제를 해결하기 위해서
 

372
00:26:45,130 --> 00:26:49,396
타입 주석을 구문 분석만 하고 실제로 evaluation 하지 않는다
 

373
00:26:49,420 --> 00:26:53,574
이런 규칙을 파이썬 문법에 정의를 하는 게 들어갔는데요
 

374
00:26:53,599 --> 00:26:56,614
3.7 부터는 __future__ 플래그로 사용할 수가 있고
 

375
00:26:56,639 --> 00:27:00,136
3.10 버전부터 기본으로 이 기능이 활성화될 예정입니다
 

376
00:27:00,160 --> 00:27:06,136
실제로 type annotation을 좀 빡세게 쓰시는
분들 같은 경우에는 이 기능을 켜놓고 쓰시는 거를 권장을 드리고요 

377
00:27:06,520 --> 00:27:12,152
그 다음에 또 많이 봐야 되는 부분이
 

378
00:27:13,450 --> 00:27:18,526
type annotation을 실제로 붙이다 보면은
typing 패키지에서 온갖 import 해와야돼요 

379
00:27:18,551 --> 00:27:23,536
List, Sequence, Tuple, Mapping, MutableMapping,
 

380
00:27:23,560 --> 00:27:25,636
MutableSequence, List, Dict
 

381
00:27:25,660 --> 00:27:30,676
온갖 것을 다 import 해 와야 type annotation을
제대로 작성을 할 수가 있는데 

382
00:27:30,700 --> 00:27:32,989
이게 파이썬 3.9에서는 좀 개선이 됩니다
 

383
00:27:33,043 --> 00:27:38,026
그래서 typing 모듈에서 너무 import 하는 패턴이 자주 반복이 되다 보니까
 

384
00:27:38,050 --> 00:27:44,625
아예 기본 내장 컨테이너 타입들에
Generic type annotation을 붙일 수 있도록 

385
00:27:44,680 --> 00:27:48,429
표준 라이브러리 자체를 확장을 하는 그런 작업이 들어가 있습니다
 

386
00:27:48,725 --> 00:27:52,246
이번에 3.9 버전에 제공될 예정입니다
 

387
00:27:52,270 --> 00:27:56,004
이 정도로 type annotation을 Backend.AI에서
 

388
00:27:56,029 --> 00:27:59,086
어떻게 적용을 했는지 이런 것들을 설명을 드렸고요
 

389
00:27:59,110 --> 00:28:03,046
여기에서 슬라이드에서는 제가 미쳐 다 소개를 못했지만
 

390
00:28:03,960 --> 00:28:06,967
타입 검사 시점에만 import를 선택적으로 하는
 

391
00:28:06,992 --> 00:28:09,976
타입체킹 플래그를 사용하는 방법이라든지
 

392
00:28:10,000 --> 00:28:15,955
그 다음에 mypy 같은 데서 타입이 정의되지 않은
 

393
00:28:15,980 --> 00:28:19,628
서드 파티 라이브러리를 안전하게 불러다 쓰는 방법이라든지
 

394
00:28:19,870 --> 00:28:23,401
Stub으로 내가 type annotation만 서드파티 라이브러리들에서
 

395
00:28:23,426 --> 00:28:25,486
내가 임의로 정의를 해서 쓴다든지
 

396
00:28:25,511 --> 00:28:29,266
이런 사실 다양한 고급 기능들이 존재합니다
 

397
00:28:29,290 --> 00:28:32,776
그런 부분까지는 뭐 시간관계상 다 소개를 드리긴 어렵지만
 

398
00:28:32,948 --> 00:28:37,221
그런 부분에 대해서도 키워드로 검색을 해서 찾아보시면은
 

399
00:28:37,246 --> 00:28:42,242
실제 실무 레벨에서 annotation을 적용하는데
도움이 되실 수 있을 거라 생각이 듭니다 

400
00:28:43,060 --> 00:28:45,835
네 이상으로 발표를 마치도록 하겠습니다


