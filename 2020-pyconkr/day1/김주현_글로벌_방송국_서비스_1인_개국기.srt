1
00:00:10,270 --> 00:00:12,550
안녕하세요 파이콘 한국 2020 여러분

2
00:00:12,580 --> 00:00:17,650
저는 글로벌 방송국 서비스인 1인 개국기 발표하게 될 김주현입니다

3
00:00:17,680 --> 00:00:19,270
웹서비스 부문이고요

4
00:00:19,300 --> 00:00:23,940
실제로 서비스는 웹이랑 앱, 둘 다 하고 있는 방송 서비스인데요

5
00:00:24,670 --> 00:00:29,980
쉽게 생각하시면 연예인 분들이 텔레비전이나 라디오에서 나오는 것처럼

6
00:00:30,010 --> 00:00:33,330
그런 미디어들을 실시간으로 콘서트처럼

7
00:00:33,360 --> 00:00:36,310
제공하는 그러한 서비스라고 보시면 되겠습니다

8
00:00:36,460 --> 00:00:40,990
그래서 서비스를 혼자서 만들고 그 방송국을 개국하게 되었다고

9
00:00:41,020 --> 00:00:43,330
이렇게 공유를 드리는데요

10
00:00:43,480 --> 00:00:48,280
실제로 저를 리드해주신 이창신 자바 명인님이 저희팀 리드로 계시고

11
00:00:48,790 --> 00:00:52,580
그분께 이 자리를 빌려 감사의 말씀을 표하고 싶습니다

12
00:00:54,250 --> 00:00:58,320
저에 대한 소개를 좀 더 하자면요 현재
네이버 나우에서 서비스 개발자로 일하고 있고

13
00:00:58,630 --> 00:01:03,670
기존에 아니 과거에는 AI기반 서비스 스타트업에서 연구개발자로 일하기도 했습니다

14
00:01:04,150 --> 00:01:06,160
파이썬으로 외주를 하기도 했구요

15
00:01:06,240 --> 00:01:09,090
그래서 주 언어 파이썬만으로 이렇게 잘 먹고 잘 살게 해주신

16
00:01:09,110 --> 00:01:13,250
파이썬 창시자님이신 귀도 반 로섬님께 항상 고마움을 갖고 살아가고 있어요

17
00:01:13,660 --> 00:01:15,660
그래서 앱도 PyQt로 만들고요

18
00:01:16,170 --> 00:01:21,580
웹에 Django FBV

19
00:01:21,620 --> 00:01:25,010
그다음에  DRF 에서 CBV로 만든 거 좋아하고

20
00:01:25,040 --> 00:01:28,480
비동기 FAST API나 Flask 백엔드도 좋아합니다

21
00:01:28,610 --> 00:01:33,740
그래서 과거부터 지금까지 그리고 미래도 앞으로도
계속 파이썬으로 개발하고 싶은 개발자입니다

22
00:01:34,420 --> 00:01:39,580
약간 저는 스타일이 그 파이썬에서 문법이 있기 때문에

23
00:01:39,610 --> 00:01:42,710
그 규칙 정보만으로도 충분하고요

24
00:01:43,000 --> 00:01:48,430
제가 서비스 개발자다 보니까 지속변경
가능한 비정형화된 스펙이 계속 쏟아져 나옵니다

25
00:01:48,460 --> 00:01:53,370
그 개발 유연차를 맞추기 위해서 불규칙하게 코딩이 쌓여 있는 편이고요

26
00:01:53,760 --> 00:01:59,100
그래서 약간 룰은 깨지기 위해서 있는 것이다 라는 말이나

27
00:01:59,150 --> 00:02:01,660
68혁명에서 금지하는 것을 금지한다는 말처럼

28
00:02:01,690 --> 00:02:06,770
약간  PEP8이나  타입힌트, 각종 클린코드,
소프트웨어 패턴에 항상 제 자신을 맞추지 않고

29
00:02:07,000 --> 00:02:10,480
필요할 때는 참고해서 적용을 하고 배우기도 합니다

30
00:02:10,510 --> 00:02:14,850
Pythonic 하지 않은 면도 있지만 약간 개성일 뿐이고

31
00:02:14,870 --> 00:02:20,940
팀원끼리 협업할 때도 한 코드 파일 안에서 서비스이기 때문에

32
00:02:20,970 --> 00:02:24,970
스타일이 달라도 작동만 하면 된다고 생각하는 편으로

33
00:02:24,990 --> 00:02:27,760
약간 제 개발 스타일을 설명드릴 수 있을 것 같습니다

34
00:02:29,200 --> 00:02:32,400
그래서 저는 직장에서도 서비스를 우선 개발하기 때문에

35
00:02:32,430 --> 00:02:35,810
안정적인 서비스 운영 및 개발이 중요하고요

36
00:02:36,250 --> 00:02:39,800
그래서 그걸 만들기 위해서 단순하면서도
자명한 눈을 가진

37
00:02:39,820 --> 00:02:43,370
비즈니스 로직구현을 최우선으로 보고 개발을 하고 있습니다

38
00:02:44,140 --> 00:02:46,670
가장 큰 이유로 방송 서비스가

39
00:02:46,700 --> 00:02:52,230
24/7이라고 24시간 동안 7일 매일 365일 방송하는 무중단 서비스잖아요

40
00:02:52,270 --> 00:02:58,120
그래서 이 장애가 없이 계속 송출되어야 하는
퀸의 Show must go on 이라는 말이 딱 들어 맞는 서비스인데

41
00:02:58,450 --> 00:03:01,770
그걸 유지하기 위해서 간결하고 유연하면서도

42
00:03:02,300 --> 00:03:05,050
서비스 확장성을 극대화시킬 수 있는

43
00:03:05,080 --> 00:03:08,570
그런 코드로 생산성과 안정성을 추구하는 편이구요

44
00:03:09,190 --> 00:03:14,360
그렇게 하는 이유는 이제 새로운 기능들이 계속 무궁무진하게 쏟아져 나오고

45
00:03:14,390 --> 00:03:18,430
그걸 적용하거나 아니면 기존 기능을 버리기도 하잖아요

46
00:03:18,460 --> 00:03:23,450
그래서 세상일이 어떻게 될지도 모르기 때문에 네 그런 기획에 맞춰서

47
00:03:23,470 --> 00:03:27,140
저도 예외는 처리는 exception은 패스하는 편이고

48
00:03:27,610 --> 00:03:32,940
그래서 서비스 코드의 모든 것은 서비스만 문제없이
돌아가면 되는 것으로 귀결되는 측면을 갖고 있습니다

49
00:03:34,600 --> 00:03:36,970
비대면 발표를 코로나 때문에 하게 됐는데요

50
00:03:37,000 --> 00:03:40,110
동영상 발표로 보실 때 다루는 것은

51
00:03:40,140 --> 00:03:45,070
지금의 Django로 서비스 개발을 필요했던
기능과 결부된 적용 경험과 느낀점이지

52
00:03:47,260 --> 00:03:53,160
약간 Django 등 각종 프레임워크들 자체 사용에서의 장단점 이런 얘기는 안 하는 편입니다

53
00:03:54,010 --> 00:03:57,080
그 사용한 라이브러리 버전 및 상세 라이브러리와

54
00:03:57,110 --> 00:03:59,830
게이트웨이간 정량적 성능 비교도 안 하고요

55
00:03:59,860 --> 00:04:07,180
그래서 예를 들어서 uWSGI VS gunicorn
VS asgi uvicorn, requests VS pycurl

56
00:04:07,210 --> 00:04:12,070
이런 걸 비교할 수도 있는데 외부에도
다 있기도 하고 셋 다 잘 쓰고 있거든요

57
00:04:12,100 --> 00:04:13,390
그래서 비교하지 않고요

58
00:04:13,420 --> 00:04:19,800
리퀘스트보다 파이컬이 더 빨라져서 잘 쓰는 편인데

59
00:04:19,830 --> 00:04:20,920
아무튼 둘 다 잘쓰고 있어요

60
00:04:20,950 --> 00:04:26,300
그래서 서비스 적용에서의 정량적인 성능 상세 metric은 얘기하지 않고

61
00:04:26,580 --> 00:04:32,210
그다음에 기술 플랫폼적인 송출, 재생, 미디어, 서버, 개발 이런 얘기도 하지 않습니다

62
00:04:32,230 --> 00:04:35,470
그래서 적재적소에 기술을 어떻게 썼는지 얘기 갖추고요

63
00:04:35,890 --> 00:04:39,720
그래서 슬라이드에 단독보다는 발표 영상의

64
00:04:39,750 --> 00:04:42,810
제가 약간 구두로 설명하는게 다 주관적인 내용이라서

65
00:04:42,830 --> 00:04:45,460
절대적인 진리도 아니라서 되게 조심스럽거든요

66
00:04:45,490 --> 00:04:48,110
그래서 영상으로 봐주시면 감사할 것 같습니다

67
00:04:49,150 --> 00:04:54,250
제 발표의 목적을 얘기를 드리면 저술한 내용처럼

68
00:04:54,280 --> 00:04:57,000
파이썬 및 파이썬 생태계 개발자 분들이

69
00:04:57,030 --> 00:04:59,990
전 세계에 계신 분들이 고마워서 이렇게 발표를 하게 됐고요

70
00:05:00,010 --> 00:05:05,930
백퍼센트 파이썬만으로도 생산성과 확장 가능성을 잘 유지하면서

71
00:05:06,580 --> 00:05:09,860
대게 글로벌 환경에서 안정적으로 웹 및 앱서비스를

72
00:05:09,890 --> 00:05:12,490
이렇게 할 수 있는 포털이 나오고 있잖아요?

73
00:05:12,520 --> 00:05:16,450
그 고가용성을 담보로 하는 100% 파이썬 서비스를 만들어서

74
00:05:16,480 --> 00:05:19,190
한번 얘기하면 좋을 것 같아서 이렇게 갖고 나오게 됐고요

75
00:05:19,450 --> 00:05:25,570
또 공유 순서로 주로 파이썬 Django 2.x대에 기반한 내용이랑

76
00:05:25,610 --> 00:05:27,350
밑단의 라이브러리를 얘기하는데

77
00:05:27,660 --> 00:05:32,160
일단 방송국 서비스를 만들기 위해서 파이썬을 만들기 위해서 필요한 요소들이랑

78
00:05:32,190 --> 00:05:36,760
그 요소들을 크게 3파트 ADMIN, API, STAT로 나눠서

79
00:05:36,790 --> 00:05:39,150
이러한 내용들을 설명드리고자 합니다

80
00:05:42,640 --> 00:05:47,080
그래서 방송국 서비스를 만들기 위해서 요소들을 한 번 도식화 해봤는데요

81
00:05:47,110 --> 00:05:50,260
처음엔 방송 데이터 모델을 DB 스키마와 함께 정리를 해야겠죠

82
00:05:50,490 --> 00:05:57,820
ORM, Django, ADMIN Models 이런 걸 쓰면서 만드는 그런 과정인데요

83
00:05:58,020 --> 00:06:00,970
그래서 Django models.py에 스트리밍 동영상은

84
00:06:00,990 --> 00:06:03,510
각종 뭐 메타 관련 정보를 기입하고

85
00:06:03,780 --> 00:06:07,700
출연자가 누구고 그런 기본 정보들을 기입을 하겠죠. 정의를 하고

86
00:06:07,960 --> 00:06:15,060
그래서 그 정의한 거를 ADMIN을 통해서 관리자가 기입을 하고요

87
00:06:15,190 --> 00:06:20,320
그 기입한 정보를 웹이나 앱에서 받아볼 수 있도록 재생할 수도 있고

88
00:06:20,350 --> 00:06:24,180
그렇죠 그런 API를 통해서 제공을 하는데요

89
00:06:24,730 --> 00:06:29,860
그 API를 통해서 앱에서는 이게 24시간 동안 무중단으로

90
00:06:29,890 --> 00:06:32,910
콘텐츠를 재생할 수도 있고 미디어를 볼 수 있는데

91
00:06:33,170 --> 00:06:37,060
한편으로는 미디어를 보면서 좋아요를 누르거나 구독을 누르거나

92
00:06:37,090 --> 00:06:41,530
이런 요청들을 피드백을 저희 API를 통해서 받을 수 있게 했습니다

93
00:06:41,550 --> 00:06:45,320
그래서 사용자 개인의 정보통신를 인풋으로 받을 수도 있고

94
00:06:45,340 --> 00:06:49,290
이제 아웃풋으로 ADMIN에서 기입한 정보들을 줄 수도 있죠

95
00:06:50,110 --> 00:06:54,510
또한 그렇게 방송을 시작하고 종료하고 이런

96
00:06:55,450 --> 00:06:58,500
한 생방송이 끝나면

97
00:06:58,530 --> 00:07:03,400
그러한 결과들 예를 들어서 시청률들을 실시간으로 기록할 수 있고

98
00:07:03,430 --> 00:07:04,690
배치로 기록할 수 있는데

99
00:07:04,720 --> 00:07:07,070
그런 걸 방송을 매핑을 통해서

100
00:07:07,460 --> 00:07:12,270
유저 재생지표를 STAT에 담아서 방송 데이터 모듈과 연계할 수도 있습니다

101
00:07:12,790 --> 00:07:15,050
그래서 API, ADMIN, STAT을 주로 얘기하고

102
00:07:16,120 --> 00:07:20,370
ADMIN 서버와 관련해서는 방송 재생 중에 송출 장애가 날 수도 있잖아요

103
00:07:20,650 --> 00:07:23,910
그래서 그럼 미디어 주소를 주기적으로 점검도 하고

104
00:07:23,940 --> 00:07:27,970
장애시에는 유저가 보거나 듣는 걸로 감지하기 전에

105
00:07:28,000 --> 00:07:32,410
자동복구 프로세스 트리거를 통해서 자동으로 다시 나올 수 있도록

106
00:07:32,440 --> 00:07:36,620
최대한 안정적인 운영을 이렇게 할 수 있는 구성요소들을 살펴보았습니다

107
00:07:38,520 --> 00:07:40,840
그래서 이 요소들을 모든 걸 파이썬으로 만들었는데요

108
00:07:40,870 --> 00:07:44,110
그때 상황이 한 명, 그니까 제가 두 달 안에

109
00:07:44,130 --> 00:07:46,900
세개의 파트 ADMIN, API, STAT이 기능을 구현해서

110
00:07:46,930 --> 00:07:48,830
서비스런칭을 했야 했던 상황이었습니다

111
00:07:48,840 --> 00:07:51,880
되게 적은 리소스의 사람과 시간이죠

112
00:07:52,270 --> 00:07:56,020
그래서 아웃풋으로는 약간 런칭 속도를 최우선으로 하고

113
00:07:56,050 --> 00:08:00,650
그다음에 서비스 안정성, 확장 가능성을 두 번째 우선순위로 하고

114
00:08:00,670 --> 00:08:03,130
그다음에 운영성은 약간 후순위로 뒀어요

115
00:08:03,160 --> 00:08:08,520
그래서 개발적인 측면에서 빠르게 만드는 대응책을 사용했는데

116
00:08:08,920 --> 00:08:11,040
Django models.py에서 아까 말씀드린 것처럼 데이터

117
00:08:11,070 --> 00:08:15,920
모델을 DB스키마로 ORM과 함께 정의를 한 다음에

118
00:08:17,260 --> 00:08:20,080
이제 Django ADMIN에서 방송 제반 정보를

119
00:08:20,100 --> 00:08:23,580
이제 CRUD Create, Read, Update, Delete 할 수 있도록

120
00:08:23,610 --> 00:08:25,400
관리자가 다시 사용을 하고

121
00:08:25,430 --> 00:08:27,900
그 다음에 API에서 아까 말씀드린 것처럼

122
00:08:27,930 --> 00:08:31,260
정보를 제공해서 클라이언트가 볼 수 있게 합니다

123
00:08:31,750 --> 00:08:35,410
그래서 전략을 어떻게 취해냐면요

124
00:08:35,440 --> 00:08:37,660
일단 ADMIN과 API를 동시에 개발을 합니다

125
00:08:38,050 --> 00:08:40,720
서비스 생산성을 최적화하기 위해서

126
00:08:40,750 --> 00:08:44,430
Python manage.py startapp은

127
00:08:44,460 --> 00:08:48,780
딱 하나로 한 다음에 그래서 앱은 하나지만 역할은 분기할 수 있도록

128
00:08:49,650 --> 00:08:51,640
약간 기능적으로도 나눴고

129
00:08:51,670 --> 00:08:54,390
그 기능을 분담할 수 있는 서버도

130
00:08:54,420 --> 00:08:59,320
예를 들어서 그 Django settings.py에

131
00:08:59,340 --> 00:09:04,270
정적이면서 글로벌한 것을 그 정의할 수 있잖아요

132
00:09:04,300 --> 00:09:06,220
그래서 그런 변수들을 정의할 수 있도록

133
00:09:06,240 --> 00:09:11,110
Object name이 지금 ADMIN으로 시작하면 이건 ADMIN 서버고

134
00:09:11,530 --> 00:09:14,980
API으로 시작하면 이거는 API 서버로 그렇게 인식을 해서

135
00:09:15,010 --> 00:09:18,750
그 써보신 분들은 다 아시겠지만 url.py에서

136
00:09:18,770 --> 00:09:25,180
ADMIN 서버에서는 ADMIN 관련한 API 및 URL들만 제공하고

137
00:09:25,210 --> 00:09:30,560
API 서버에서는 생 API, 클라이언트가 볼 API만 urls.py에 정의를 해놨어요

138
00:09:30,750 --> 00:09:34,420
그래서 ADMIN에서는 ADMIN URL만 보이고 API 에서 API URL만

139
00:09:34,450 --> 00:09:37,100
보이는 거죠 이렇게 접근은 그렇게 되지만

140
00:09:37,130 --> 00:09:40,160
실제로 개발은 동시에 개발할 수 있던 게

141
00:09:40,190 --> 00:09:42,360
ADMIN에서 아까 모델 정의를 하잖아요

142
00:09:42,420 --> 00:09:47,560
모델 정의를 한 걸 이제 동기로는 DRF로 API를 내려주고

143
00:09:47,590 --> 00:09:50,070
비동기는 FastAPI 를 통해서 내려주는데

144
00:09:50,530 --> 00:09:55,700
DRF API에서는 이제 뷰셋의 모델 뷰셋을 통해서

145
00:09:55,730 --> 00:09:59,430
정의한 모델을 쉽게 바로 Django 모델 그대로 다룰 수 있고요

146
00:09:59,770 --> 00:10:02,520
그 다음에 FastAPI는 약간 생소 하실 수 있으실텐데

147
00:10:02,540 --> 00:10:09,590
이게 비동기로 만들어진 그런 API 역할을 할 수 있거든요

148
00:10:09,620 --> 00:10:13,810
그래서 그런 DB모델도 지금 SQLAlchemy

149
00:10:13,840 --> 00:10:19,270
Flask에서 쓰는 그런 ORM 매핑처럼 SQLAlchemy로 쓰거나

150
00:10:19,300 --> 00:10:23,540
혹은 Django ORM에서 직접 이 링크처럼 받아가지고 쓸 수 있습니다

151
00:10:23,770 --> 00:10:26,570
DRF에서 쓰는 거보다는 약간 복잡하지만요

152
00:10:27,070 --> 00:10:32,520
그래서 그걸 통해서 이제 pydantic이라는 모델벨리데이션을 통해서

153
00:10:32,580 --> 00:10:36,340
ORM 모드로 Django 모델을 컨트롤링을 똑같이 DRF화 할 수가 있습니다

154
00:10:36,370 --> 00:10:40,120
그래서 비동기가 패스트 API고 DRF가 동기로

155
00:10:40,140 --> 00:10:42,520
이렇게 사용을 하게 되는데

156
00:10:42,550 --> 00:10:47,620
이런 식으로 Django에서 정의한 모델을

157
00:10:47,650 --> 00:10:50,440
쉽게 컨트롤링 할 수 있었던 측면이 있었던 것 같습니다

158
00:10:52,690 --> 00:10:56,950
STAT은 한편으로 방송별 유저 활동 분석 통계를 내야 되죠

159
00:10:56,980 --> 00:11:03,400
어떤 액션을 취했고 그 다음에 어떤 걸
좋아하는지를 알아야 서비스 방향을 알수 있고

160
00:11:03,430 --> 00:11:08,520
이제 그거에 대한 피드백을 통해서 계속 서비스를 발전시켜나갈 수 있는 거잖아요

161
00:11:08,660 --> 00:11:11,160
어떠한 쇼를 밀어주고 그런 내용이죠

162
00:11:11,560 --> 00:11:13,950
그러기 위해서 데이터 엔지니어링이 필요했는데

163
00:11:13,980 --> 00:11:18,470
일단 배치로 할 때는 Celery+RabbitMQ+Flower를 주로 사용했고

164
00:11:19,200 --> 00:11:21,200
Confluent Kafka도 사용할 수 있습니다

165
00:11:21,430 --> 00:11:24,660
그래서 리얼타임으로도 지금 배치이긴 한데

166
00:11:25,120 --> 00:11:27,480
Kafka 스트리밍으로 할 때는 받을 수도 있고

167
00:11:28,850 --> 00:11:33,320
컨슈머나 프로듀스 임포트에서 Celery처럼 쓸 수 있죠

168
00:11:33,370 --> 00:11:36,790
여기서 브로커는 RabbitMQ를 썼고 모니터링은 Flower를 썼는데요

169
00:11:36,820 --> 00:11:39,120
그래서 이건 추후에 말씀드리겠습니다

170
00:11:39,870 --> 00:11:46,040
리얼 타임으로는 여기서는 Celery, RabbitMQ랑 Flower만 다루긴 하는데

171
00:11:46,060 --> 00:11:47,500
이 발표는 그런데요

172
00:11:47,530 --> 00:11:54,540
Beat로 실시간 로그를 받거나 아니면 Django의 settings.py의 로깅이 있잖아요

173
00:11:54,560 --> 00:12:00,020
그래서 로깅 핸들러로 Elasticsearch(DSL)을 바로 사용할 수도 있고

174
00:12:00,200 --> 00:12:06,410
DSL를 같이 붙인 게 Elasticsearch에서 쿼리를 보낼 때 바디가 되게 복잡하고

175
00:12:06,440 --> 00:12:10,380
nest 되어있고 막 verb한 것도 이제 DSLR을 쉽게 보낼 수 있잖아요

176
00:12:10,520 --> 00:12:11,640
그래서 주로 썼고요

177
00:12:11,660 --> 00:12:16,450
그다음에 (python-)Logstash 이제 직접 로깅한 결과를

178
00:12:16,480 --> 00:12:20,050
Logstash로 바로 보내서 Kibana에서도 실시간으로 바로 보실 수 있구요

179
00:12:20,080 --> 00:12:23,300
그래서 리얼타임엔 주로 ELK스택을 활용한 면이 큽니다

180
00:12:24,860 --> 00:12:29,210
그래서 이런 요소들을 파이썬으로 해석을
해보자면 이렇게 해석할 수 있을 것 같습니다

181
00:12:29,860 --> 00:12:32,670
그래서 Django ADMIN 부터 이제 말씀을 드릴 건데요

182
00:12:32,690 --> 00:12:34,400
방송관리를 해야겠죠

183
00:12:34,420 --> 00:12:38,450
방송관리라 하면 방송의 콘텐츠들을 관여하거나

184
00:12:38,470 --> 00:12:41,380
송출을 이렇게 제어할 수도 있겠죠 오디오를 다루거나

185
00:12:41,670 --> 00:12:45,810
방송을 시작할 때 온에어 처음의 불을 밝히는데요

186
00:12:45,830 --> 00:12:48,950
그것 처럼 온에어 불을 킴과 동시에

187
00:12:48,970 --> 00:12:52,220
저희 ADMIN에서도 송출을 관여해야 됩니다

188
00:12:52,250 --> 00:12:54,830
방송 시작을 해서 생방송임을 나타내겠죠

189
00:12:54,860 --> 00:12:59,530
그래서 Django ADMIN 커스터마이제이션으로
각종 비즈니스 로직 및 UI를 각 해결했고요

190
00:12:59,560 --> 00:13:05,280
그래서 개발적인 생산성을 되게 빠르게 해서 관리시스템을 구축할 수 있었습니다

191
00:13:05,800 --> 00:13:10,200
또 ADMIN 안에서도 MVT 패턴으로 얘기를 해보자면

192
00:13:10,230 --> 00:13:14,310
그 모델은 방송 콘텐츠 정보를 기입하는 면이 있고요

193
00:13:14,340 --> 00:13:18,010
시작 및 종료 정보를 기입해서 API가 볼 수 있도록 하고

194
00:13:18,040 --> 00:13:21,660
방송장면과 방송 분류 정보를 볼 수가 있고요

195
00:13:22,150 --> 00:13:24,400
View단에서는 이제 컨트롤링하는 거죠

196
00:13:24,430 --> 00:13:28,130
Model과 fields를 CRUD로 컨트롤할 수 있도록

197
00:13:28,150 --> 00:13:33,070
Customized action이나 Customized form을 써서 주로 처리를 했습니다

198
00:13:33,100 --> 00:13:35,310
템플릿은 보여주는 UI와 UX인데요

199
00:13:35,340 --> 00:13:38,380
이건 DTL이나 Jinja2처럼

200
00:13:38,410 --> 00:13:43,120
사용자 입출력 인터페이스를 좀 예쁘게 Customization 할 수
있었고

201
00:13:43,690 --> 00:13:45,570
용도에 맞게 쓸 수 있었던 것 같습니다

202
00:13:46,330 --> 00:13:51,140
또한 ADMIN을 운영하는 대상이 여러 명일 수도 있는데요

203
00:13:51,160 --> 00:13:54,810
그래서 그 그룹을 나누고 그 그룹의 권한을 주거나 해서

204
00:13:54,830 --> 00:13:59,780
ACL 설정을 해서 방송모델제어액션별 그룹 및 권한을 부여 할수 있습니다

205
00:13:59,810 --> 00:14:05,210
그래서 특정한 쇼를 맡은 특정한 관리자 그룹은 그 쇼만 볼 수 있도록 하고

206
00:14:05,230 --> 00:14:10,780
이런 것도 쉽게 Django ADMIN으로 ACL을 설정할 수 있었던 것 같아요

207
00:14:10,810 --> 00:14:13,720
Django Admin에서 모델의 필요조건이 당시에 뭐였냐면요

208
00:14:13,960 --> 00:14:17,240
서비스 스펙을 변경하는 가능성을 예측하면서

209
00:14:17,250 --> 00:14:20,100
미리 모델을 정의할 필요가 있었기 때문에

210
00:14:20,500 --> 00:14:22,190
약간 좀 유연하게 만들었어요

211
00:14:22,210 --> 00:14:27,110
그래서 항상 required하면서 확정적이고 정치적인 스펙 그런 필드들이 아닌 이상

212
00:14:27,510 --> 00:14:30,470
계속 유저들의 입맛에 맞게 기능이 바뀔 때면

213
00:14:30,490 --> 00:14:34,500
그에 맞춰서 필드들도 사라질 수도 있고 있을 수도 있고

214
00:14:34,520 --> 00:14:38,230
뭐 릴레이션도 사라지거나 새로 생기거나

215
00:14:38,250 --> 00:14:40,380
그럴 수 있기 때문에 유연성이 필요했습니다

216
00:14:40,390 --> 00:14:42,850
그래서 Field.blank = true를 주로 많이 줬구요

217
00:14:42,880 --> 00:14:47,220
그래서 default도 공란으로 주고 0 주고 null도 허용해서

218
00:14:47,500 --> 00:14:49,840
지속변경 가능한 스펙의 대응이 용이하도록

219
00:14:49,870 --> 00:14:52,110
그렇게 처음에 DB 스키마를 짰습니다

220
00:14:52,300 --> 00:14:57,020
그래서 참조 필드가 지워지더라도 기능이나 릴레이션이 사라지더라도

221
00:14:57,050 --> 00:15:01,410
on_delete할 때 그 참조하는 모델을 SET_NULL로 쓰고

222
00:15:01,440 --> 00:15:04,270
NULL로 된 건 또 API에서 내려주면 안 되잖아요

223
00:15:04,290 --> 00:15:07,390
그래서 objects에서 exclude를 먼저 한 다음에

224
00:15:07,390 --> 00:15:09,820
그래서 None인 것들을, 있는 것들만

225
00:15:09,850 --> 00:15:14,170
참조 가능한 것들만 해서 참조 불가를 방어를 했습니다

226
00:15:14,200 --> 00:15:17,330
그래서 그런 식으로 먼저 스키마를 짰고요

227
00:15:17,620 --> 00:15:20,850
또 이제 Field.choices를 쓰는데

228
00:15:20,870 --> 00:15:27,400
이제 뭐 이게 요일이나 날짜 이런 월화수목금은 안변하겠지만

229
00:15:27,430 --> 00:15:32,130
추가적으로 장르를 계속 추가한다거나 이런 것은
enum set을 계속 변경, 배포해야 되거든요

230
00:15:32,150 --> 00:15:36,550
이걸 정의를 어디다가 해서 하는 것보다 차라리 필드를

231
00:15:39,330 --> 00:15:41,960
이렇게 정의를 하면 DB를 migration하기 때문에

232
00:15:41,990 --> 00:15:45,250
그냥 Foreign key choices를 모델로 따로 만들어가지고

233
00:15:45,280 --> 00:15:49,530
그렇게 관여하는 게 좋았었어요 그렇게 참조해서 쓰는 게 차라리 낫죠

234
00:15:50,260 --> 00:15:53,390
장르들도 계속 추가되고 뭐 분류도 추가될 텐데

235
00:15:54,140 --> 00:15:58,810
그래서 그에 대한 팁으로는 이제 모델 최종 변경일자를

236
00:15:58,830 --> 00:16:04,360
DateTimeField명으로 update로 정의하는 예제들이 좀 인터넷에 있었는데

237
00:16:04,390 --> 00:16:08,840
근데 update는 그 queryset.update 메소드랑 혼동이 일어나기 때문에

238
00:16:08,860 --> 00:16:12,730
모델 스키마 정의시 update 대신 다른 필드명 사용을 권장하는 편입니다

239
00:16:12,750 --> 00:16:16,010
그래서 update는 안 쓰시면 좋을 것 같습니다

240
00:16:16,040 --> 00:16:23,330
네 이렇게 update를 update.. 아 네 끔찍하죠. 이상입니다

241
00:16:24,040 --> 00:16:27,220
그다음에 Django Admin View에서 비즈니스 로직을 다 하실 수 있습니다

242
00:16:27,250 --> 00:16:32,970
아까 말씀드린 것처럼 custom form이나 custom actions인데요

243
00:16:33,250 --> 00:16:38,640
이 custom action을 추가하다 보면 readonly_fields를 추가하지 않으면

244
00:16:38,980 --> 00:16:44,180
custom_action_funcion이 정의 되어 있는데 Unknown field(s)로 뜨기 때문에

245
00:16:44,980 --> 00:16:47,140
readonly_fields를 두시는 걸 추천드리고요

246
00:16:47,800 --> 00:16:50,530
그래서 이건 FieldError를 방지하기 위한 팁이고

247
00:16:50,830 --> 00:16:55,600
custom action 기반 form 페이지 추가시 Admin custom form을 활용을 하는데

248
00:16:55,630 --> 00:16:57,990
Admin 안에서 다 해결할 수 있는 게 되게 좋은 거 같애요

249
00:16:58,020 --> 00:17:01,870
그래서 admin.actions를 정의 하고 admin.form도 정의를 한 다음에

250
00:17:01,900 --> 00:17:04,790
그 폴더 안에 templete 폴더도 customized form을

251
00:17:04,810 --> 00:17:10,200
이제 뒤에 나올 UI와 UX에 맞춰서
이제 정의를 하시면 쉽게 짤 수 있는 거죠

252
00:17:10,740 --> 00:17:14,220
또 Django에서 이제 메시지가 디폴트로 있잖아요

253
00:17:14,250 --> 00:17:17,250
context_processors.messages가 있는데

254
00:17:17,280 --> 00:17:23,890
그래서 그 customized forms, actions를
관리자가 사용한 다음에 결과를 알길 원하는데

255
00:17:23,920 --> 00:17:29,410
그 결과를 알기 원하는 페이지가 바뀌어도 잘 보여주고요

256
00:17:29,440 --> 00:17:35,030
그리고 결과에 대한 값도 이제 success, error, info,
Warning, debug 이렇게 다섯 가지가 있는데

257
00:17:35,050 --> 00:17:37,810
이것도 형형색색으로 나타낼 수 있더라고요

258
00:17:37,830 --> 00:17:39,570
그래서 이런 팁도 있고요

259
00:17:39,600 --> 00:17:44,940
그래서 또 이러한 customized actions랑 form을 철회를 할 때

260
00:17:44,970 --> 00:17:48,070
Request를 처리가 되게 길고 동기로 처리했을 때

261
00:17:48,700 --> 00:17:55,850
Response 504 Gateway Time-out
이 나더라도 더블메시지에서는 결국 실행이 됐더라구요

262
00:17:55,870 --> 00:17:59,150
그래서 그런 경험 또한 공유하고 싶습니다

263
00:17:59,810 --> 00:18:05,820
그래서 Django는 튼튼하게 잘 그러한 비즈니스 로직 커스터마이즈 로직을 수행할 수 있는

264
00:18:05,850 --> 00:18:09,690
그런 ADMIN 커스터마이제이션 기능이죠

265
00:18:10,780 --> 00:18:15,350
마지막 탬플릿은 이제 관리자가 원하는 기능별로 접근할 수 있는 메뉴를 구성할 수도 있고

266
00:18:15,380 --> 00:18:18,180
UI와 UX 이렇게 구성할 수 있는 거죠

267
00:18:18,200 --> 00:18:23,910
그래서 2017 파이콘 KR에 좋은 슬라이드가 있는데 이걸 한 번 참조하시면 좋을 것 같고요

268
00:18:23,930 --> 00:18:28,910
그래서 그렇게 모듈화시킨 그런 템플릿도 이제 상속으로 해서

269
00:18:28,930 --> 00:18:31,400
공통화 가능한 기능 모델을 확장하고

270
00:18:31,630 --> 00:18:38,370
그런 식으로 써서 한 번에 바꿀 때에 html 여러 번 바꾸는 것보다

271
00:18:38,400 --> 00:18:42,780
그 모듈을 바꿔 가지고 바꾸는 그런 생산성적인 면이 좋았던 것 같아요

272
00:18:43,840 --> 00:18:50,190
그래서 종합해서 1, 2, 3 모델, 뷰, 템플릿을 말씀 드렸는데

273
00:18:50,260 --> 00:18:53,680
그걸 통해서 방송을 처음 시작한다고 해봅시다

274
00:18:53,700 --> 00:18:55,650
그래서 신규 방송을 런칭하는데

275
00:18:55,670 --> 00:19:03,020
컨텐츠 분류 정보를 처음에 모델에 기입을 하기 위해서
Admin을 쓰겠죠 모듈을 정의한 걸로

276
00:19:03,070 --> 00:19:08,560
그래서 그걸 이제 model단에서 정의한 거를

277
00:19:09,050 --> 00:19:11,970
ADMIN의 view단에서 customized action이나

278
00:19:12,000 --> 00:19:15,580
customized form으로 방송 시작을 하고 종료까지 합니다

279
00:19:15,610 --> 00:19:19,600
그래서 시작할 때는 온에어 플래그를 true로 뒀다가

280
00:19:20,440 --> 00:19:22,790
false로 한 것 처럼

281
00:19:24,040 --> 00:19:28,300
그래서 그렇게 시작 종료가 끝나면

282
00:19:28,330 --> 00:19:32,150
기록을 아카이빙하고 그 걸 예쁘게 템플릿으로 볼 수도 있고요

283
00:19:32,180 --> 00:19:38,200
그래서 방송 이름을 TextField로 정의하고
시작종료는 BooleanField,

284
00:19:38,230 --> 00:19:43,480
노출 순서도 API에서 어떤 방송이 맨 처음에 나와야 할지 보여드려야 되잖아요

285
00:19:43,510 --> 00:19:50,370
그래서 그 순서를 1,2, 3, 4로 정의했으면 IntegerField에
저장을 해서 보여줄 수 있는 거죠 API에서 순서를 그렇죠

286
00:19:50,740 --> 00:19:57,360
방송시작과 종료에서는 시작에서 종료 사이에서는 API 정의든 노출 순서든

287
00:19:57,480 --> 00:19:59,930
그러니까 IntegerField에 정의된 걸로 노출하고

288
00:19:59,950 --> 00:20:03,490
그 다음에 BooleanField에서 true, false로 줘가지고

289
00:20:03,730 --> 00:20:09,580
뭐 보여줄건 보여주고 안 보여 줄 건 안 보여주고
방송시작한 건 보여주고 종료한건 false로 안 보여줘야 되겠죠

290
00:20:10,000 --> 00:20:12,820
방송 종료 후 방송 기록 및 연관 분류는 업데이트 합니다

291
00:20:13,530 --> 00:20:16,370
방송 시작 종료가 사실

292
00:20:17,560 --> 00:20:22,120
유저 입장에서 클라이언트에서 보여지는
게 다 인데 기록을 업데이트할 필요성이 있고

293
00:20:22,210 --> 00:20:26,730
연관된 데이터 모델들을 저장을 또 해줘야 된다면

294
00:20:26,750 --> 00:20:30,980
model save method override해서 재정의 한다던가

295
00:20:31,000 --> 00:20:37,100
아니면 signals의 host save model을 통해서

296
00:20:37,130 --> 00:20:41,180
그 모델이 저장된 이후에 action도 어떻게 정해준 거죠

297
00:20:41,200 --> 00:20:46,660
예를 들어서 시청률을 결국 집계해 보니까 몇 %인데
그걸 저장해줘야 된다 그래서 그걸 나중에 저장해 주고

298
00:20:46,690 --> 00:20:52,520
일단 방송은 끊어줘야 되니까 그렇게 시간차가 있는 것도 다룰 수 있는 것 같구요

299
00:20:53,230 --> 00:20:55,570
이제부터는 API를 좀 얘기해보겠습니다

300
00:20:55,600 --> 00:20:59,080
이제 DRF와 FastAPI를 구성하는 걸 이야기를 하는데요

301
00:20:59,110 --> 00:21:03,580
비동기 동기 캐싱 논캐싱 이러한 걸로도 분류할 수 있는데

302
00:21:03,610 --> 00:21:08,960
예를 들어서 지금 제가 당면했던 스펙이 이렇게 개인화 필요 없이

303
00:21:08,980 --> 00:21:14,040
뭐 장르별로 이 방송이 나와야 되고 이 방송에 나와야
되고 이런 거는 캐싱이 가능한 스펙이잖아요

304
00:21:14,070 --> 00:21:16,600
그래서 이런 건 캐싱 가능한 API로 만들었고

305
00:21:16,620 --> 00:21:20,090
한편 캐싱이 없는 API는 예를 들어서

306
00:21:27,610 --> 00:21:28,800
소리가 크네요

307
00:21:29,070 --> 00:21:32,190
아무튼 지금처럼

308
00:21:32,950 --> 00:21:36,460
댓글 정보나 노래 정보 같은 경우에는 실시간으로 캐싱 없이 나와야 되잖아요

309
00:21:36,490 --> 00:21:38,050
되게 빠르게 지나가는 것 같은데

310
00:21:38,050 --> 00:21:38,060
그래서 그러한 요소들을 캐싱 없이 보여주어야 할 때는
되게 빠르게 지나가는 것 같은데

311
00:21:38,060 --> 00:21:42,230
그래서 그러한 요소들을 캐싱 없이 보여주어야 할 때는

312
00:21:42,260 --> 00:21:44,100
그렇게 캐싱없는 API를 구성했던 것 같습니다

313
00:21:44,560 --> 00:21:49,440
이 이미지는 저희 사용자분 블로그에서 가져왔습니다

314
00:21:49,470 --> 00:21:50,350
이건 캡쳐이구요

315
00:21:51,670 --> 00:21:53,980
이것도 그 사용자분 블로그에서 가져온건데

316
00:21:53,990 --> 00:21:57,770
그래서 대중 혹은 개인화된 캐싱 유무랑

317
00:21:57,820 --> 00:22:02,920
이게 또 포털메인에 들어가 있으니까 대규모의 유저 리퀘스트를 받아야 되는데

318
00:22:03,730 --> 00:22:07,080
근데 유저가 이러한 정보들을 알림받기를

319
00:22:07,100 --> 00:22:12,560
클릭을 많이 하면 그걸 받아야 될 거고 유저별 캐싱 없이 그런 고민도 있었고요

320
00:22:12,800 --> 00:22:18,180
한편으로는 데이터 프리 이런 정보들은 대개 정적이고 안 바뀌는 거잖아요

321
00:22:18,200 --> 00:22:21,540
서비스 소개 같은 건데 그래서 이런 건 또 캐싱 없이 받아줘야 되고

322
00:22:22,800 --> 00:22:27,920
실시간 라이브를 할 때는 이제 유저별
캐싱 없이 댓글들을 다 받아줘야 돼서

323
00:22:27,950 --> 00:22:29,440
그런 고민이 되게 많았습니다

324
00:22:29,470 --> 00:22:32,430
그걸 한번 분류를 해 놨어요 그래서 유형별로 받을 수 있게

325
00:22:32,460 --> 00:22:35,890
뭐 정보 제공 대상이나 정보 중지 기간

326
00:22:35,920 --> 00:22:38,030
그 다음에 그 정보를 호출하는 빈도

327
00:22:38,040 --> 00:22:40,840
한번 받는지 계속 읽지 않으면 갱신하는 빈도 이렇게

328
00:22:41,090 --> 00:22:43,420
항상 나눠가지고 구분을 했었고요

329
00:22:43,450 --> 00:22:46,060
그래서 그거에 맞는 API 구성을 했던 것 같습니다

330
00:22:48,400 --> 00:22:51,510
그래서 API 캐싱은 예를 들어서 캐싱 자체가

331
00:22:51,540 --> 00:22:56,320
뭐 Django 파이썬 low-level에서도 LRU 캐시가 있고

332
00:22:56,350 --> 00:23:01,660
직접 캐싱이 많을 수도 있고 Django 자체는
page 혹은 site 캐싱을 할 수도 있고

333
00:23:02,520 --> 00:23:06,150
그다음에 덤프를 뜨는 경우에는 파일이나 DB 저장할 수 있잖아요

334
00:23:06,170 --> 00:23:09,430
그걸 캐싱으로 떨구든지 아무튼

335
00:23:09,450 --> 00:23:13,620
그래서 시간적으로 대응할 때는 타임아웃을 대게 쓰죠

336
00:23:14,050 --> 00:23:18,400
여러분들 Django 쓰시는 분은 다 아시다시피 근데 그걸 쓰는데

337
00:23:18,430 --> 00:23:23,370
예를 들어서 100% 개인화 정보구성 API를
구성할 때는 대규모 유저로 받을 때는 그

338
00:23:23,400 --> 00:23:27,210
그 해더로 유저를 구분하는 건 잘 캐싱이 풀리더라고요

339
00:23:27,230 --> 00:23:32,010
그래서 쿠키로 받는 게 더 서비스가 안정성 면에서

340
00:23:32,030 --> 00:23:35,570
유저 단위로 구분할 수 있고 그러한 캐싱이 좋았던 것 같습니다

341
00:23:35,720 --> 00:23:41,660
그래서 그렇게 쓰거나 캐싱 아에 안 쓰는 것도
100% 개인화 정보구성API 캐싱이 좋은 것 같구요

342
00:23:41,890 --> 00:23:50,630
인메모리 캐시 내지 Django 캐시를 쓰다 보면
글로벌한 캐싱이 필요할 수도 있는데

343
00:23:50,980 --> 00:23:55,360
파이썬에서 ARCUS memcached-based Cache Cloud가 있어요

344
00:23:55,390 --> 00:23:59,210
그래서 이걸로 쓰면 대게 여러 서버에서도

345
00:23:59,230 --> 00:24:03,010
settings.py의 DB처럼 연결해 두고 쓰기에 되게 좋았던 것 같습니다

346
00:24:04,480 --> 00:24:07,760
이제 API을 만약에 배포를 하게 되면 유저가 얼마나 나올지 모르잖아요

347
00:24:07,790 --> 00:24:12,610
그래서 load 그러니까 부하를 ramp-up 테스트해서 점점 부하를 늘려보면서

348
00:24:12,640 --> 00:24:14,980
nGrinder로 늘려서 하거나

349
00:24:15,000 --> 00:24:19,030
아니면 python locust으로 100%의 테스트 케이스를 짤 수 있는 거잖아요?

350
00:24:19,060 --> 00:24:21,790
그래서 되게 좋은데 그걸로 테스트를 했었고요

351
00:24:21,820 --> 00:24:26,990
API 테스트의 배포 대상으로는 이제 아까 말씀드린
DRF uWSGI Emperor mode로

352
00:24:26,990 --> 00:24:31,440
Emperor, 군주죠 vassals, 신하들 해석은

353
00:24:31,630 --> 00:24:33,940
어코드를 방해할 수 있는 그런 모드로 했었고

354
00:24:33,940 --> 00:24:33,950
그 다음에 Graceful Reload에서 리퀘스트를
어코드를 방해할 수 있는 그런 모드로 했었고

355
00:24:33,950 --> 00:24:36,760
그 다음에 Graceful Reload에서 리퀘스트를

356
00:24:37,800 --> 00:24:40,250
코드의 변경이 있었는데 왜 업데이트를 해주려면

357
00:24:40,270 --> 00:24:46,450
변경 배포를 하려면 기존 봤던 리퀘스트를 다 response 해주고

358
00:24:46,480 --> 00:24:50,890
그다음에 Reload 해주는 방식으로 되게 깔끔하게 변경 배포를 해주었습니다

359
00:24:50,920 --> 00:24:55,520
FastAPI 같은 경우도 Uvicorn이라는 ASGI를

360
00:24:55,540 --> 00:24:58,060
uWSGI 대신에 쓰는 걸로 보시면 되는데요

361
00:24:58,090 --> 00:25:04,250
이제 lru_cache가 디폴트 데코레이터로 있어요

362
00:25:04,280 --> 00:25:07,450
그래서 원래는 파이썬 Functools에 내장된 캐싱이잖아요

363
00:25:07,480 --> 00:25:11,290
그런데 여기에 보시면 쉽게 캐싱할 수 있도록 되어있고요

364
00:25:11,440 --> 00:25:15,310
비동기 너무 쉽게 캐싱할 수 있고 둘 다 빠른 다큐멘테이션도

365
00:25:15,340 --> 00:25:17,710
스웨거나 ReDoc UI로 이렇게 볼 수 있었던 것 같습니다

366
00:25:17,740 --> 00:25:21,520
아니면 drf-yasg 까시면 보실 수 있겠죠

367
00:25:21,550 --> 00:25:24,560
다음에 DRF viewsets ModelViewSet의 할당시

368
00:25:24,580 --> 00:25:28,270
정적 할당보단 get_queryset() override를 추천을 했네요

369
00:25:28,300 --> 00:25:34,020
혹시 ModelViewSet에서 queryset을 처음에
정적으로 할당하면 이게 모든 필드는 변경있을 시

370
00:25:34,070 --> 00:25:37,180
migration하면 또 Unknown field로 에러 나오고 그러거든요

371
00:25:37,210 --> 00:25:38,860
그래서 get_queryset 에서 하는 것도 좋고

372
00:25:38,890 --> 00:25:43,310
이게 아무리 캐싱하더라도 모델이 변하면 queryset도 바뀌어야 되고

373
00:25:43,340 --> 00:25:46,210
그런데 그런 대응해서는 queryset을

374
00:25:46,240 --> 00:25:48,040
처음에 뭐 이니셜레이션 하는 것보다

375
00:25:48,060 --> 00:25:52,200
get_queryset에서 하는 게 되게 잘 변하고 좋습니다

376
00:25:52,240 --> 00:25:54,620
그래서 get_queryset의 오버라이드를 추천드립니다

377
00:25:55,240 --> 00:26:04,090
개국이후에 서비스를 해야 하잖아요

378
00:26:04,840 --> 00:26:09,580
서비스를 하는데 방송별로 아티스트들도 많고

379
00:26:09,600 --> 00:26:12,550
그 아티스트를 좋아하는 유저들도 되게 많을 거란 말이예요

380
00:26:12,580 --> 00:26:18,170
그래서 어떤 방송을 밀어주고 어떤 방송에
어떠한 유저가 더 좋아하는지 이런 거를 알아야 되는데

381
00:26:18,510 --> 00:26:23,470
그걸 하기 위해서 통계의 정보를 일단 데이터 엔지니어링으로 구성하고

382
00:26:23,500 --> 00:26:27,690
그다음에 그렇게 얻은 정보들을 데이터 사이언스로 분석해서

383
00:26:27,720 --> 00:26:32,350
서비스를 나갈지 방향의 결정에 도움이 되었던 것 같습니다

384
00:26:32,380 --> 00:26:33,920
이걸 다 또 파이썬으로 했어요

385
00:26:33,950 --> 00:26:38,020
그래서 STAT 그니까 방송별 유저 활동 내지는

386
00:26:38,050 --> 00:26:40,990
리텐션 이런 것도 비즈니스인 인사이트 피드백을 필요로 하잖아요

387
00:26:41,020 --> 00:26:43,750
그래서 여기서도 Django Admin을 시도했습니다

388
00:26:43,780 --> 00:26:49,300
그래서 Celery를 썼는데 Celery를 프런트처럼
Beat라고 Celery Beat라고 쓸 수 있어요

389
00:26:49,330 --> 00:26:54,580
그래서 이걸 쓰면서 Celery Beat에 기록 또한

390
00:26:54,600 --> 00:26:57,260
scheduler로 DatebaseScheduler를 쓰면

391
00:26:57,290 --> 00:27:02,010
그 DB에 저장을 할 수 있습니다 배치 작업기록을 저장할 수 있고

392
00:27:02,510 --> 00:27:06,720
스케줄 또한 저장할 수 있어서 뭐 해 뜰때 시작 했다가 해 질때 하는

393
00:27:06,750 --> 00:27:08,390
그러한 솔라스케줄도 있고

394
00:27:09,940 --> 00:27:14,000
매주 몇요일마다 몇시마다하는 그런 크론탭 배치도

395
00:27:14,020 --> 00:27:16,190
쉽게 쓸 수 있었던 것 같습니다

396
00:27:16,220 --> 00:27:19,770
그래서 DatabaseScheduler 할때 좋았던 것 같구요

397
00:27:19,800 --> 00:27:22,350
그래서 배치 작업 기록이 전환이 좋고

398
00:27:22,370 --> 00:27:26,570
또 지금 Celery 브로커로 RabbitMQ나 redis가 있는데

399
00:27:26,590 --> 00:27:31,190
RabbitMQ 굳이 한 이유는 일단 Flower로 모니터링 해봤는데

400
00:27:31,220 --> 00:27:36,760
Redis broker를 썼을 때는 active task가 flickering 되겠더라고요

401
00:27:36,790 --> 00:27:41,540
어떤 말씀이냐면 이게 task를 실행시켜 놓고

402
00:27:41,560 --> 00:27:48,940
프로듀스를 해서 액티브인지 아닌지 1인지 0인지가 나와야 되는데

403
00:27:48,970 --> 00:27:54,130
RabbitMQ 했을때는 계속 1로 뜨는데 redis broker로
하면 계속했는지 1인지 0인지 왔다 갔다 하더라구요

404
00:27:54,160 --> 00:27:57,600
그래서 flickering 문제도 있었고 또 RabbitMQ 특성상

405
00:27:57,630 --> 00:28:01,120
더 메세지 큐 입장에서 이런 상태값들을 지원하는게

406
00:28:01,140 --> 00:28:05,340
Celery가 지원하는 그런 기능들이랑 더 맞아서

407
00:28:05,350 --> 00:28:13,490
그래서 Flower에서는 그 RabbitMQ를 Celery broker로 썼습니다

408
00:28:13,520 --> 00:28:16,020
그래서 그러한 팁을 드리고 싶고요

409
00:28:16,290 --> 00:28:19,040
그 Batch 결과가 나온 통계 같은 경우

410
00:28:19,060 --> 00:28:22,750
이제 뭐 시청률이나 이런 거를 각 방송별로 얻어낼 거 아니에요

411
00:28:22,780 --> 00:28:28,410
그래서 그 덤프를 모아서 전 세계에 유저들이 어떤
방송국의 선호도를 갖고 있고 그런 걸 봐야 되는데

412
00:28:28,430 --> 00:28:32,490
그래서 아까 캐쉬로 파일 덤프를 뜨거나 그런 것처럼

413
00:28:33,070 --> 00:28:36,380
그런 덤프들을 판다스의 데이터 프레임으로 데이터를 했고

414
00:28:36,460 --> 00:28:40,770
그다음에 데이터 프레임에 각 칼럼 그러니까 각 형질들이죠

415
00:28:40,810 --> 00:28:43,660
그래서 그거를 scikit-learn으로 분석하고 분류하고

416
00:28:43,690 --> 00:28:48,160
향후에 뭐 얼마나 더 들어올지
그런 서비스 추세를 예측하는데 쓰였던 것 같습니다

417
00:28:49,480 --> 00:28:55,810
이제 교육을 분석한 거를 이제 사람이 봐가지고 유의미한
지표는 뽑아가지고 서비스 방송에 반영을 해야 되잖아요

418
00:28:56,170 --> 00:28:59,770
특정 지을 수 있게 matplotlib.pyplot으로 시각화했는데

419
00:28:59,770 --> 00:29:03,850
되게 복잡하고 구성요소가 많기 때문에 간단하게 Jupyter notebook에서

420
00:29:03,880 --> 00:29:09,040
보길 원하실때는 데이터 프레임을 바로 쇼할 수도 있지만

421
00:29:09,070 --> 00:29:14,740
그 cufflinks라는 plotly를 포함하는 라이브를 설치하시면

422
00:29:14,770 --> 00:29:17,260
이 한 줄만으로 쉽게 잘 예쁘게 볼 수 있었던 거 같습니다

423
00:29:17,280 --> 00:29:18,660
그래서 그 방식을 추천드립니다

424
00:29:19,360 --> 00:29:24,410
그래서 제가 matplotlib으로 만약에 뽑은 이런 예시를 한번 보여 드리면

425
00:29:24,430 --> 00:29:27,000
유저들별로 어떤 특정 방송들을 좋아한다면,

426
00:29:27,000 --> 00:29:28,980
정기적으로 편성된 시간 중

427
00:29:29,030 --> 00:29:30,640
그러니까 여기 뭐 월화수목금이 있죠

428
00:29:30,670 --> 00:29:35,450
그래서 어떤 정규방송 중에도 특정 시간을 더 선호할 것 아니에요

429
00:29:35,470 --> 00:29:37,250
그래서 그런 것도 볼 수 있고

430
00:29:37,260 --> 00:29:40,380
다음에 방송에 나왔던 출연자들의 정량적인 효과

431
00:29:40,400 --> 00:29:44,240
그러니까 이 출연자가 몇 시간 정도 방송했을 때

432
00:29:44,260 --> 00:29:48,960
유저가 더 많이 들어왔다 그럼 출연시간당 청취자 수 계산을 볼 수도 있고

433
00:29:48,990 --> 00:29:53,500
뭐 이렇게 약간 상관관계도 양의 상관관계도 볼 수도 있고

434
00:29:53,530 --> 00:29:57,380
평균 밑에 있는 쇼들 내지 아티스트들은 어떤 게 있고

435
00:29:57,410 --> 00:30:02,710
평균 이상인 쇼 아티스트는 이런게 있어서 이러한 쇼 및 아티스트를 밀어주면

436
00:30:02,740 --> 00:30:06,130
이 서비스화하면 좋을 것 같다 인사이트가 될 수 있고요

437
00:30:06,160 --> 00:30:10,460
또한 이제 방송별로 겹치는 유저별 특성을 feature로 만들어서

438
00:30:10,480 --> 00:30:13,780
방송간 유사성을 볼 수도 있고 패턴을 분석해서

439
00:30:13,800 --> 00:30:18,520
방송들끼리 유저가 시간이 지날수록 많이 겹치면 이 패턴들이 보이잖아요

440
00:30:18,550 --> 00:30:20,720
패턴들을 이제 시각화해서

441
00:30:20,750 --> 00:30:24,480
어떤 방송에서 어떤 방송까지 유저가 이만큼 인입이 됐었고

442
00:30:24,970 --> 00:30:30,200
그렇게 그런 유사성 흐름과 방송유저 특색에 따른

443
00:30:30,230 --> 00:30:34,730
각종 성분 feature들 기반 sklearn.manifold.TSNE 머신러닝으로

444
00:30:34,750 --> 00:30:37,300
비슷한 성격의 방송들을 묶어 놓을 수 있고요

445
00:30:37,330 --> 00:30:40,120
그래서 되게 다양한 아까 형질이 많았는데

446
00:30:40,150 --> 00:30:45,740
그거를 이제 2차원 단순화해서 이렇게 군집된 방송군들과

447
00:30:45,770 --> 00:30:49,140
유저들의 성격을 묶어낼 수 있는 거죠

448
00:30:49,170 --> 00:30:55,500
이렇게 분열을 해서 유저플러스 방송 결합과 분류별 서비스 방송을 추진할 수 있는 거죠

449
00:30:55,520 --> 00:30:59,640
이 유저분에 맞는 이 방송국 이렇게 볼 수도 있고

450
00:31:00,160 --> 00:31:04,730
그래서 그러한 파이썬 데이터 트림이나
방송 서비스의 의사결정에

451
00:31:04,750 --> 00:31:07,960
STAT이 되게 도움이 된 것 같습니다

452
00:31:07,990 --> 00:31:12,590
파이썬으로 기반한 Stash와 데이터 엔지니어링 부터 데이터 사이언스

453
00:31:12,620 --> 00:31:17,020
그래서 실시간, 일간, 주간, 월간 방송별 시청률 집계 되게 많았어요

454
00:31:17,050 --> 00:31:20,490
되게 리텐션도 일간, 주간 이런 것도 많았는데

455
00:31:20,520 --> 00:31:24,010
아무튼 파이썬 Django Admin에서

456
00:31:24,040 --> 00:31:29,670
또 이게 Celery한 기록들이 또 Admin에서 바로 당길 수 있잖아요

457
00:31:29,690 --> 00:31:33,640
그래서 따로 UI 안 만들고 바로 Admin에서 보고

458
00:31:33,670 --> 00:31:40,480
이거를 또 이제 그 이렇게 시각화할 수 있을 뿐만 아니라

459
00:31:40,500 --> 00:31:45,400
Django 임포트 익스포트로 CSV이나 XLS로 추출할 수가 있습니다

460
00:31:45,430 --> 00:31:49,070
그래서 그 추출한 결과값을 정량적으로 분석할 수도 있고요

461
00:31:49,630 --> 00:31:51,710
또 이런 Batch job이 되게 길잖아요

462
00:31:51,730 --> 00:31:54,870
데이터 엔지니어링 하루가 걸릴 수도 있고 그렇기도 한데

463
00:31:54,900 --> 00:31:58,620
그래서 그런거가 나올지 계속 저희가 확인하는 풀링보다는

464
00:31:58,640 --> 00:32:01,840
실시간 라이브로 알림을 받는 걸 되게 추천드릴게요

465
00:32:02,400 --> 00:32:04,420
제가 코드를 간단히 써 봤습니다

466
00:32:04,450 --> 00:32:08,980
그래서 이렇게 헤더만 여기 들어가셔서 받으시면

467
00:32:09,000 --> 00:32:11,840
쉽게 메시지를 라인 메시지를 받을 수 있거든요

468
00:32:12,190 --> 00:32:15,870
그래서 실시간으로 라인이 오면 볼 수도 있고

469
00:32:15,900 --> 00:32:21,500
또 이제 라인봇을 저희 Django project.settings.LOGGING에 보시면

470
00:32:22,080 --> 00:32:25,010
그 Admin.EmailHandler를 상속해가지고

471
00:32:25,040 --> 00:32:28,400
아까 그 로깅해서 logstash로 보는 것 처럼

472
00:32:28,400 --> 00:32:28,410
그 라인 뒷 파일을 보낼 수 있거든요
아까 그 로깅해서 logstash로 보는 것 처럼

473
00:32:28,410 --> 00:32:31,660
그 라인 뒷 파일을 보낼 수 있거든요

474
00:32:31,690 --> 00:32:36,630
그래서 그 서버에러가 나는 걸 한 건도 놓치지 않고 실시간으로 받을 수 있어요

475
00:32:36,650 --> 00:32:43,510
그 생방송 중에도 스트리밍 오류가났고
그 오류를 복구을 했고 복구가 되었다 이런 것까지

476
00:32:43,550 --> 00:32:46,120
바로 자동으로 다 자동화시켰고

477
00:32:46,150 --> 00:32:49,320
그 결과를 바로 받을 수도 있을 뿐만 아니라

478
00:32:49,350 --> 00:32:55,090
어떤 에러가 나면 그 에러가 난 유저와 회원 아이디와 상대의 URL path

479
00:32:55,110 --> 00:32:59,530
그 에러가 난 파일의 위치 내지 URI 얘기겠죠

480
00:32:59,560 --> 00:33:04,000
그래서 그런 정보들 Traceback을

481
00:33:04,030 --> 00:33:07,480
그 파일에서 몇 번째 826번째 줄에서

482
00:33:07,510 --> 00:33:09,100
필드 참조 에러 오류가 났다

483
00:33:09,130 --> 00:33:15,190
그래서 그걸 만든 트리거가 된 그런 방식이 이 API를 통해서 된 거고

484
00:33:15,220 --> 00:33:18,690
그래서 그 유저아이디를 이렇게 제한이 됐다해서

485
00:33:18,690 --> 00:33:21,690
그런 에러까지도 Traceback으로 분석을 하고

486
00:33:21,720 --> 00:33:26,090
실시간으로 이제 대응을 할 수 있었던 것 같습니다

487
00:33:26,890 --> 00:33:30,310
마지막으로 Troubleshooting에 썼던 팁을 말씀드리면

488
00:33:30,330 --> 00:33:34,930
그 Django 프로젝트 정적, 전역 변수들은 settings.py에 보통 글로벌하게 선언하잖아요

489
00:33:34,960 --> 00:33:38,030
그래서 환경변수 선언으로 에러대응을 할 수 있고요

490
00:33:38,440 --> 00:33:42,910
주로 PycURL 관련해서 에러 대응한 것을 공유해드리고 싶은데

491
00:33:42,940 --> 00:33:46,480
SSL_LIBRARY=nss로 설치했을 때의 경우이고요

492
00:33:46,930 --> 00:33:51,280
PycURL로 아까 리퀘스트처럼
HTTP/2, HTTPS 호출시

493
00:33:51,310 --> 00:33:53,690
Memory Leak이 발생하는 현상이 있습니다

494
00:33:53,730 --> 00:33:58,530
이게 자체적인 NSS 관여한 거라서

495
00:33:58,550 --> 00:34:01,310
그래서 그 환경변수로 SDB로 설정해 놓으면

496
00:34:01,320 --> 00:34:03,280
이렇게 Memory Leak 해결할 수 있었구요

497
00:34:03,310 --> 00:34:07,560
이러한 링크를 참조하시는 걸 추천드리고요

498
00:34:07,930 --> 00:34:13,440
또 이제 PycURL을 멀티프로세스로 fork해서 호출시

499
00:34:13,460 --> 00:34:16,380
libcurl error로 호출 안될시 문제가 있는데요

500
00:34:16,420 --> 00:34:20,200
그래서 멀티프로세스로 하는 호출이 안 되더라고요

501
00:34:20,220 --> 00:34:28,230
그래서 그럴 때는 환경변수로
["NSS_STRICT_NOFORK"]="DISABLED" 설정하면

502
00:34:28,340 --> 00:34:30,260
에러를 되게 쉽게 해결했던 경험이 있습니다

503
00:34:30,280 --> 00:34:34,840
그런데 이거를 계속 정적으로 글로벌하게 다 쓰는 거니까

504
00:34:34,870 --> 00:34:36,590
settings.py에 설정하면 좋을 것 같습니다

505
00:34:36,620 --> 00:34:38,170
그래서 그런 팁을 드리고 싶습니다

506
00:34:40,000 --> 00:34:44,500
여태까지 되게 장황하기도 하면서 빠르게 설명을 한 번 드려 봤는데요

507
00:34:44,530 --> 00:34:48,450
그래서 저희 글로벌 방송국 서비스를

508
00:34:48,480 --> 00:34:52,170
이렇게 파이썬 및 Django를 통해서 쉽게 만들 수 있었고

509
00:34:53,390 --> 00:34:58,000
그런 생산성에도 도움이 되고 고가용적인 면에서도 캐싱을 잘써서

510
00:34:58,030 --> 00:34:59,560
이렇게 도움이 되었던 것 같습니다

511
00:34:59,590 --> 00:35:04,060
그래서 코드상으로는

512
00:35:04,090 --> 00:35:07,000
자세하게 설명드리지 않았지만 이렇게 볼 수 있고

513
00:35:07,030 --> 00:35:12,680
마지막으로 저와 일하는 것에 관심이 있으신
분들은 여기를 참조해 주시면 감사하겠습니다

514
00:35:12,760 --> 00:35:15,620
이상입니다. 들어주셔서 감사합니다

