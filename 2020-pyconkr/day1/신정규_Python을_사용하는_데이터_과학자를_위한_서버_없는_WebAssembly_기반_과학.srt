1
00:00:10,300 --> 00:00:13,276
안녕하세요. 오늘 발표를 맡게 된 신정규입니다


2
00:00:13,300 --> 00:00:14,862
오늘 발표를 할 주제는


3
00:00:15,370 --> 00:00:23,370
파이썬을 사용하는 데이터 과학자들을 위한 서버가
필요없는 WebAssembly 기반의 과학 연산 환경 만들기입니다 

4
00:00:24,430 --> 00:00:29,568
저는 레블업이라는 회사를 동료들과 함께 시작을 해서


5
00:00:29,593 --> 00:00:32,186
현재 Backend.AI 라는 플랫폼을 만들고 있고요


6
00:00:32,770 --> 00:00:37,715
딥러닝 워크로드를 클러스터 위에서 분산 처리하는 플랫폼입니다


7
00:00:38,710 --> 00:00:43,569
그 과정에서 다양한 파이콘 발표를 할 수가 있었는데요


8
00:00:44,230 --> 00:00:47,855
고맙게도 계속 기회를 주셔서 2015년부터 여러 발표를 할 수 있었습니다


9
00:00:48,280 --> 00:00:50,951
회사에 역사와 파이콘의 역사가 사실 같이 가는대요


10
00:00:51,420 --> 00:00:53,802
처음에는 저희가 만든 플랫폼을 소개를 드렸었고


11
00:00:54,045 --> 00:00:58,521
그 다음회와 그 다음회는 이제 저희가 사이드로 만들면 챗봇과


12
00:00:58,546 --> 00:01:02,225
그 챗봇의 알고리즘이나 구현에 대해서 설명을 드렸었습니다


13
00:01:02,650 --> 00:01:07,446
그리고 머신러닝 워크샵이나 아니면 이제 스프린트도 함께 진행을 했었고요


14
00:01:07,870 --> 00:01:14,541
그 다음에는 이제 겸임교수를 하면서 학생들을
가르치면서 느낀 점에 대해서 소개를 드리고 

15
00:01:14,830 --> 00:01:21,616
작년 같은 경우에는 이제 한 4년 정도 Backend.AI를
만들면서 기술적으로 해결했어야 하는 점들, 

16
00:01:21,640 --> 00:01:26,952
설계할 때 미리 고려를 못했던 점들
뭐 이런 것들을 굉장히 길게 소개를 드렸었어요 

17
00:01:28,330 --> 00:01:34,275
그런데 올해는 갑자기 코로나 이슈가 터졌죠


18
00:01:35,200 --> 00:01:41,301
그래서 거의 8개월째 주말에도 놀지도
못하고 저는 착실하게 갖혀서 일만하고 있는데 

19
00:01:41,530 --> 00:01:47,217
머릿속에 뭔가 되게 복잡한 생각들이 여러 가지가
있었다가 이제 다 없어지고 그냥 놀고 싶은 생각만 남았습니다 

20
00:01:47,770 --> 00:01:53,691
그래서 이번 파이콘 주제도 사실 제가 원래
조금 더 본격적으로 하고 있는 일이 아니라 

21
00:01:54,460 --> 00:01:58,545
작년부터 계속 창고에 있다가 이 코로나가 준 기회 때문에


22
00:01:58,570 --> 00:02:03,631
창고에서 꺼내서 한 사이드 프로젝트를 소개해드리게 될 거예요


23
00:02:03,983 --> 00:02:07,967
그 사이드 프로젝트의 기반 프로젝트인 Iodide 등에 대해서


24
00:02:07,992 --> 00:02:12,476
어떻게 이런 것들이 필요하게 되었는가 
어떻게 프로젝트를 시작하게 되었는가 

25
00:02:12,500 --> 00:02:14,734
뭐 이런 것들을 소개를 같이 드릴 예정입니다


26
00:02:15,400 --> 00:02:18,507
그래서 오늘 설명드릴 것은 파이썬에 대해서 간단하게 소개해드리고


27
00:02:18,532 --> 00:02:21,641
그 다음에 과학 연산과 과학 연산 환경에 대해서 소개해 드리겠습니다


28
00:02:21,940 --> 00:02:24,666
그 다음에 연산자원에 대해서 소개를 해드린 다음에


29
00:02:25,030 --> 00:02:27,444
갑자기 웹이랑 모질라 말씀을 드릴 거예요


30
00:02:27,936 --> 00:02:31,486
그 다음에 Iodide Project라는 프로젝트에 대해서 소개를 드리고


31
00:02:31,510 --> 00:02:35,041
그 하위 프로젝트인 Pyodide에 대해서도 소개를 해드리겠습니다


32
00:02:35,410 --> 00:02:39,706
그 다음에 이걸 가지고 처음에 들었던 여러 가지 생각으로 테스트를 해보고


33
00:02:39,730 --> 00:02:43,956
그 다음에 이건 이런 것들이 더 되면 쓸만하겠는데 라고 생각을 해서


34
00:02:44,401 --> 00:02:49,246
생각이 들어서 개발했던 여러 가지 코드에 대해서 설명을 드리고


35
00:02:49,270 --> 00:02:52,876
그걸로 데모를 하고
그 다음에 이걸로 어떤 것들을 더 해볼 수 있을까? 

36
00:02:52,900 --> 00:02:58,189
아니면 여러분들이 이걸 기반으로 무엇을 더 해볼 수
있을까에 대해서 생각하면서 마무리 지어보도록 하겠습니다 

37
00:02:59,950 --> 00:03:02,910
제가 파이썬을 하게 된 지 이제 11년이 됐는데요


38
00:03:02,973 --> 00:03:06,723
2010년에 이제 김준기님께서


39
00:03:06,748 --> 00:03:11,519
지금 C++ 만 쓰던 저에게 파이썬을 권장을 해주셔서 강제로 쓰게 됐는데


40
00:03:11,800 --> 00:03:14,846
지금은 뭐 거의 모든 코딩을 파이썬으로 하고 있죠


41
00:03:15,640 --> 00:03:23,569
초보자 한테만 좋은 언어가 아니라 과학 연산이나
뭐 비주얼라이제이션에도 굉장히 좋은 언어입니다 

42
00:03:23,980 --> 00:03:28,690
현재는 빅데이터 분석 뿐만 아니라
머신러닝이나 딥러닝에도 굉장히 널리 쓰이고 있죠 

43
00:03:29,140 --> 00:03:31,772
최근에 줄리아가 굉장히 성장을 하고 있지만


44
00:03:31,797 --> 00:03:35,359
이 범용성 때문에 파이썬의 위치는 당분간 계속될 것으로 보입니다


45
00:03:36,430 --> 00:03:39,287
글로벌 인터프린터 락 때문에 느리다는 편견도 있지만


46
00:03:39,312 --> 00:03:44,226
사실 Cython과 multiprocessing을 잘 조합을 해서 쓰면은


47
00:03:44,251 --> 00:03:45,946
충분히 성능이 나오기 때문에


48
00:03:45,970 --> 00:03:48,640
거대 과학연산에도 널리 쓰이고 있습니다


49
00:03:49,270 --> 00:03:53,574
그리고 파이썬이 처음 시작은 다양한 종류의 과학 연산 라이브러리들을


50
00:03:53,598 --> 00:03:55,551
퓨어 파이썬으로 구현을 하지 않고


51
00:03:55,900 --> 00:04:00,434
이미 잘 만들어진 여러 라이브러리들을 같이 이식을 하는 식으로 발전을 했어요


52
00:04:00,850 --> 00:04:03,466
그리고 파이썬 언어 자체가 굉장히 유연하기 때문에


53
00:04:03,490 --> 00:04:06,052
기존에 나와 있는 다른 언어로 만든 구현제를


54
00:04:06,857 --> 00:04:11,341
잘 가져와서 인터페이스를 붙이는데 굉장히 유용하게 사용할 수 있습니다


55
00:04:11,366 --> 00:04:13,669
글로벌 랭귀지로 많이 사용을 할 수가 있죠


56
00:04:13,880 --> 00:04:19,067
사실 키보드로 짜는 모든 언어의 결과물은 파이썬과
잘 붙는다고 생각을 하셔도 과언이 아니겠습니다 

57
00:04:20,830 --> 00:04:22,392
그러면 과학연산은 무엇이냐?


58
00:04:23,345 --> 00:04:24,886
과학용 연산이겠죠


59
00:04:24,910 --> 00:04:28,199
그런데 과학용 연산 하면 얼마나 하겠어 라고 생각을 하실 텐데


60
00:04:28,930 --> 00:04:34,672
인류가 전기를 쓰는 양이 얼마나 되는지 생각을
한번 해보면 되게 깜짝 놀라실 수가 있습니다 

61
00:04:35,200 --> 00:04:37,621
전기, 그걸 대체 어디다 쓸까요?


62
00:04:37,653 --> 00:04:41,836
오피스에도 전기 쓸 수 있겠죠


63
00:04:41,860 --> 00:04:47,914
게임, 게임에도 전기를 굉장히, 요새는 게임이 더
많이 있을 것 같기도 합니다 과학 연산보다는 어쨌든 

64
00:04:48,070 --> 00:04:53,655
그런데 인류는 과학연산에 전기를 어마어마하게 소모하고 있습니다 여러분


65
00:04:54,250 --> 00:04:56,445
정말 엄청난 양을 소모 하고 있어요


66
00:04:56,950 --> 00:05:02,114
뭐 비공식 통계로는 예를 들면 컴퓨테이션에
사용되는 전체 전기량 중의 

67
00:05:02,139 --> 00:05:05,020
90%를 과학 연산에 사용된다는 통계도 있었죠


68
00:05:06,070 --> 00:05:11,741
여러분 과학연산은 여러분들이 생각하는 것처럼 뭔가
최신의 기술들을 동원해서 만들어지거나 하지는 않습니다 

69
00:05:12,700 --> 00:05:17,637
의외로 들어가면 여러분들이 지금 보기가
힘든 포트란 언어로 된 코드들이 굉장히 많습니다 

70
00:05:17,980 --> 00:05:24,237
사실 한번 검증이 된 라이브러리들은 손을 안 대는 것이
과학연산의 불문율이기 때문에 

71
00:05:25,210 --> 00:05:31,561
모든 이런 매트릭스 연산의 기본이 되는 IMSL이나
이런 것들은 포트란으로 아직도 만들어지는 경우들이 많아요 

72
00:05:32,030 --> 00:05:36,226
그리고 BLAS나 이제 뭐 선형 대수를 위한 Linear Algebra 패키지나


73
00:05:36,250 --> 00:05:42,703
아니면 약간 궤를 벗어나서 멀티 CPU에서 이제 뭐
루프를 나눠서 돌릴 때 쓰는 OpenMP 같은 툴들도 있죠 

74
00:05:43,001 --> 00:05:46,171
그리고 이런 것들을 GPU와 묶어서 가속을 하기 위해서


75
00:05:46,196 --> 00:05:49,828
CUDA라이브러리을 사용한 cuBLAS나 cuLAPACK 같은 것들도 있습니다


76
00:05:51,130 --> 00:05:57,559
다음에 이제 GNU 진영에서도 이제 역사와 전통을 자랑하는 
GNU Scientific Library가 있고 

77
00:05:57,584 --> 00:06:01,950
그 다음에 유럽에 있는 CERN에서 개발해서 사용하고 있는 ROOT도 있죠


78
00:06:02,350 --> 00:06:09,270
그 다음에 이제 포트란 말고 다른 언어로
이런 가장 기본적인 연산해보자 

79
00:06:09,295 --> 00:06:12,998
이래서 나왔던 게 Numerical Recipes. C++랑 C버전이 있습니다


80
00:06:13,360 --> 00:06:17,469
그리고 이런 것들을 잘 묶어서 이제 numpy나 scipy가 나와 있죠


81
00:06:17,830 --> 00:06:21,908
그래서 얘네들을 컴파일할 때 보시면 항상 포트란이 필요합니다


82
00:06:24,280 --> 00:06:30,365
그러면 이런 것들을 기반으로 Scientific
Environments 과학환경, 연산환경이 필요하게 되는데 

83
00:06:30,850 --> 00:06:33,248
라이브러리나 플랫폼이나 컨테이너 등이 있습니다


84
00:06:33,730 --> 00:06:38,347
라이브러리는 이제 뭔가 컴퓨터로 계산하실 때 한 번쯤 써보셨을


85
00:06:38,800 --> 00:06:43,464
NumPy도 있고 그 다음에 그걸 기반으로
만든 다양한 종류의 과학연산하는 SciPy도 있구요 

86
00:06:43,628 --> 00:06:44,926
데이터를 다루는 Pandas도 있구요


87
00:06:44,950 --> 00:06:47,656
이제 비주얼라이제이션을 담당하는 Matplotlib


88
00:06:47,680 --> 00:06:54,307
그 다음에 이제 여러 가지 머신러닝에 관련된
알고리즘을 모아놓은 SciKit-Learn 등이 있습니다 

89
00:06:54,670 --> 00:07:01,666
그 다음에 이런 여러 라이브러리들을 묶어서 파이썬
언어와 함께 조합한 플랫폼도 여러 가지가 있는데요 

90
00:07:01,690 --> 00:07:05,361
뭐 많이 들어보셨을 Anaconda도 있고 Canopy 이런 것도 있고


91
00:07:05,393 --> 00:07:08,297
유료인 ActivePython같은 툴들도 있고요


92
00:07:08,322 --> 00:07:12,814
뭐 PyIMSL나 Python(x,y) 처럼 윈도우 환경의
비주얼라이제이션에 특화된 그런 툴들도 있죠 

93
00:07:13,420 --> 00:07:18,496
그 다음에 이런 것들을 최근에 유행하고 있는 컨테이너
환경에서 돌리기 위해서 컨테이너 이미지로 만든 것들도 있습니다 

94
00:07:18,520 --> 00:07:21,754
뭐 NVIDIA GPU Cloud에 다양한 종류의 라이브러리들도 있고


95
00:07:21,779 --> 00:07:23,909
이제 MLWorkspace같은 것도 있고


96
00:07:23,934 --> 00:07:27,902
저희가 직접 만들고 있는 Backend.AI
Scientific Kernels같은 경우도 거기에 해당하겠죠 

97
00:07:29,530 --> 00:07:33,551
이런 환경들을 기반으로 어마어마하게 연산을 많이 합니다


98
00:07:33,576 --> 00:07:38,590
아까 앞에서 정말 정말 많은 연산자원이 과학연산에 쓰인다고 했었잖아요


99
00:07:38,615 --> 00:07:43,536
최근에는 딥러닝과 딥러닝 분야에서


100
00:07:43,561 --> 00:07:46,044
어마어마하게 자원을 더 많이 소모하고 있습니다


101
00:07:46,720 --> 00:07:51,040
예전에는 CPU만 사용했다면 지금은
GPU나 전용칩들을 사용해서 가속을 하고 있고 

102
00:07:51,430 --> 00:07:55,936
만약에 하드웨어가 같더라도 수많은
드라이버들이나 수많은 라이브러리들을 사용하고 있죠 

103
00:07:55,960 --> 00:07:58,876
그래서 그 컨피그레이션이 굉장히 복잡합니다


104
00:07:58,900 --> 00:08:02,056
잘 돌아가던 게 드라이버 업데이트를 하면 안 돌아가는 경우들도 생겨요


105
00:08:02,530 --> 00:08:06,467
그리고 자원을 이렇게 모아놓다 보니까 엄청나게 많은 연산을 할 수 있는


106
00:08:06,492 --> 00:08:08,382
초대규모 연산 환경들이 생겨났습니다


107
00:08:09,130 --> 00:08:13,456
GPU Cloud가 거기에 해당되고 이제
분산 클러스터들도 그 한 예가 되겠습니다 

108
00:08:13,480 --> 00:08:16,940
아래 나온 그림은 구글에서 만든 TPU Pod인데


109
00:08:17,971 --> 00:08:21,409
TPU Pod은 정말 매트릭스 연산에만 최적화되어서


110
00:08:21,434 --> 00:08:25,003
어마어마한 머신러닝 워크로드를 처리하고 있죠


111
00:08:25,690 --> 00:08:31,377
그런데 이게 정말 다 모두에게 필요하느냐 
를 생각을 해볼게요 

112
00:08:32,170 --> 00:08:37,654
제가 머신러닝 쪽으로 이런 저런 사람들과 얘기를 하면 그 사람들 대부분은


113
00:08:37,679 --> 00:08:40,156
연구를 이미 아시는 분들이 아닌 경우에는


114
00:08:40,180 --> 00:08:44,596
대부분 이제 MNIST 부터 얘기를 하십니다


115
00:08:44,620 --> 00:08:46,010
그 HelloWorld 인데요


116
00:08:46,035 --> 00:08:48,971
그림 1234567890 손글씨 찾는 건데


117
00:08:51,130 --> 00:08:55,614
그걸 하기 위해서 "내가 MNIST하고 머신러닝
지금부터 배워보려고 하는데 

118
00:08:55,645 --> 00:08:58,315
GPU로 뭘 사야 되요?" 뭐 이런 얘기들을 해요


119
00:08:58,629 --> 00:09:03,543
그리고 맨날 올라오죠
Anaconda 이렇게 깔았는데 뭐가 안 돌아가요 

120
00:09:03,790 --> 00:09:06,516
그런데 사실 스터디 할 때는 GPU가 그렇게 많이 필요하지는 않습니다


121
00:09:06,579 --> 00:09:08,774
2기가면 넘쳐나구요


122
00:09:09,160 --> 00:09:14,660
사실은 거의 대부분의 사람들이 머신러닝이나
딥러닝을 배울때 GPU가 아예 필요하지 않습니다 

123
00:09:15,910 --> 00:09:18,120
낭비예요. 거기까지 가는 분들이 별로 없습니다


124
00:09:19,030 --> 00:09:24,967
그리고 이제 예를 들면 뭐 과학 커뮤니티나 
아니면 학회 같은 곳에서 워크샵을 한다고 했을 때 

125
00:09:25,540 --> 00:09:31,352
워크샵을 준비를 하면은 여섯 시간 워크샵이라고
하면 보통 준비에 한 두시간 이상 걸려요 

126
00:09:32,560 --> 00:09:35,574
예를 들면 뭐 구글 클라우드나 AWS에서 환경을 만든다고 하면


127
00:09:35,599 --> 00:09:38,575
뭐 계정만들고 뭐 만들고 뭐 만들고 하다가 시간 다 가고요


128
00:09:39,370 --> 00:09:44,146
그 다음에 내 컴에 깐다고 하면 라이브러리 뭐
깔고 뭐 깔고 뭐 깔고하다 보면 시간 다 끝납니다 

129
00:09:44,170 --> 00:09:47,543
그래서 여섯 시간이라면 준비에 짧게 잡으면 두 시간


130
00:09:47,568 --> 00:09:50,240
그 다음에 실제로 한 4시간 실습을 하죠


131
00:09:50,326 --> 00:09:55,591
사실의 비중은 되게 제가 굉장히 적게 잡은 건데요


132
00:09:56,020 --> 00:10:00,706
사실 3시간:3시간이나 4시간:2시간일 때도 있고 
준비하다가 시간 다가는 경우들도 많이 있습니다 

133
00:10:00,730 --> 00:10:04,355
그러니까 소잡는 칼로 닭을 잡는 경우가 너무 많은 거예요


134
00:10:07,240 --> 00:10:09,841
정말 이런 과정이 항상 다 필요할까요?


135
00:10:10,247 --> 00:10:11,341
답변해 주십시오


136
00:10:12,490 --> 00:10:14,310
그렇죠. 필요하지 않을 겁니다


137
00:10:14,575 --> 00:10:16,936
그러면 이걸 해결하기 위한 여러 가지 방법이 있는데


138
00:10:16,960 --> 00:10:20,780
오늘 주제대로 해결하기 위해서 갑자기 웹 이야기를 좀 해보겠습니다


139
00:10:22,390 --> 00:10:28,632
이제 이제 40살 넘어가신 분들 같은
경우는 아마 1990년대를 기억하실 겁니다 

140
00:10:28,663 --> 00:10:34,936
네트워크 컴퓨터라는 개념이 처음 나오고
그 다음에 이제 자바가 나오고 고슬링 나오고 

141
00:10:34,960 --> 00:10:38,026
이제 웹이 처음 등장하고 넷스케이프가 나오고


142
00:10:38,050 --> 00:10:43,120
넷스케이프에서 뭔가 다이나믹한 뭔가를 돌리기 위해서
자바 애플릿이라는 게 많이 사용되던 시대가 있었죠 

143
00:10:43,630 --> 00:10:46,612
자바 애플릿을 사용하면 뭐 인터페이스도 잘 만들 수 있었고


144
00:10:46,637 --> 00:10:50,326
그러다가 보니 마이크로소프트가 마이크로소프트 자바를 만들었고


145
00:10:50,350 --> 00:10:54,381
그게 또 호환이 안 돼가지고 둘이서 서로 소송이 걸리고 등등등 일이 있었죠


146
00:10:54,820 --> 00:10:57,890
소송 걸린 동안에 이제 자바는 강제적으로 죽고


147
00:10:58,429 --> 00:11:02,535
썬이 이기고 나서 이제 MS자바는 퇴출당하면서


148
00:11:02,560 --> 00:11:07,974
그 자리를 어도비가 만든 어도비 플래시, 당시에는 매크로미디어 플래시였는데


149
00:11:08,091 --> 00:11:10,966
매크로미디어 플래시와 Active X가 메우게 되었죠


150
00:11:11,620 --> 00:11:13,909
그리고 우리나라에서는 그 Active X가 지금까지 왔고요


151
00:11:15,370 --> 00:11:18,784
그러니까 뭔가 컴퓨터 자원을 사용하는


152
00:11:18,809 --> 00:11:24,041
고급 인터페이스 환경을 구현하기 위한 
시도들은 쭉 있어왔고 앞으로도 계속 있을 겁니다 

153
00:11:24,400 --> 00:11:28,126
그리고 이제 Chromium 진영에서는 NaCl 같은 것들을 시도하다가


154
00:11:28,150 --> 00:11:33,196
Active X를 대체하기 위해서요 
중간에 다 접혔죠 

155
00:11:33,220 --> 00:11:37,641
그리고 뭐 작년부터는 Active X 퇴출당한다고 하는데 다 EXE로 바뀌고 있습니다


156
00:11:38,800 --> 00:11:40,682
뭐가 달라졌는지 잘 모르겠어요


157
00:11:41,380 --> 00:11:47,630
여전히 Active X 대신 EXE를 통합 설치하라고 하고
끝없이 끝없이 끝없이 설치를 하는 건 똑같은 것 같아요 

158
00:11:48,490 --> 00:11:52,833
그런데 항상 이런 과정으로 이상하게 가는 것만 있는 건 아닙니다


159
00:11:53,800 --> 00:11:59,862
뭔가 이런 바이너리를 브라우저 환경에서 돌리기 위한 시도는


160
00:12:01,360 --> 00:12:03,836
표준화 기구에서도 진행이 되고 있었어요


161
00:12:04,630 --> 00:12:05,746
모질라 이야기를 해봅시다


162
00:12:05,770 --> 00:12:11,316
모질라 재단은 넷스케이프의 소스를 기여받아서 뜯어보고 쓸데가 없다는 걸 발견하고


163
00:12:11,860 --> 00:12:14,555
리팩토링을 해서 모질라 스위트를 내놨다가


164
00:12:14,580 --> 00:12:19,610
결국 그 모질라 스위트의 브라우저만 땐 경량화버전의 파이어폭스를 내놨죠


165
00:12:20,980 --> 00:12:23,800
그리고 파이어폭스 엔진을 개선하기 위해서


166
00:12:23,825 --> 00:12:26,572
이제 Servo 엔진을 만들려고 했고


167
00:12:26,597 --> 00:12:29,722
그 Servo 엔진을 만들기 위한 Rust란 언어를 만들었습니다


168
00:12:30,730 --> 00:12:33,972
브라우저 만들기 위해서 언어를 만들 정도의 열정 있는 분들이에요


169
00:12:34,660 --> 00:12:39,346
그리고 WWW 컨소시엄에서 WebAssembly라는 컨셉을 내놓습니다


170
00:12:39,370 --> 00:12:44,704
그러니까 다양한 종류의, 뭐 C나 포트란이나
뭐 여러 가지 언어들이 있겠죠 

171
00:12:44,729 --> 00:12:49,993
그런 언어들이 컴파일하면 
컴파일 결과물이 원래는 그 머신 

172
00:12:50,018 --> 00:12:53,806
돌리고 있는 컴퓨터에 굉장히 종속성이 강한 결과물이 나오게 되는데


173
00:12:53,830 --> 00:12:56,634
그게 아니라 WebAssembly라고 부르는


174
00:12:56,659 --> 00:13:00,978
어떤 바이너리 형태를 만들게 되면 걔는 브라우저에서 돌려주자라는 거예요


175
00:13:01,660 --> 00:13:05,550
약간 Lightweight VM 같은 개념으로 들어오는 거죠


176
00:13:06,940 --> 00:13:11,377
그리고 LLVM과 함께 WebAssembly 개념은 굉장히 성장을 하게 됩니다


177
00:13:11,416 --> 00:13:14,603
그래서 Emscripten이라는 툴도 나왔죠
얘는 뭐냐면 

178
00:13:15,070 --> 00:13:20,623
내가 LLVM 컴파일러가 있는 어떤 언어로 프로그램을 만들면


179
00:13:20,648 --> 00:13:22,816
그 프로그램을 LLVM 컴파일러를 통해서 컴파일을 해서


180
00:13:22,840 --> 00:13:27,646
결과물이 이제 WebAssembly 결과물이 나오게 되는 거예요


181
00:13:27,670 --> 00:13:30,520
또는 asm.js에서 돌릴 수 있거나


182
00:13:30,545 --> 00:13:35,506
그러니까 내가 뭔가 굉장히 노력을 하지 않아도 컴파일러를 교체함으로써


183
00:13:35,530 --> 00:13:38,350
결과물이 WebAssembly에서 돌아가는 결과물이 나오는 거죠


184
00:13:38,717 --> 00:13:41,490
자 그러면 이걸 바탕으로 뭘 해볼 수가 있을까요?


185
00:13:42,460 --> 00:13:44,506
여러분들 생각나는 게 어떤 게 있으습니까?


186
00:13:44,538 --> 00:13:46,592
그리고 사람들은 당연히 이것 부터 했습니다


187
00:13:47,124 --> 00:13:48,381
네 게임이죠


188
00:13:49,210 --> 00:13:52,335
퀘이크 라이브는 13년 정도 전에 나왔었는데


189
00:13:52,335 --> 00:13:55,795
그때 나왔음에도 불구하고 브라우저에서 굉장히 잘 돌아갔습니다


190
00:13:57,088 --> 00:13:59,014
물론 이런 시도들만 있는 건 아니고요


191
00:13:59,935 --> 00:14:01,989
그 중에 하나가 Iodide 프로젝트입니다


192
00:14:02,800 --> 00:14:06,776
Iodide 프로젝트는 과학연산을 브라우저 위해서 해보자는 거예요


193
00:14:07,660 --> 00:14:12,910
그래서 과학 컴퓨팅이나 과학연산이나
데이터 사이언스를 하기 위해서 뭐가 필요하냐? 

194
00:14:13,540 --> 00:14:14,566
라고 하는 거죠


195
00:14:17,320 --> 00:14:21,406
우리는 주피터 노트북을 씁니다


196
00:14:21,430 --> 00:14:24,381
주로 과학연산하는 사람들이 파이썬 기반으로 할 때는


197
00:14:24,406 --> 00:14:29,491
주피터 노트북을 돌리려면 내 컴퓨터에 환경을 다 만들고
주피터를 설치해야 되죠 

198
00:14:29,530 --> 00:14:34,114
그리고 주피터 노트북이 실행하거나 하고 당연히 라이브러리 충돌이슈도 생기고


199
00:14:34,139 --> 00:14:36,428
설치하는 과정도 필요하고 뭐 여러 가지가 필요하겠죠


200
00:14:38,950 --> 00:14:42,285
그 과정에서 우리가 웹브라우저를 인터페이스로 쓰긴 하지만


201
00:14:42,310 --> 00:14:45,879
사실 이게 돌아가는 거는 웹브라우저의 껍데기를 쓴 파이썬이 돌아가죠


202
00:14:46,489 --> 00:14:50,949
그러면 아예 사이언티픽 컴퓨팅을 웹으로
해버리면 않돼냐 라는 생각도 할 수 있을 겁니다 

203
00:14:52,630 --> 00:14:57,137
자바스크립트가 21세기 초만 해도 
속도 때문에 그런 건 전혀 불가능하다고 생각을 했어요 

204
00:14:57,325 --> 00:15:00,176
하지만 지금은 뭐 V8 엔진이 나오면서


205
00:15:00,201 --> 00:15:03,989
굉장히 이런, 자바스크립트 엔진의 속도도 빨라졌고


206
00:15:04,630 --> 00:15:09,903
거기에 이제 WebAssembly가 거의 모든 브라우저에 표준으로 들어오게 되면서


207
00:15:10,644 --> 00:15:12,960
이제 뭔가 해볼 수 있지 않을까? 라는 생각이 들게 되는 거죠


208
00:15:15,340 --> 00:15:20,164
그렇다면 이 Iodide를 통해서 예를 들면 다양한 종류의 과학연산용 언어를


209
00:15:20,500 --> 00:15:21,886
WASM으로 만들고


210
00:15:21,910 --> 00:15:26,081
그 다음에 Iodide에서 만든 노트북 인터페이스를 통해서


211
00:15:26,106 --> 00:15:30,658
그 커널들을 돌리게 되면은 가능하지 않겠느냐 라고 해서


212
00:15:30,683 --> 00:15:33,160
이제 시도되고 있는 실험 프로젝트가 Iodide입니다


213
00:15:33,185 --> 00:15:35,309
여러 가지 언어들을 백앤드로 가지고 있고요


214
00:15:35,357 --> 00:15:38,871
전용의 그 노트북 인터페이스를 갖고 있습니다


215
00:15:40,150 --> 00:15:43,454
그럼 Pyodide는 뭐냐 Pyodide는


216
00:15:44,290 --> 00:15:47,790
Iodide에서 사용하는 파이썬 웹 스택입니다


217
00:15:49,900 --> 00:15:53,501
그걸 소개해드리기 전에 일단 Iodide에 대해서 조금 더 소개를 드리면


218
00:15:53,837 --> 00:15:57,056
웹기반의 과학연산 환경인데


219
00:15:57,081 --> 00:16:01,706
이제 완전 노트북 환경도 있고 비주얼라이제이션도 웹에서 다 지원을 하고요


220
00:16:02,050 --> 00:16:05,190
그런데 R도 있고 다양한 언어들을 지원을 하는데


221
00:16:05,440 --> 00:16:08,229
그럴 것 같으면 주피터 노트북을 통해서


222
00:16:08,268 --> 00:16:11,049
내 컴퓨터에 있는 자원을 파이썬으로 보내서


223
00:16:11,074 --> 00:16:12,924
IPykernel을 쓰는 거 대신


224
00:16:13,630 --> 00:16:18,380
WASM 위에 풀 파이썬 스택을 올린 다음에


225
00:16:18,405 --> 00:16:22,044
그걸로 그냥 웹 브라우저에서 바로 실행을 해버리면 안 되냐 라는 거죠


226
00:16:23,230 --> 00:16:29,866
그래서 만일 우리가 파이썬을 통째로 컴파일해서 WebAssembly로 만들 수 있다면


227
00:16:29,890 --> 00:16:32,746
파이썬 기반의 라이브러리들도 그럴 수 있을 거고


228
00:16:32,770 --> 00:16:36,902
그런 것들을 불러쓰는 툴채인과 패키지들을 만든다면


229
00:16:36,927 --> 00:16:39,957
그 모든 것들을 브라우저로만으로도 처리할 수 있을 겁니다


230
00:16:40,777 --> 00:16:47,086
아이디어가 나왔죠 "정말 될까? 정말 될까?" 했는데
정말 되는 거죠! 정말 된다는 걸 발견을 했습니다 

231
00:16:47,110 --> 00:16:49,219
발견 아니고 정말 되게 만든 거죠


232
00:16:49,630 --> 00:16:54,559
Pyodide인데 브라우저에서 돌아가는 파이썬 사이언스 스택입니다


233
00:16:54,622 --> 00:16:57,309
그래서 Iodide의 엔진 중의 하나로 돌아가고요


234
00:16:57,940 --> 00:17:05,024
그래서 여러분들이 흔히 아시는 NumPy, SciPy
Pandas, Matplotlib 

235
00:17:05,049 --> 00:17:08,955
이런 모든 것들을 WebAssembly로 미리 다 컴파일을 해버리고


236
00:17:08,980 --> 00:17:11,433
또는 컴파일하기 위한 툴채인을 다 제공을 하는 거에요


237
00:17:11,801 --> 00:17:13,441
쉬운 거는 브라우저만 있으면 됩니다


238
00:17:13,930 --> 00:17:17,156
내 컴퓨터에 파이썬을 설치할 필요도 없어요. 그냥 돌릴 수 있습니다


239
00:17:17,560 --> 00:17:20,606
그리고 나중에 뒤에서 데모로 볼 수도 있겠지만


240
00:17:20,654 --> 00:17:22,325
기본적으로 웹브라우저기 때문에


241
00:17:22,450 --> 00:17:26,989
그리고 WebAssembly기술에서는 WebAssembly가 돌아가는


242
00:17:27,014 --> 00:17:30,785
브라우저의 Document Object Model에 접근할 수 있습니다


243
00:17:30,926 --> 00:17:33,160
그러니까 웹페이지와 상호작용이 가능하다는 거죠


244
00:17:33,379 --> 00:17:36,332
그래서 굉장히 재미있는 아이디어들을 만들 수도 있을 겁니다


245
00:17:36,460 --> 00:17:38,569
그중에 제 아이디어를 통해서 소개를 드릴게요


246
00:17:39,070 --> 00:17:41,374
문제는 크고 느리다는 겁니다


247
00:17:42,340 --> 00:17:48,557
파이썬은 크죠. 오리지널 파이썬을
WebAssembly로 컴파일 하면 40MB 정도밖에 안 됩니다 

248
00:17:48,582 --> 00:17:51,621
"40MB 정도 밖에" 이미 웹에서는 좀 큰 단위이긴 하죠


249
00:17:52,210 --> 00:17:57,194
하지만 여러분 웹에서 좀 짤방이 있는
사이트를 들어가실 때 혹시 보신 적 있으세요 

250
00:17:58,452 --> 00:18:01,708
웬만한 짤방 사이트에 들어가면 기본적으로 50MB 씩은 로딩은 합니다


251
00:18:01,733 --> 00:18:02,975
대한민국은 할 수 있어요


252
00:18:03,400 --> 00:18:06,360
물론 여기에서 이제 Pandas 정도가 되면


253
00:18:06,369 --> 00:18:09,275
200MB 이상을 로딩하게 되는데 뭐 나중에 생각합시다


254
00:18:09,300 --> 00:18:15,460
그래서 크고 느립니다
느린 거는 WebAssembly가 싱글스레드기 때문인데요 

255
00:18:15,491 --> 00:18:17,296
뒤에서 다시 한 번 얘기를 하겠습니다


256
00:18:17,320 --> 00:18:20,452
그래서 Pyodide의 패키지들은 대충 이렇게 구성이 되어 있습니다


257
00:18:21,220 --> 00:18:28,246
Cython으로 파이썬이 컴파일이 돼 있고
이제 C Linear Algebra 패키지랑 함께 만들어진 게 

258
00:18:28,270 --> 00:18:29,806
NumPy가 만들어져 있고요


259
00:18:29,830 --> 00:18:33,408
NumPy 기반으로 Matplotlib랑 Pandas가 컴파일되고


260
00:18:33,433 --> 00:18:37,667
또 SciPy랑 NetworkX도 컴파일해서 만들어져 있습니다


261
00:18:38,089 --> 00:18:42,256
그리고 이제 통계쪽으로는 SymPy랑
statsmodels을 지원을 하고 있고 

262
00:18:42,280 --> 00:18:47,451
SciPy 기반으로는 자연어처리를 할 수 NLTK랑 spaCy를 지원합니다


263
00:18:47,770 --> 00:18:53,566
그리고 일반적인 머신러닝으로는 SciPy를 기반으로
scikit-learn을 지원을 하고 있고요 

264
00:18:53,590 --> 00:18:58,576
이제 바이오쪽으로는 Biopython을 지원을 하고
컴파일을해서 패키지들이 만들어져 있는 상태고 

265
00:18:58,600 --> 00:19:01,184
scikit-learn에서 사용하는 scikit-image도 만들어져 있고


266
00:19:01,209 --> 00:19:05,446
그 다음에 Wavelet을 처리할 수 있는 PyWavelet도 만들어져 있기 때문에


267
00:19:05,470 --> 00:19:08,915
이미지 프로세싱이나 Time Series Analysis도 할 수가 있게 되었습니다


268
00:19:09,460 --> 00:19:15,295
그래서 이게 현재 8월에 Pyodide 사이트에서 제공을 하고 있는


269
00:19:15,940 --> 00:19:19,000
풀스택 중에서 여러분들이 이제 이름을 아실만한 패키지들이고요


270
00:19:19,025 --> 00:19:23,517
이 패키지들이 사용하는 수많은 서브 패키지들이
있는데 그런 것들은 생략을 한 겁니다 

271
00:19:24,615 --> 00:19:27,201
그래서 굉장히 많은 패키지들이 제공되고 있습니다


272
00:19:27,430 --> 00:19:30,194
그리고 만일 없다 그러면 여러분들이 빌드를 할 수도 있습니다


273
00:19:30,219 --> 00:19:34,406
만일 퓨어 파이썬이라면요 그렇지 않은 경우에는 조금 빌드하기가 복잡합니다


274
00:19:35,627 --> 00:19:37,290
자 그럼 어떻게 돌리는지 한번 봅시다


275
00:19:37,315 --> 00:19:39,673
이게 예제로 그냥 한 번 만들어온 거예요


276
00:19:39,698 --> 00:19:43,064
보시면 window.languagePluginUrl 이라고 해서


277
00:19:43,089 --> 00:19:48,616
언어 패키지들이 불러올 URL을 하나 지정을 해주었고


278
00:19:48,640 --> 00:19:50,257
그 다음에 Pyodide를 불렀습니다


279
00:19:50,800 --> 00:19:52,913
그리고 사용하는 법은 되게 단순한데요


280
00:19:53,202 --> 00:19:58,846
이제 Pyodide를 임포트를 하면은 languagePluginLoader랑
pyodide라는 객체 두 개가 임포트가 됩니다 

281
00:19:58,870 --> 00:20:01,657
그래서 pyodide에는 다양하면 명령들이 붙어 있고


282
00:20:01,682 --> 00:20:03,385
languagePluginLoader 라는 거는


283
00:20:03,410 --> 00:20:09,016
이 pyodide를 initialzie하는 async 객체에요


284
00:20:09,040 --> 00:20:14,241
그래서 만약에 로드가 되면은 여기에 있는
'import sys'랑 'sys.version'를 실행을 해라 

285
00:20:14,266 --> 00:20:17,211
그리고 그 결과를 result에 뿌려라


286
00:20:17,236 --> 00:20:18,906
그러면 이렇게 결과물이 나오게 됩니다


287
00:20:19,960 --> 00:20:22,335
코드가 복잡하니까 핵심만 보면 이렇게 되어 있죠


288
00:20:25,180 --> 00:20:28,883
자 resultPane 이라고 이제 눈에 보이는 부분,


289
00:20:28,907 --> 00:20:30,930
코드 결과물이 들어가야 될


290
00:20:31,390 --> 00:20:33,327
그 div 하나 만들고요


291
00:20:34,531 --> 00:20:37,065
그 다음 그걸 일단 비운 다음에


292
00:20:37,090 --> 00:20:39,676
계산한 결과물을 거기다 쓰는 겁니다
단순하죠 

293
00:20:39,700 --> 00:20:42,253
그런데 옆에 코드를 돌리면은 가끔 undefined가 나와요


294
00:20:42,278 --> 00:20:48,315
왜냐하면 result 객체가 undefined가 나올 때가 있습니다


295
00:20:48,340 --> 00:20:50,650
이건 타이밍 이슈인데요. 뒤에서 다루겠습니다


296
00:20:50,675 --> 00:20:55,816
이거는 이제 자바스크립트의 async 속성과 굉장히 밀접한 관련이 있습니다


297
00:20:55,840 --> 00:20:58,480
자 굉장히 간단하잖아요 코드만 보면


298
00:20:59,140 --> 00:21:01,906
그러면 이걸 도대체 어떻게 사용을 할 수 있을까?


299
00:21:01,930 --> 00:21:05,758
이제 실제로 써먹자, 써먹어 보자라는 생각을 하게 됐는데


300
00:21:06,130 --> 00:21:10,130
Pyodide나 Iodide는 테스트나 뭔가 실험용 프로젝트이기 때문에


301
00:21:10,520 --> 00:21:14,338
실제로 써먹기 위해서는 몇 가지가 더 필요합니다


302
00:21:14,363 --> 00:21:18,683
예를 들면은 코드나 결과를 저장할 파일 시스템이 필요할 거고요


303
00:21:19,360 --> 00:21:24,360
그 다음에 이제 모듈. 기본적인 모듈을 로딩하는 방법이 필요할 거고


304
00:21:24,454 --> 00:21:28,594
그 다음에 실제로 내가 연구를 하거나
공부를 할 수 있는 웹UI가 필요할 겁니다 

305
00:21:29,320 --> 00:21:32,318
Iodide를 쓰면 웹UI가 해결이 될 수 있겠죠


306
00:21:32,343 --> 00:21:35,176
그런데 Iodide는 Django로 만들어져 있고


307
00:21:35,200 --> 00:21:39,512
돌리려면 DB도 띄워야 되고 Django도 띄워야 되고 
뭐 띄워야 되는 게 여러개 있습니다 

308
00:21:40,780 --> 00:21:46,516
그거 띄울거면 음... 
그냥 주피터 띄우는 게 나을 것 같다는 생각도 들어요 

309
00:21:46,540 --> 00:21:51,166
그렇기 때문에 작년에 처음 만들어보자라고 맘먹었던거는


310
00:21:51,190 --> 00:21:54,166
스탠드 얼론하면서 그러니까 단독으로 들고 다닐 수 있으면서


311
00:21:54,191 --> 00:21:56,924
뭐 USB 같은데에 들고 다닐 수 있는 포터블 솔루션이었습니다


312
00:21:57,220 --> 00:21:59,656
그래서 모든 시나리오를 굉장히 심플하게 해서


313
00:21:59,680 --> 00:22:04,664
이것만들고 다니면 다 할 수 있는 어떤
도구를 하나 만들어보자라고 생각을 하게 됐죠 

314
00:22:04,780 --> 00:22:08,225
자 그러면 Practical Problem들을 하나씩 해결해보겠습니다


315
00:22:09,040 --> 00:22:13,655
파일 시스템 해결은 BrowserFS라는 라이브러리를 써서 해결을 했습니다


316
00:22:13,680 --> 00:22:19,070
이 BrowserFS는 내부적으로 Emscripten 파일 시스템을 지원을 해요


317
00:22:19,330 --> 00:22:25,283
그래서 BrowserFS를 사용해서 스토리지를 만들고


318
00:22:25,308 --> 00:22:29,447
여기 이 예제에선 브라우저 LocalStorage를 만들고요


319
00:22:29,955 --> 00:22:33,025
그 브라우저 LocalStorage를 하나 정의를 한 다음에


320
00:22:33,050 --> 00:22:35,922
거기 안에 파일을 쓰고 마운트를 할 수도 있습니다


321
00:22:35,947 --> 00:22:42,556
그래서 그걸 폴더를 만들거나 마운트를 하고 이제
그거를 파이썬 내부 코드에서 바로 참조를 할 수 있게 됩니다 

322
00:22:42,580 --> 00:22:43,525
이런 식으로 할 수 있죠


323
00:22:43,550 --> 00:22:46,205
뭐 여긴 예제로 'data'라 했는데


324
00:22:46,230 --> 00:22:49,401
이거는 이제 Pyodide의 이슈 중에 하나에


325
00:22:49,426 --> 00:22:51,660
나와 있는 예제를 약간 단순화한 겁니다


326
00:22:52,360 --> 00:22:55,969
실제로 쓸 때는 뭐 'home' 디렉토리 정도로 지정을 하겠습니다


327
00:22:56,530 --> 00:23:01,139
그래서 이 예제를 통하면 즉 Pyodide는 이제 오른쪽 그림을 보시면


328
00:23:01,870 --> 00:23:06,370
이제 Pyodide가 path랑 fs 파일 시스템 객체를 리턴을 합니다


329
00:23:06,651 --> 00:23:11,244
그리고 그것들을 EmscriptenFS가 사용할 수 있도록


330
00:23:11,269 --> 00:23:13,532
BrowserFS를 통해서 바인드를 해버리는 거예요


331
00:23:13,557 --> 00:23:18,377
그래서 EmscriptenFS는 LocalStorage를 자신의 마운트 포인터로 갖고


332
00:23:19,750 --> 00:23:24,873
그 다음에 BrowserFS가 그 EmscriptenFS이랑


333
00:23:24,898 --> 00:23:28,562
Pyodide의 path랑 fs를 연결해주는 역할을 하는 겁니다


334
00:23:28,810 --> 00:23:32,474
그러면 파일 시스템을 만들고 브라우저를 닫았다 꺼도 유지가 될 겁니다


335
00:23:33,430 --> 00:23:38,273
이왕이면 로컬 파일 시스템을 그대로 접근할 수 
있으면 좋지 않을까? 하는 생각도 들죠? 

336
00:23:38,320 --> 00:23:39,672
뒤에서 한번 다뤄보겠습니다


337
00:23:40,510 --> 00:23:44,476
두 번째는 필요할 때만 모듈을 로딩을 해야 되겠죠


338
00:23:44,500 --> 00:23:48,546
이거는 이제 Promise-ready라는 API가
이미 있기 때문에 그걸 그대로 사용을 하겠습니다 

339
00:23:48,940 --> 00:23:54,676
runPythonAsync라는 명령을 쓰면은 아래에 있는 라이브러리 임포트 중에서


340
00:23:54,700 --> 00:23:57,582
없는 라이브러리가 있다고 하면은


341
00:23:57,614 --> 00:24:01,996
그걸 async로 불러옵니다


342
00:24:02,020 --> 00:24:05,848
그 필요한 시점에 불러와서 사용을 하게 돼요


343
00:24:06,670 --> 00:24:12,427
그리고 그 결과물로 result가 나오게 되는데
result가 결과가 나오기 전에는 undefined고 

344
00:24:12,505 --> 00:24:15,481
결과물이 만일 나온다 그러면 undefined가 아니라


345
00:24:15,520 --> 00:24:18,256
텍스트 형태거나 다른 형태일 수도 있습니다


346
00:24:18,280 --> 00:24:20,426
그런데 Pyodide를 지금 제가 쓰는 것처럼


347
00:24:20,451 --> 00:24:23,458
Iodide 없이 순수 자바스크립트로 쓰는 경우에는


348
00:24:24,490 --> 00:24:26,896
이렇게 직접 그 부분을 다 만들어줘야 돼요


349
00:24:27,520 --> 00:24:29,660
어디에 결과물이 출력될 건지요


350
00:24:30,434 --> 00:24:34,816
그래서 일단 이 runPythonAsync 함수를 사용해서 다이나믹 import를


351
00:24:34,840 --> 00:24:36,286
구현을 해서 사용을 하겠습니다


352
00:24:36,310 --> 00:24:39,817
앞으로 모든 런타임은 이 명령을 사용해서 부르게 되겠죠


353
00:24:41,350 --> 00:24:43,428
자 그 다음에 이제 그러면 테스트를 한번 해봅시다


354
00:24:45,160 --> 00:24:50,738
일단 첫 번째 문제는 뭐냐면 stdout을
뿌렸을 때 결과물이 안 나온다는 거에요 돌려보시면 

355
00:24:51,824 --> 00:24:59,159
그래서 stdout을 받기 위해서 다음과
같은 코드를 항상 초기화 될 때 실행을 해줍니다 

356
00:24:59,363 --> 00:25:03,003
이제 sys.stdout에 StringIO 연결을 해서


357
00:25:03,700 --> 00:25:08,106
그 다음에 그 값을 코드가 실행될 때마다 읽어보도록 만드는 거죠


358
00:25:09,100 --> 00:25:13,764
그래서 이제 이 처음에 초기화할 때는


359
00:25:13,789 --> 00:25:16,966
이 StringIO를 stdout에 연결해놓고


360
00:25:16,990 --> 00:25:20,872
이제 실제 구현체에서는 stderr도 같이 붙었습니다


361
00:25:21,280 --> 00:25:26,147
그런 다음에 이제 각 코드 실행이 끝날 때마다 아래에 있는


362
00:25:27,820 --> 00:25:31,429
stdout.getvalue()를 실행해서 실제 그 값을 갖고 오는 거예요


363
00:25:31,750 --> 00:25:34,726
그 값을 갖고 와서 텍스트 형태로 뿌리는데


364
00:25:34,727 --> 00:25:38,171
그냥 뿌리지 않고 앞에서 무슨 결과 더 나왔을지 모르니까


365
00:25:38,560 --> 00:25:42,903
이제 resultPane에 객체를 만들어서 새로 붙이는 형태로 구현을 하는 겁니다


366
00:25:42,935 --> 00:25:46,474
그러면 이제 Runtime Test의 오른쪽 예제를 보시면


367
00:25:46,513 --> 00:25:50,817
위와 같은 코드를 돌리면 이렇게 실행을 했을 때 결과물이 아래 쭉 붙게 되죠


368
00:25:52,780 --> 00:25:55,696
두 번째로는 Iodide에 dependency가 있습니다


369
00:25:55,720 --> 00:26:01,096
왜냐하면 Pyodide 자체는 Iodide의 서브셋으로 만들어졌기 때문에


370
00:26:01,120 --> 00:26:06,688
예를 들면 결과물을 어디에 내보낼 거냐 뭐 결과물이
텍스트인 경우에는 앞에 처럼 해결할 수 있겠지만 

371
00:26:06,713 --> 00:26:11,945
인터랙티브 Plot이라거나 아니면 이미지 일수도 있고


372
00:26:11,970 --> 00:26:13,923
아니면 버튼 같은 것일 수도 있잖아요


373
00:26:14,320 --> 00:26:17,451
그런 경우들은 Iodide가 없으니까 돌아가지 않겠죠


374
00:26:17,476 --> 00:26:20,921
그래서 Pyodide 코드를 뜯어봤을 때


375
00:26:20,946 --> 00:26:24,327
Iodide가 있으면 Iodide쪽 코드를


376
00:26:24,320 --> 00:26:26,936
원용해서 사용하도록 되어 있는 부분을 참조를 해서


377
00:26:27,250 --> 00:26:31,031
Iodide를 강제로, 가짜 Iodide를 하나 만들어주는 겁니다


378
00:26:31,660 --> 00:26:35,667
그래서 이렇게 globalThis 객체에
iodide라는걸 하나 만들어 붙여주는데 

379
00:26:35,692 --> 00:26:39,128
이건 간단한 예고 실제로는 더 복잡하게 만들어서


380
00:26:39,153 --> 00:26:42,183
실제 Iodide 역할을 하도록 만들어서 붙일 겁니다


381
00:26:42,280 --> 00:26:47,100
그리고 지금 여기서는 아웃풋을 예로 붙인거를 보여드렸는데


382
00:26:47,125 --> 00:26:50,084
이 아웃풋의 예로 보시면 Ploting을 이렇게 뿌릴 수가 있거든요


383
00:26:50,500 --> 00:26:54,053
이제 아웃풋 말고 예를 들면 어떤 식의 핸들러를 붙여서


384
00:26:54,078 --> 00:26:58,006
어떤 식의 아웃풋을 내보낼거냐를 등록하고 해지할 수 있게 되어있는데


385
00:26:58,031 --> 00:27:02,398
그 부분은 자체적으로 목업을 구현을 해서 내부적으로 가지고 있을 겁니다


386
00:27:03,640 --> 00:27:05,194
자 일단 심플하게 갑시다


387
00:27:07,240 --> 00:27:12,263
자 그러면 이것만이면 되느냐
실제로 필요한 문제들이 더 많이 있어요 

388
00:27:13,210 --> 00:27:16,575
예를 들면 데이터 사이언스를 한다 라고 하면


389
00:27:16,600 --> 00:27:19,271
결국 이.. 크기 데이터의 크기


390
00:27:19,256 --> 00:27:23,943
그 다음에 데이터 접근 속도라거나 사용 편의성 같은 게 굉장히 중요해지고


391
00:27:24,460 --> 00:27:28,561
그 다음에 런타임 크기 자체가 인터넷으론 제공하기 되게 어렵습니다


392
00:27:29,080 --> 00:27:34,931
풀로 다 로드 했을때 뭐.. 작으면 150MB에서
크면 450MB 까지도 로딩할 수 있거든요 

393
00:27:35,196 --> 00:27:42,765
Pyodide 0.15를 받으면 아마 200에서 300메가 안쪽에서 끊기는데


394
00:27:42,790 --> 00:27:48,046
여러분들이 필요한 패키지를 추가로 많이 더 넣었다
그러면은 이게 굉장히 많이 늘어나게 될 거예요 

395
00:27:48,070 --> 00:27:52,421
그래서 컴파일한 라이브러리에 따라서 용량이 기하급수적으로 커질 수 있습니다


396
00:27:53,230 --> 00:27:58,050
그래서 이걸 풀기 위해서
이걸 항상 들고 다니자 라고 구현을 하게 되었습니다 

397
00:27:58,840 --> 00:28:06,027
그래서 어떻게 들고 다니느냐 Chromium 엔진이 들어있는
Electron 쉘을 사용해서 Electron App으로 통째로 만들어버리는거죠 

398
00:28:06,460 --> 00:28:11,638
Electron App은 브라우저 환경을 제공을 해주면서
Web App을 만들때 주로 사용하는 툴인데요 

399
00:28:11,663 --> 00:28:16,436
여러분들이 사용하는 뭐 Visual Studio Code 같은 것들의 쉘로 쓰이고 있죠


400
00:28:17,014 --> 00:28:21,785
NW.js였나? 어쨌든. NodeJS 환경 기반으로 만들어져 있고


401
00:28:21,810 --> 00:28:26,886
이렇게 만들게 되면은 컴파일 옵션을 잘 지정을 하면
App일 땐 App mode로도 만들 수가 있고 

402
00:28:26,911 --> 00:28:31,582
만약에 충분한 트레픽 환경이 지원되는
경우에서는 Web mode로 만들 수도 있을 겁니다 

403
00:28:33,310 --> 00:28:35,060
그래서 이제 설계를 해보겠습니다


404
00:28:35,650 --> 00:28:40,906
기본적으로 NodeJS가 담당하는 건
Pyodide WebWorker를 붙이게 되고 

405
00:28:40,930 --> 00:28:46,756
그 다음에 Electron 자체가 
Main 스레드가 있고 Renderer 스레드가 있고요 

406
00:28:46,780 --> 00:28:53,489
Electron이 Main 스레드를 실행을 하고 Main 스레드는 Renderer를 새로 만들죠


407
00:28:53,514 --> 00:28:57,263
새로 만들고 그게 이제 우리 눈에 보여지는 웹페이지가 되고요


408
00:28:57,607 --> 00:28:59,802
그 사이는 IPC로 통신을 합니다


409
00:28:59,849 --> 00:29:06,870
그리고 이제 멀티세션을 지원하기 위해서 WebWorker
기반으로 Pyodide를 돌릴 수가 있는데 

410
00:29:06,940 --> 00:29:11,588
문제는 뭐냐 하면 이 WebWorker를 썼을 때는
DOM Modification이 안됩니다 

411
00:29:11,807 --> 00:29:15,674
왜냐하면 WebWorker 자체가 이제 완전히 독립된 DOM을 가지기 때문인데요


412
00:29:16,750 --> 00:29:20,356
그 문제는 뭐 차차 해결을 하겠지만 데모할 때는


413
00:29:20,380 --> 00:29:26,239
이제 WebWorker를 쓰지 않고 이제 Renderer 스레드에서
돌리는 식으로 한번 데모를 해보도록 하겠습니다 

414
00:29:27,280 --> 00:29:29,147
실제로 구현하는 형태는 이렇게 될 겁니다


415
00:29:29,950 --> 00:29:33,556
왼쪽 아래 사용자가 있고 사용자가 이제 App을 실행을 하게 되면은


416
00:29:33,580 --> 00:29:36,312
Electron의 main 프로세스가 main.js를 부르게 되고


417
00:29:36,337 --> 00:29:39,477
그러면 걔는 main.js가 이제 Renderer 프로세서를 부르면서


418
00:29:39,502 --> 00:29:41,719
index.html이란 애를 부르게 됩니다


419
00:29:42,310 --> 00:29:47,286
그러면 index.html은 기본적인 세팅을 하고
pyodide-console 이라고 부르는 

420
00:29:47,311 --> 00:29:49,186
WebComponent를 부르게 될 거고요


421
00:29:49,210 --> 00:29:55,708
이 WebComponent는 자기가 부트스트래핑을 하는
과정에서 Iodide 목업을 먼저 호출을 하고 

422
00:29:55,733 --> 00:29:58,272
그 목업에 기반해서 Pyodide를 또 부르게 됩니다


423
00:29:58,750 --> 00:30:05,015
그리고 이런 Pyodide를 실행하면서
초기화할 때 BrowserFS를 통해서 

424
00:30:05,040 --> 00:30:07,126
LocalStorage를 바인딩을 하고


425
00:30:07,150 --> 00:30:10,110
Pyodide는 그 자체적으로 NODEFS를 사용을 해서


426
00:30:10,360 --> 00:30:13,688
Renderer 프로세스의 NodeJS를 통해서


427
00:30:14,530 --> 00:30:19,537
EmscriptenFS의 NODEFS를 통해서
파일 시스템으로 바로 연결이 되게 될 겁니다 

428
00:30:20,080 --> 00:30:22,666
그리고 Pyodide는 인터페이스를 제공해야 되니까


429
00:30:22,690 --> 00:30:24,846
CodeMirror를 사용해서 에디터를 제공을 할 거고요


430
00:30:25,330 --> 00:30:32,176
그 다음에 뭐 여러 가지 
Plastics라고 부르는 자체적으로 만든 

431
00:30:32,207 --> 00:30:33,700
웹 UI 컴포넌트를 사용을 할 거고


432
00:30:33,725 --> 00:30:38,850
그 다음에 로그를 계속 모니터링해서 내가 지금 어떻게
돌아가고 있는지 볼 수 있는 인터페이스를 만들 겁니다 

433
00:30:42,670 --> 00:30:48,426
자 이렇게 빌드한 거는 rollup.js로
빌드를 해서 Electron App으로 빌드를 할 거고 

434
00:30:48,451 --> 00:30:54,113
그 다음에 그렇게 만들어진 결과물을 Electron Packager를
사용해서 빌딩을 해서 앱으로 만들 겁니다 

435
00:30:54,138 --> 00:30:57,816
그리고 이렇게 만든 것은 GitHub을 통해서 소스 코드로도 공개를 하고


436
00:30:57,841 --> 00:31:01,683
만들어진 App 자체의 Zip파일도 같이 공개를 할거고요


437
00:31:01,708 --> 00:31:04,090
그리고 나중에 좀 안정화가 되면은


438
00:31:04,115 --> 00:31:09,029
Windows Store나 Mac App Store를 통해서 공개를 할 수도 있겠죠


439
00:31:09,400 --> 00:31:16,764
거기까진 음... 
계속 뭔가 일이 너무 힘들게 되면 빨리 진행이 될 것 같습니다 

440
00:31:16,789 --> 00:31:18,976
도피처니까요?


441
00:31:19,000 --> 00:31:22,109
자 이제 실제로 하다 보면 더 많은 문제들이 있어요


442
00:31:23,080 --> 00:31:26,986
예를 들면 결과물이 계속 누적이 됩니다 파이썬 안에서


443
00:31:27,010 --> 00:31:32,776
왜냐하면 그 system의 stdout 출력을 하는


444
00:31:32,800 --> 00:31:35,884
그 stdout이 버퍼가 계속 누적이 되기 때문인데


445
00:31:35,909 --> 00:31:41,476
그래서 한 번 출력을 한 다음에 그거를 강제로 리셋을 해줄 필요가 있습니다


446
00:31:41,500 --> 00:31:47,296
리셋 명령은 파이썬3 기준으로는 truncate 하고


447
00:31:47,320 --> 00:31:50,385
다시 처음으로 포인터를 돌리는 방법을 써야 되고요


448
00:31:51,120 --> 00:31:56,066
네 번째로는 아까 잠깐 설명드렸던 WebWorker의 한계인데
WebWorker는 DOM Access를 못해요 

449
00:31:56,091 --> 00:32:02,542
Access를 못하면 뭐 실행에는 큰 문제가 없지만 
이제 비주얼라이제이션, 그래프를 그린다거나 

450
00:32:02,573 --> 00:32:07,487
아니면 뒤에서 보여드릴 뭔가 굉장히 
재미있는 예제를 만드는 방법은 없습니다 

451
00:32:07,660 --> 00:32:12,980
해결책을 찾고 있는데 일단 기본적으로 DOM 대신
WorkerGlobalScope이라는 자체적인 

452
00:32:13,237 --> 00:32:16,696
최상위 객체를 가지기 때문에 이걸 어떻게 해결해야 될지 모르겠습니다


453
00:32:16,720 --> 00:32:21,659
IPC를 통해서 전달을 하는 아이디어도 있긴 합니다


454
00:32:23,380 --> 00:32:26,481
자 그러면 이제 앱을 한번 테스트를 해볼까요?


455
00:32:28,240 --> 00:32:33,286
자 첫 번째로 데이터를 그냥 가져와서 Analyze를
하고 출력을 하는 부분을 한번 해보겠습니다 

456
00:32:35,350 --> 00:32:41,026
자 이게 지금 Pyodide Console로 
Electron으로 구운 앱이에요 

457
00:32:41,050 --> 00:32:42,917
보시면 앱처럼 생겼죠


458
00:32:42,942 --> 00:32:47,504
그 다음에 오른쪽 아래는 항상 지금 현재 
상황의 로그가 나오도록 만들어 놓았습니다 

459
00:32:47,529 --> 00:32:52,168
얘가 로그 모니터고
그래서 보시면 이제 위에 있는 임포트를 실행을 하니까 

460
00:32:52,193 --> 00:32:57,556
실제로 내부 경로에서 그 라이브러리 자바스크립트,


461
00:32:57,580 --> 00:33:00,337
WebAssembly로 된 컴포넌트들을 불러오는 걸 보실 수 있습니다


462
00:33:00,970 --> 00:33:01,923
데이터를 불러와 보겠습니다


463
00:33:01,955 --> 00:33:05,743
약간 다른 게 있는데 바로 URL을 읽어오지를 못해요


464
00:33:06,485 --> 00:33:10,967
이 Pyodide 한계 때문에. 그래서 그걸 위해서
pyodide.open_url 이라는 내부 함수가 있는데 

465
00:33:10,992 --> 00:33:14,296
그걸 통해서 값을 읽어온 다음에 read_csv로 읽었습니다


466
00:33:14,739 --> 00:33:22,035
자 그러면 이건 이제 전 세계의 코로나 바이러스
데일리 데이터를 읽어와서 이걸로 이제 플로팅을 할 겁니다 

467
00:33:22,060 --> 00:33:25,919
이 plot 함수는 Pandas의 DataFrame을


468
00:33:25,958 --> 00:33:29,597
주어진 그룹으로 나누고 그 그룹별로 출력을 할 수 있게 만든 거예요


469
00:33:29,621 --> 00:33:35,206
자 그러면 이번에는 한국을 볼까요?
새로운 케이스가 얼마나 늘어났는지 보겠습니다 

470
00:33:35,230 --> 00:33:39,855
네. 최근에 늘어나고 있죠
네. 큰일입니다 

471
00:33:41,170 --> 00:33:44,740
그 다음으로는 이제 새로운 케이스가 얼마나 생기는지 한번 보겠습니다


472
00:33:47,591 --> 00:33:51,598
새로운 케이스 방금 봤죠?
왜 이렇게.. 다른 거 봅시다 

473
00:33:51,910 --> 00:33:53,425
다른 나라들과 비교를 해볼까요?


474
00:33:53,450 --> 00:33:59,043
전체 케이스 보면 이제 감염자 수
토탈 케이스 누적을 본 겁니다 

475
00:33:59,160 --> 00:34:03,089
이렇게 보면 아직 우리나라는 바닥에 깔려 있는 중이긴 합니다


476
00:34:03,463 --> 00:34:07,620
자 이번에는 백만 명당 새로운 케이스의 증가폭을 보면


477
00:34:07,645 --> 00:34:10,706
우리나라가 꽤 크게 증가하고 있음을 볼수 있습니다


478
00:34:10,768 --> 00:34:15,127
우리나라만 증가하는 게 아니라
현재 영국도 비슷하게 증가를 하고 있죠 

479
00:34:16,810 --> 00:34:20,114
굉장히..
어떡해 안타까운데 

480
00:34:20,139 --> 00:34:25,138
우리나라의 백만 명당 증가수를 보면은


481
00:34:25,933 --> 00:34:29,300
지지난주 부터 굉장히 급격하게 증가한 것을 보실 수가 있습니다


482
00:34:32,500 --> 00:34:36,117
네 간단하게 이제 데몬스트레이션을 해서 그림을 그려봤습니다


483
00:34:37,210 --> 00:34:39,615
그러면 이제 조금 더 재미있는걸 해봅시다


484
00:34:39,639 --> 00:34:41,756
아까 제가 Pyodide 설명드렸을 때


485
00:34:41,772 --> 00:34:46,815
얘는 기본적으로 WebAssembly기 때문에 
DOM을 접근할 수 있다고 설명드렸잖아요? 

486
00:34:46,840 --> 00:34:50,893
그래서 접근하기 위해서 'js' 라는 파이썬 모듈을 제공을 합니다


487
00:34:50,918 --> 00:34:54,549
얘는 DOM에 있는 어떤 값을 갖고 있을 수 있게 해줘요


488
00:34:54,574 --> 00:34:58,155
여기 보시면 "from js import document, window" 하면


489
00:34:58,179 --> 00:35:01,046
실제로 자기가 속해 있는


490
00:35:01,071 --> 00:35:06,429
그 브라우저의 document랑 window 객체에 대한 Proxy를 줍니다


491
00:35:07,210 --> 00:35:12,256
그 다음에 이거를 BrowserFS를
통해서 아까 전에 LocalStorage로 연결했다면 

492
00:35:12,280 --> 00:35:16,186
이제 이건 어쨌든 Electron 이니까 nodeIntegration 옵션을 켜고


493
00:35:16,210 --> 00:35:22,514
그 다음에 Emscripten 자체를 NodeFS를 지원하도록
리컴파일을 하면은 실제 파일 시스템에도 접근할 수 있겠죠 

494
00:35:23,920 --> 00:35:27,316
NodeFS는 디폴트로는 꺼져 있습니다


495
00:35:27,340 --> 00:35:32,019
작년 가을 버전 이후에는 NodeJS 파일 시스템이 꺼져 있기 때문에


496
00:35:32,044 --> 00:35:35,527
그것들을 옵션을 주고 수정을 해서 새로 컴파일을 해야 됩니다


497
00:35:37,750 --> 00:35:43,636
그 다음에 이제 내가 필요한 라이브러리가 있으면 가져와서 추가를 하는 절차입니다


498
00:35:43,660 --> 00:35:47,572
이걸 위해서 Pyodide 소스 코드에 해보시면 'mkpkg'라는 게 있고


499
00:35:47,597 --> 00:35:53,386
이 mkpkg를 통해서 내가 원하는 패키지의 meta.yaml 파일을 만들 수가 있습니다


500
00:35:53,410 --> 00:35:55,339
그리고 이것을 빌드를 할 수가 있고요


501
00:35:55,683 --> 00:36:00,574
이렇게 빌드를 하면은 그 빌드한 WebAssembly 
패키지를 내가 불러 쓸 수 있게 됩니다 

502
00:36:02,260 --> 00:36:06,992
자 그러면 이제 이것들을 엮어서 좀 재미있는 예제를 한번 보겠습니다


503
00:36:07,017 --> 00:36:11,566
데이터를 갖고 오고 
그 다음에 데이터 프리 프로세싱은 Pandas를 통해서 할 거예요 

504
00:36:11,590 --> 00:36:14,866
그리고 그 Pandas를 통해서 만들어진 데이터를


505
00:36:14,890 --> 00:36:17,772
TensorFlow.js 자바스크립트 라이브러리로 보내서


506
00:36:18,490 --> 00:36:20,644
모델을 훈련하고 결과물을 만든 다음에


507
00:36:20,669 --> 00:36:25,239
그 결과물을 다시 파이썬으로 갖고 와서 데몬스트레이션 할 겁니다


508
00:36:26,650 --> 00:36:27,454
신기하겠죠


509
00:36:28,150 --> 00:36:29,064
한번 해봅시다


510
00:36:40,622 --> 00:36:41,973
패키지를 들고 오고요


511
00:36:42,730 --> 00:36:47,987
이제 이 중간에 결과들은 오른쪽 아래에 있는
콘솔을 참고하시면 조금 더 보기 좋으실 겁니다 

512
00:36:51,760 --> 00:36:56,431
갖고 와서 
자 이제 데이터를 갖고 올 건데 얘는 이제 

513
00:36:56,456 --> 00:36:59,439
저희는 마이크로소프트 주식을 갖고 올 겁니다


514
00:37:00,700 --> 00:37:05,266
주식을 21세기 주식 자료를 갖고 와서 쭉 뿌릴 겁니다


515
00:37:05,290 --> 00:37:10,336
1999년부터 2020년까지 주식자료인데 보시면 이게


516
00:37:10,360 --> 00:37:13,420
정형화된 JSON이 아니기 때문에 빼줘야 되는 애들이 있어요


517
00:37:13,445 --> 00:37:17,776
1 2 3 4 5 이렇게 앞에 잘못 붙은 인덱스들은 제거를 하고


518
00:37:17,800 --> 00:37:22,786
그 다음에 'Meta Data'라고 되어 있는 거를 남기면,


519
00:37:22,810 --> 00:37:26,895
이 'Meta Data'라고 부르는 필드 안에 JSON이 들었거든요


520
00:37:27,370 --> 00:37:33,702
여기 보시면 이렇게 긁으면 이게 JSON인데 
JSON을 붙여서 분석을 한 다음에 

521
00:37:33,727 --> 00:37:39,391
여기서 이제 시장이 닫힐 때의 가격만 취해서 
'price'라는 칼럼을 새로 만들겠습니다 

522
00:37:42,230 --> 00:37:43,248
이제 한번 볼까요?


523
00:37:43,273 --> 00:37:44,968
'price'라는 칼럼이 쭉 만들어졌죠


524
00:37:45,610 --> 00:37:51,376
자 그러면 이거를 그냥 쓰지 않고 이제


525
00:37:51,400 --> 00:37:53,686
한번 실제로 값이 어떻게 됐는지 봅시다


526
00:37:53,710 --> 00:37:57,545
이제 시간 순으로 정렬을 해서


527
00:37:57,570 --> 00:38:02,499
ts라는 새로운 Pandas 데이터를 만들었고
이제 한번 뿌려봅시다 

528
00:38:02,980 --> 00:38:06,362
그러면 마이크로소프트의 주식 변화를 보실 수가 있죠


529
00:38:06,970 --> 00:38:09,446
자 그러면 이제 Simple Moving Average라고 해서


530
00:38:10,000 --> 00:38:13,375
뭐 과거 얼마만큼의 시간 동안의


531
00:38:13,400 --> 00:38:16,734
Moving Average, 평균값을 기반으로


532
00:38:16,765 --> 00:38:21,052
우리가 이 데이터의 트레이닝 셋을 만들고 훈련시켜서


533
00:38:21,490 --> 00:38:23,669
가격을 예측하는 모델을 한번 만들어 봅시다


534
00:38:25,090 --> 00:38:26,656
뭐 50일 정도를 씁시다


535
00:38:26,680 --> 00:38:30,016
window_size는 50일로 하고 데이터를 만들 거예요


536
00:38:30,040 --> 00:38:33,665
지금 현재부터 과거까지 50개씩만 딱 사용하도록 만들었죠


537
00:38:35,890 --> 00:38:39,718
그 다음에 이제 실제로 데이터가 들어갔는지 봅시다
네. 뭐 하나 들어왔네요 

538
00:38:40,090 --> 00:38:43,448
얘가 이제 우리가 트레이닝 시킬때의 피처가 될 겁니다


539
00:38:43,753 --> 00:38:47,268
아! 피처가 아니라 이제 결과값이 될 거고


540
00:38:47,393 --> 00:38:52,175
그 결과값을 만들기 위해서 들어갔던 얘들이


541
00:38:52,200 --> 00:38:55,456
Moving Average를 구하기 전의 데이터 50개씩이 되겠죠


542
00:38:55,480 --> 00:39:00,925
그러면은 window_data[0]을 인풋으로
피처로 넣으면은 sma[0]이 나와야 되는 거예요 

543
00:39:00,956 --> 00:39:05,698
자 그러면 자 이제부터 자바스크립트 쪽으로 바통을 넘겨봅시다


544
00:39:11,470 --> 00:39:14,555
js를 import 해올게요
어떤게 되는지 볼까요? 

545
00:39:16,870 --> 00:39:20,176
자 이렇게 document를 바로 액세스해서 색깔을 바꿔보겠습니다


546
00:39:20,200 --> 00:39:22,537
짜잔 앱 색깔이 바뀌었죠


547
00:39:22,600 --> 00:39:24,896
자 파란색으로 한번 해볼까요?


548
00:39:25,154 --> 00:39:25,785
짜잔


549
00:39:25,810 --> 00:39:28,411
이번에는 노란색으로 해보겠습니다


550
00:39:29,817 --> 00:39:31,926
네 바로 액세스가 되죠


551
00:39:32,090 --> 00:39:33,646
다시 하얀색으로 바꾸고요


552
00:39:33,670 --> 00:39:36,417
자 이제 DOM에 액세스가 돼요


553
00:39:36,442 --> 00:39:38,699
Document Object Model에 액세스가 되고


554
00:39:38,676 --> 00:39:41,865
거기는 사실 이 앱에서는 기본적으로


555
00:39:41,890 --> 00:39:43,738
TensorFlow.js가 붙어 있습니다


556
00:39:44,035 --> 00:39:47,214
자 그러면 데이터를 자바스크립트로 이렇게 패스를 할게요


557
00:39:47,620 --> 00:39:51,766
자바스크립트를 여기서 실행하기 위해서 제가 js라는 명령을 추가해놨는데


558
00:39:51,791 --> 00:39:56,541
개는 이제 바로 들어온 코드를 eval해서 돌리는 코드입니다


559
00:39:56,612 --> 00:40:01,666
그런데 그 코드는 스코프가 실행된 블록에 한정이 되기 때문에


560
00:40:01,690 --> 00:40:03,727
어디서든 엑세스 할 수 있게 하려면


561
00:40:03,752 --> 00:40:06,815
여기 window 처럼 글로벌 객체에 붙여야 됩니다


562
00:40:06,840 --> 00:40:09,796
자 데이터를 inputs, outputs로 보냈고요


563
00:40:09,821 --> 00:40:12,399
처음에 !js 라고 붙은걸 실행을 하면은


564
00:40:13,711 --> 00:40:16,453
그 이 안에는 자바스크립트 코드가 돌아가는 겁니다


565
00:40:16,478 --> 00:40:20,056
결과물은 지금 여기 좀 기다리면 나올 거예요


566
00:40:20,080 --> 00:40:22,790
5191, 5191이 나왔죠 데이터 사이즈


567
00:40:23,117 --> 00:40:25,069
이제 트레이닝 코드입니다


568
00:40:25,094 --> 00:40:29,625
자 이제 TesorFlow.js 트레이닝 코드를 만들어서 실제로 트레이닝을 해봅시다


569
00:40:30,190 --> 00:40:32,836
자 이제 트레이닝 되는 동안 시간이 걸릴 테니까


570
00:40:32,860 --> 00:40:36,281
오른쪽 아래의 Epoch 올라가는 걸 확인하면서 코드를 간단하게 봅시다


571
00:40:36,550 --> 00:40:43,306
얘는 Simple Moving Average를 구할 때
들어가는 과거 50일 동안의 값을 가지고 

572
00:40:43,330 --> 00:40:46,594
그 결과값으로 나온 얘를 트레이닝을 해서


573
00:40:46,619 --> 00:40:49,954
나중에는 이제 과거 결과값 50일을 넣으면


574
00:40:49,979 --> 00:40:54,706
그 다음 날을 예측하도록 만든 굉장히 간단한 RNN 모델이에요


575
00:40:54,730 --> 00:40:58,355
그래서 RNN 모델로 이제 뉴런들 정리하고


576
00:40:58,380 --> 00:41:03,401
시퀀셜로 모델을 만들고 그 모델에 이제 데이터를 넣죠


577
00:41:03,440 --> 00:41:08,033
보시면은 이제 데이터를 위에서 tensor2d로 형태를 만들어놓고


578
00:41:08,410 --> 00:41:10,966
실제로 이제 레이어를 더하고요


579
00:41:10,990 --> 00:41:15,256
레이어수는 아까 전에 인풋으로 처음에 지정을 해줬습니다
원하면 더 늘릴 수도 있겠죠 

580
00:41:15,280 --> 00:41:18,676
그 다음에 이제 컴파일하고 Loss function으로 Mean square error를 썼고요


581
00:41:18,700 --> 00:41:22,192
그 다음에 중간 결과값을 보기 위해서 여기 콜백을 정의를 해놨어요


582
00:41:22,387 --> 00:41:25,722
이게 Epoch이 끝날 때마다 콜백을 호출하게 되는데


583
00:41:25,785 --> 00:41:30,378
그 콜백 값이 지금 여러분들 오른쪽 아래에 
나오고 있는 Epoch이랑 Loss 값입니다 

584
00:41:31,030 --> 00:41:36,044
제가 이거 몇 번 해봤는데 대충 뭐 
10 정도면은 수렴하는 것 같더라고요 

585
00:41:36,069 --> 00:41:37,600
그래서 10만 돌렸습니다


586
00:41:39,381 --> 00:41:44,498
이제 4개 짜리 레이어가 있는 모델을 쭉쭉쭉 돌려봅시다


587
00:41:47,290 --> 00:41:52,030
여기 보면 inputs랑 outputs을 위에 있는 70% 데이터만 잘랐어요


588
00:41:52,055 --> 00:41:56,305
그러니까 앞부분 70%의 데이터로 뒷부분 30퍼센트가 예측됐는지를 볼 겁니다


589
00:41:57,040 --> 00:42:03,500
그래서 여기 트레이닝 사이즈가 70인데 70/100이니까 0.7이겠죠


590
00:42:04,060 --> 00:42:08,341
그래서 전체 길이에서 그만큼만 자른 걸 인풋으로 쓰고
그만큼만 자른걸 아웃풋으로 썼습니다 

591
00:42:08,680 --> 00:42:12,946
그래서 전체 데이터에서 뒷부분 30%는 나중에 뒤에서 예측하겠습니다


592
00:42:12,970 --> 00:42:17,454
자 되는 동안 어짜피 이제 결과 트레이닝 보는 거는


593
00:42:17,479 --> 00:42:21,095
그 Promise니까 미리 붙여놔도 되거든요. 붙였고요


594
00:42:21,199 --> 00:42:25,432
이제 계산이 되면은 
아 !js를 안붙였네요 

595
00:42:25,457 --> 00:42:30,628
자바스크립트인데 안붙였으니까 지금 파이썬에서 돌리려고 해서 
에러가 났던 거고 자 돌려봅시다 그러면 

596
00:42:30,972 --> 00:42:34,564
결과물이 나올 거고 다 됐으니까 이제 Prediction calculated라고 나왔죠


597
00:42:34,589 --> 00:42:39,214
자 결과물이 그러면 이제 window.predicted_results에 들어갔을 거예요


598
00:42:40,540 --> 00:42:45,616
아 아까 빼먹은게 있는데 기본적으로 파이썬에서 자바스크립트로 넘겨줄 때는


599
00:42:45,640 --> 00:42:49,126
64bit float가 됐기 때문에 중간 변화하는 과정이 필요합니다


600
00:42:49,150 --> 00:42:51,017
나중에 위에 코드를 보시면 될 거예요


601
00:42:51,520 --> 00:42:57,176
자 그러면 다시 파이썬에서 자바스크립트 데이터를 갖고 왔습니다


602
00:42:58,060 --> 00:43:05,814
컨버트를 하고 이제 결과를 보죠. 이게 이제 Prediction인데
이게 이제 앞부분 70%로 뒷부분 30%를 예측한 거니까 

603
00:43:05,845 --> 00:43:08,767
뒷부분에 Ploting을 해봐야 정확도를 비교할 수 있겠죠


604
00:43:10,060 --> 00:43:13,356
자 그러면 뒷부분에 해당되는 X축 데이터를 만들고


605
00:43:13,381 --> 00:43:18,706
이게 이제 처음 70% 말고 70% 이후에 30%에 대한 X값이고


606
00:43:18,730 --> 00:43:21,046
그 다음에 거기에 대한 참 값을 만들어서 Ploting 해봤습니다


607
00:43:21,070 --> 00:43:26,146
보시면 이제 주황색 값이 예측을 한 거고요 이제


608
00:43:26,170 --> 00:43:28,486
실제 데이터 값이 가이드라인으로 표시된 겁니다


609
00:43:28,510 --> 00:43:31,366
대충 비슷하게 맞다가 뒤에선 좀 깨지죠


610
00:43:31,390 --> 00:43:36,327
아무래도 그 앞에 데이터를 학습해서는 저렇게
끝없이 올라가는 곡선을 예측하는 건 불가능한 것 같습니다 

611
00:43:36,880 --> 00:43:42,286
자 이제 파이썬을 웹 브라우저기반


612
00:43:42,310 --> 00:43:44,472
정확히는 Electron 기반으로 돌리고


613
00:43:44,497 --> 00:43:47,456
파이썬 결과물을 자바스크립트로 보내서 트레이닝을 시키고


614
00:43:47,481 --> 00:43:51,691
결과물로 도로 받아와서 파이썬에서 데몬스트레이션하는 걸 해봤습니다


615
00:43:52,450 --> 00:43:53,200
재미있죠


616
00:43:53,860 --> 00:43:56,133
온갖 아이디어들이 생각나실 수 있을 겁니다


617
00:43:57,550 --> 00:44:01,216
퍼포먼스는 어떻게 되느냐? 네
제 맥에서 돌려봤던 퍼포먼스인데 

618
00:44:01,240 --> 00:44:05,401
기본적인 다섯 가지 종류에 대해서 퍼포먼스를 측정을 했는데


619
00:44:05,830 --> 00:44:09,056
기본적으로 속도가 느리죠 느린 이유는


620
00:44:09,081 --> 00:44:17,656
뭐 코드가 굉장히...
컴파일한 코드들의 문제일 수도 있고요 

621
00:44:17,680 --> 00:44:23,912
라이브러리들이 이제 최적화된 뭐 매트릭스
라이브러리들이 컴파일이 안 되어 있을 수도 있고요 

622
00:44:23,937 --> 00:44:26,427
뭐 기본적으로는 일단 싱글 스레드라서 그렇습니다


623
00:44:26,890 --> 00:44:31,569
나머지 이제 데스크탑에서 돌린 초록색 결과는


624
00:44:32,230 --> 00:44:37,230
전부 다 이제 8코어를 다 풀로 사용해서 돌아간 것들인데


625
00:44:37,690 --> 00:44:41,716
이제 나머지 브라우저에서 돌린 것들은
기본적으로는 코어 하나만 사용을 하는 거죠 

626
00:44:41,740 --> 00:44:46,146
그렇다고 해도 이제 파이어폭스가


627
00:44:46,171 --> 00:44:49,888
크롬이나 크로미움 계열보다 훨씬 더 속도가 잘 나오는 것을 보실 수 있습니다


628
00:44:51,010 --> 00:44:55,595
기본적으로 속도가 큰 계산을 돌릴 때는 문제가 되겠지만


629
00:44:56,320 --> 00:45:01,523
뭐 연구 프로토타입, 아니면은 그냥 학습용


630
00:45:01,930 --> 00:45:06,466
수업용으로는 굉장히 충분한 정도라고 볼 수 있겠습니다


631
00:45:06,490 --> 00:45:10,096
여기 나온 연산들이 좀 힘든 연산들이에요


632
00:45:10,120 --> 00:45:13,370
자 문제는 뭐냐면 파이어폭스가 속도가 잘 나오긴 하는데


633
00:45:13,440 --> 00:45:17,002
오래 걸리는 스크립트를 놀리면 파이어폭스가 자체적으로 중단을 합니다


634
00:45:17,290 --> 00:45:22,786
그래서 그걸 고치기 위해서는 파이어폭스에서는
max_script_run_time 이라는 값을 조작을 해줘야 되고 

635
00:45:22,810 --> 00:45:28,292
그냥 제가 권장하는 것은 제가 빌드한 Electron App을 쓰는 겁니다


636
00:45:28,317 --> 00:45:29,919
그냥 걔를 쓰면 됩니다


637
00:45:31,480 --> 00:45:36,105
그래서 스터디용으로는 굉장히 충분 하지만


638
00:45:36,130 --> 00:45:40,503
이제 뭐 반대로 뒤집어보면 헤비 워크로드는
잘 감당 못한다 라는 문제점이 있습니다 

639
00:45:41,514 --> 00:45:43,045
자 이제 아이디어를 몇 개를 내볼 수 있는데요


640
00:45:43,070 --> 00:45:48,678
하나는 풀 파이썬이 아니라 마이크로 파이썬을 컴파일을 
해서 WebAssembly에 올리면 얼마나 가벼워질까? 

641
00:45:49,540 --> 00:45:53,711
그러면 파이썬 언어로 DOM을 조작할 수 있으니까


642
00:45:53,781 --> 00:46:00,836
웹 페이지 제너레이터나 아니면 웹 페이지용
도구로 파이썬 언어를 사용할 수 있을까? 

643
00:46:01,540 --> 00:46:03,436
이제 기본 파이썬 너무 크니까요?


644
00:46:03,460 --> 00:46:05,356
마이크로 파이썬이 더 작을 수 있잖아요


645
00:46:05,380 --> 00:46:08,280
Python-based Single Page Application을 만들 수 있지 않을까?


646
00:46:08,305 --> 00:46:10,258
하는 아이디어 하나 있었고


647
00:46:10,840 --> 00:46:18,316
그 다음에 두 번째로는 그 Micropip 라는게
Pyodide 안에 들어 있습니다 

648
00:46:18,340 --> 00:46:23,776
그래서 그걸 사용하면은 파이썬 패키지들을 설치할 수 있게 되는데


649
00:46:23,800 --> 00:46:28,425
그런 게 아니라 이제 바이너리 패키지 컴파일이 필요한 경우들은


650
00:46:29,470 --> 00:46:30,616
여러 가지 작업들이 더 필요해요


651
00:46:30,640 --> 00:46:32,890
그런데 그런 것들을 미리 만들어져 있는


652
00:46:32,915 --> 00:46:37,846
PyPI에 해당되는 어떤 리파지토리가 있으면 굉장히 쉽게 갈 수 있겠죠


653
00:46:37,870 --> 00:46:42,720
지금은 이제 Pyodide의 CDN 같은 경우가 그 역할을 하게 되는데


654
00:46:42,745 --> 00:46:45,651
CDN 같은 경우는 이제 그냥 버젼을 계속 따라가게 되고


655
00:46:46,090 --> 00:46:50,340
누구나 참여해서 뭔가 계속 추가할 수 있는 Echo sphere 역할은 좀 약하니까요


656
00:46:51,160 --> 00:46:55,126
그 다음에 세 번째로는 JupyterLab에 integrate 해버리는 겁니다


657
00:46:55,150 --> 00:47:01,876
예를 들면 JupyterLab을 돌리는데 거기서
돌리는 브라우저 리소스가 그 Jupyter가 돌아가는 

658
00:47:01,900 --> 00:47:03,734
브라우저. 그것을 사용하는 거죠


659
00:47:03,759 --> 00:47:08,679
밖에 별도로 커널에 보내는 게 아니라 
jyve 같은 프로젝트들이 있어요 

660
00:47:08,704 --> 00:47:11,566
그런 거를 이제 이 Iodide 기반으로 하려고 하는


661
00:47:11,590 --> 00:47:16,275
그런데 기본적으로 구현체 자체가 시큐리티 이슈를 해결을 못하고 있고


662
00:47:16,300 --> 00:47:20,673
돌리려면 똑같이 JupyterLab을 내 컴퓨터에서 실행을 해야 됩니다


663
00:47:20,698 --> 00:47:23,344
그런 것들이 문제점으로 아직 있죠


664
00:47:23,369 --> 00:47:26,356
그리고 굉장히 다양한 아이디어들을 내볼 수 있을 거예요


665
00:47:26,380 --> 00:47:30,256
여러분들은 어떤 아이디어가 나세요? 생각이 나세요?


666
00:47:30,280 --> 00:47:35,473
파이썬으로 웹 브라우저에 이런 저런 것들을 할 수 있다거나


667
00:47:35,498 --> 00:47:38,333
아니면 여러분들이 만든 과학 연산 코드를


668
00:47:38,358 --> 00:47:41,506
그대로 웹 페이지 형태로 제공을 해서


669
00:47:41,530 --> 00:47:45,145
사람들이 자신의 컴퓨터나 모바일에서 돌릴 수 있게 한다고 하면


670
00:47:45,170 --> 00:47:47,185
굉장히 다양한 생각을 해볼 수 있겠죠


671
00:47:47,909 --> 00:47:50,309
예를 들면 Iodide에서는 그런 페이지들이 있는데


672
00:47:50,334 --> 00:47:55,560
웹 페이지인데 Iodide 백앤드나
Pyodide 백앤드를 쓰고 있어서 

673
00:47:55,585 --> 00:47:57,646
중간 중간에 실행하는 부분들이


674
00:47:58,450 --> 00:48:01,815
이제 서버사이드에 부담 없이 사용자가 바로 실행을 할 수 있게 한다거나


675
00:48:01,840 --> 00:48:06,760
아니면 이제 놀랍게도 SDL이 컴파일이 되있습니다


676
00:48:06,785 --> 00:48:09,674
SDL 컴파일되어 있으면 PyGame이 같이 따라올 수 있겠죠?


677
00:48:09,699 --> 00:48:13,128
그럼 PyGame 구현체를 웹에서 구현할 수 있을 테니까


678
00:48:13,570 --> 00:48:16,437
파이썬으로 만든 간단한 게임을 웹에서 서빙할 수도 있겠죠


679
00:48:16,695 --> 00:48:18,288
이런 것들도 아이디어가 되겠습니다


680
00:48:18,850 --> 00:48:21,223
더 많은 아이디어들이 생각이 나실 수 있을거에요


681
00:48:21,248 --> 00:48:25,357
여러분들이 이 발표를 듣고 여러 가지 생각을 해보셨으면 좋겠습니다


682
00:48:26,890 --> 00:48:30,929
오늘 발표했던 코드는 다 이 저장소에서 보실 수가 있고요


683
00:48:31,360 --> 00:48:36,733
기본적인 저장소 구조는
앱을 빌드하기 위한 내용들이 있고 

684
00:48:36,758 --> 00:48:40,890
중간에 예제 코드들이나 테스트 코드들은
examples 안에 있으니까 참고하시기 바랍니다 

685
00:48:41,238 --> 00:48:42,765
지금까지 들어주셔서 감사합니다


686
00:48:45,162 --> 00:48:47,398
얼른 코로나 끝나고 만나요


