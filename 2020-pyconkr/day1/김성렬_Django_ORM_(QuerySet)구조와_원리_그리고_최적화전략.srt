1
00:00:10,920 --> 00:00:13,570
발표 시작하도록 하겠습니다

2
00:00:13,600 --> 00:00:18,580
안녕하세요. 저는 이번 발표를 진행하게 된 김성렬이라고 합니다

3
00:00:18,610 --> 00:00:21,540
Django ORM을 공부한 내용들을 정리해서

4
00:00:21,560 --> 00:00:26,200
도움이 되는 내용을 공유드리고자 발표를 하게 되었습니다

5
00:00:26,710 --> 00:00:33,610
청취자 대상은 약간이라도 QuerySet을
사용해 본 적이 있는 사람들을 대상으로 하는 발표이고요

6
00:00:33,640 --> 00:00:40,350
그렇기 때문에 완전 초보적인 내용들은 과감하게 생략을 하도록 했습니다

7
00:00:40,960 --> 00:00:48,720
그리고 이 발표를 통해서 초보자 분들은 QuerySet에 대한
기초를 이해할 수 있도록 도움을 드리고

8
00:00:48,760 --> 00:00:55,780
중급자들 분들께는 '이런 것도 있구나' 라는 내용과 Django ORM 중에서

9
00:00:55,810 --> 00:01:00,010
QuerySet이라는 구현제가 어떤 구조로 이루어져 있는지에 대해서

10
00:01:00,030 --> 00:01:02,960
지식을 얻어갈 수 있었으면 좋겠습니다

11
00:01:03,760 --> 00:01:09,140
그러면 원래는 초반에 기획했던 발표 내용은 되게 원론적이고

12
00:01:09,160 --> 00:01:13,570
깊은 내용들을 나열하는 방식을 의도 했었는데

13
00:01:13,600 --> 00:01:18,640
발표 자료를 작성하다 보니까 구조적인 내용에 대해서 나열하거나

14
00:01:18,670 --> 00:01:23,800
원론적인 내용들을 걷어내고 또 걷어내게 됐어요

15
00:01:23,830 --> 00:01:28,050
발표가 그렇게 되니까 굉장히 지루해지더라고요

16
00:01:28,450 --> 00:01:34,460
그래서 최대한 도움이 될 만한 결과적인 내용들을 담으려고 노력을 했고요

17
00:01:35,560 --> 00:01:38,250
그러면 발표 시작하도록 하겠습니다

18
00:01:38,980 --> 00:01:41,520
목차입니다

19
00:01:41,540 --> 00:01:47,350
일단 첫 번째로 왜 이 발표를 시작하게 됐는지 간단하게 이야기를 드리고

20
00:01:47,380 --> 00:01:52,290
2장에서는 간단하게 ORM의 특징들에 대해서 짚고 넘어가고자 합니다

21
00:01:52,310 --> 00:01:57,340
여기서는 초보자분들에게 약간 도움이 되는 내용들을 설명을 드리려고 하고

22
00:01:57,370 --> 00:02:02,860
3장에서는 이 내용을 기반으로 QuerySet이
어떤 구조로 이루어져 있는지에 대해서 설명을 하고

23
00:02:02,880 --> 00:02:06,610
4장에서는 QuerySet를 사용하면서 착각하기 쉽고

24
00:02:06,640 --> 00:02:10,840
뭔가 실수하기 쉬운 내용들에 대해서 좀 더 알아보자 보고자 합니다

25
00:02:10,870 --> 00:02:16,400
그리고 이 발표 마지막에 프로젝트에 대해서 공유를 드릴거지만

26
00:02:16,450 --> 00:02:25,840
이 PPT에서 나오는 결과물들은 Python: 3.8, 3.7
그리고 Django: 2.2, 3.0, 3.1 에 대해서

27
00:02:25,870 --> 00:02:30,340
이렇게 체크를 해보고 수행을 해본 내용들로 구성이 되어 있습니다

28
00:02:30,860 --> 00:02:37,620
물론 여기 언급한 버전들이 이 정도긴 하지만 Django: 1.9 이상이기만 하면은

29
00:02:37,670 --> 00:02:44,200
이 발표에서 이야기하는 결과 내용과 큰 차이가 없을 거예요

30
00:02:44,260 --> 00:02:48,080
왜 1.9 인지는 발표 중에 설명을 드리도록 하겠습니다

31
00:02:48,110 --> 00:02:50,450
그러면 발표 시작하겠습니다

32
00:02:50,770 --> 00:02:54,860
제가 이 발표를 시작하게 된 계기는 되게 간단합니다

33
00:02:54,880 --> 00:03:00,730
개인적인 생각이지만 파이썬 기초를
공부하고자 하면은 기초를 공부하기 위한 내용들은

34
00:03:00,760 --> 00:03:03,710
온라인에서 되게 많이 볼 수 있는데

35
00:03:03,730 --> 00:03:07,850
거기서 조금만 더 심화된 내용이나 깊은 내용들을 찾으려고 하면은

36
00:03:07,870 --> 00:03:13,680
그 자료량이 되게 급격하게 감소한다고 저는 되게 많이 느꼈어요

37
00:03:13,700 --> 00:03:17,120
이게 굳이 파이썬에만 국한된 내용은 아닐 것이긴 하지만요

38
00:03:17,150 --> 00:03:21,180
특히 프레임워크 같은 것들을 공부하려고 하면은 그 자료랑이

39
00:03:21,210 --> 00:03:23,830
일반적으로 더 크게 줄어드는 것 같더라구요

40
00:03:23,860 --> 00:03:29,460
마찬가지로 저는 ORM을 Hibernate로
처음 접해서 공부를 하기 시작했는데

41
00:03:29,480 --> 00:03:33,110
너무 원론적이다 라고 생각할 만한 내용부터

42
00:03:33,130 --> 00:03:37,580
정말 필요하다 라고 생각할 만한 내용까지 꽤 설명이 잘된 자료들을

43
00:03:37,600 --> 00:03:43,660
나름 어렵지않게 검색을 통해서 찾고
그리고 책을 통해서 얻을 수 있었던 것 같아요

44
00:03:43,690 --> 00:03:46,530
그런데 배우는 것이 어려워도

45
00:03:47,020 --> 00:03:50,220
자료를 얻는 것은 그렇게 어렵지 않았다고 생각을 했어요

46
00:03:50,240 --> 00:03:52,710
근데 Django를 공부하면서

47
00:03:53,050 --> 00:04:01,960
웹 프로그래밍, MTV 패턴 이런 키워드들을 벗어나기만 하면
자료들이 되게 급격하게 줄어든다고 저는 느꼈어요

48
00:04:02,020 --> 00:04:08,620
검색을 해보았을 때 뭔가 '왜 이렇게 동작하는 거지'라는
것들을 알기 위해서 검색을 했을 때

49
00:04:08,640 --> 00:04:12,580
그 얻고자 하는 정보들이 되게 많이 줄어들기도 하고요

50
00:04:12,610 --> 00:04:18,310
공식 문서도 분명 유용하고 좋은 문서 이긴 하지만
내용들이 Django ORM의 큰 그림

51
00:04:18,330 --> 00:04:24,400
그러니까 아키텍처를 보는 데 있어서 되게
좀 어렵고 약간 아쉽다는 점들을 좀 개인적으로 느꼈어요

52
00:04:24,430 --> 00:04:28,990
그래서 Django 소스 코드를 열어보고 이것저것 공부를 해보고

53
00:04:29,020 --> 00:04:35,130
그 내용들에 대해서 정리를 한번 하고 공유를
같이 하고 싶어서 발표를 하게 되었습니다

54
00:04:35,740 --> 00:04:42,720
ORM에는 여러가지 개념들이 있는데 그중에서 몇 몇
간단한 내용들만 일단 먼저 설명을 하고 넘어가고자 합니다

55
00:04:42,740 --> 00:04:45,970
첫 번째로 Lazy Loading이라는 개념이 있어요

56
00:04:45,990 --> 00:04:51,120
ORM에서는 정말 필요한 시점에만 SQL을 호출하는 특징이 있어요

57
00:04:51,610 --> 00:04:57,350
왼쪽 예제를 보시면은 초보자 분들이 그 흔히 착각하기 쉬운 부분인데

58
00:04:58,090 --> 00:05:01,150
마우스의 가르키는게 보이실지 모르겠지만

59
00:05:01,180 --> 00:05:04,450
이 첫 번째 줄에 보시면은 User.objects.all()

60
00:05:04,480 --> 00:05:07,750
해 가지고 QuerySet을 선언을 하게 되면

61
00:05:07,780 --> 00:05:12,020
그 선언된 시점에는 다만 QuerySet에 지나지 않아요

62
00:05:12,040 --> 00:05:16,130
그러니까 이 말이 뭐냐 하면 원래 일반적으로 사람들이 선언할 때

63
00:05:16,150 --> 00:05:19,540
이거를 user_list 해가지고 선언을 하잖아요

64
00:05:19,570 --> 00:05:23,510
그런데 그렇게 선언을 하고 정말 이 여기에 넘어오는 것이

65
00:05:23,540 --> 00:05:28,310
User 모델의 list가 넘어온다고 이렇게 착각을 하실 때가 많은데

66
00:05:28,330 --> 00:05:32,030
선언한 시점에는 아직 QuerySet으로 여전히 남아 있게 돼요

67
00:05:32,060 --> 00:05:35,710
일반적으로 뭔가 변수명들를 그런 식으로 사용하긴 하지만

68
00:05:35,770 --> 00:05:38,970
실제로 정말로 User 리스트가 되는 시점

69
00:05:38,990 --> 00:05:43,450
그러니까 User 리스트가 되는 시점은 QuerySet을

70
00:05:43,480 --> 00:05:46,420
list()로 묶어가지고 묶어주는 시점에

71
00:05:46,450 --> 00:05:52,400
QuerySet이 동작을 해가지고 SQL이 수행되어서
우리가 원하는 데이터를 가져오게 됩니다

72
00:05:52,430 --> 00:05:56,660
그러니까 사람들이 착각하는거는 여기에 선언한 시점에

73
00:05:56,690 --> 00:06:01,120
이미 User의 리스트 데이터가 들어와 있다 라고 생각하기 쉽지만

74
00:06:01,150 --> 00:06:07,810
실제로는 list()로 묶는 이 시점에 정말로 SQL이 수행되고 데이터가 가져와 지는 거죠

75
00:06:09,040 --> 00:06:11,230
여기서 얘기하고 싶은 것은 그겁니다

76
00:06:11,260 --> 00:06:17,400
정말로 필요한 시점에만 ORM은 SQL을 호출해가지고 데이터를 가져오게 됩니다

77
00:06:18,670 --> 00:06:23,820
이 이야기는 정말 필요하지 않으면 QuerySet은 SQL 호출하지 않는다는 뜻입니다

78
00:06:23,840 --> 00:06:30,940
왼쪽 예제를 보시면은 이번에는 위쪽 예제와 다르게 3개의 QuerySet을 선언했는데요

79
00:06:30,970 --> 00:06:35,470
users QuerySet이 있고 orders QuerySet이 있고
companies QuerySet이 있을 수 있습니다

80
00:06:35,500 --> 00:06:41,050
하지만 list로 묶어가지고 실제로
데이터를 얻으려고 한 것은 users QuerySet 뿐에요

81
00:06:41,080 --> 00:06:47,650
이 로직상에서는
여기서는 QuerySet을 선언하기는 했지만 실제로 데이터를

82
00:06:47,680 --> 00:06:53,000
QuerySet을 호출하는 부분은 이
그러니까 users QuerySet 하나이기 때문에

83
00:06:53,050 --> 00:06:57,340
실제로 결과값을 보시면 발생하는 SQL 같은 경우에는

84
00:06:57,370 --> 00:07:01,350
users거 SQL 하나밖에 없다는 것을 알 수가 있죠

85
00:07:01,750 --> 00:07:09,180
이 예제를 통해서 보여드리고 싶은 것은
정말로 필요해야만 QuerySet은 SQL 호출한다는 점입니다

86
00:07:09,210 --> 00:07:13,660
orders QuerySet과 companies QuerySet을 선언해 놓았음에도 불구하고

87
00:07:13,690 --> 00:07:22,070
저희가 직접 정말로 사용하지 않으면
이 QuerySet은 SQL을 호출하지 않는다는 점이죠

88
00:07:23,050 --> 00:07:27,810
이러한 특성들 때문에 때로는 비효율적으로 ORM은 동작하기도 합니다

89
00:07:27,840 --> 00:07:33,160
이번 예제를 보시면은 users QuerySet을 선언하고 데이터를 호출하는데

90
00:07:33,190 --> 00:07:37,290
첫 번째 User만 호출을 했어요 이번에는

91
00:07:37,380 --> 00:07:41,930
users QuerySet을 선언하고 0번째 유저를 호출을 했죠

92
00:07:42,550 --> 00:07:48,290
이런 식으로 호출을 했을 때 실제 발생한
SQL은 정말 필요한 만큼만 호출을 하기 때문에

93
00:07:48,320 --> 00:07:52,210
모든 User를 불러오는 QuerySet을 선언했지만

94
00:07:52,240 --> 00:07:59,740
이 시점에서는 하나의 User만 필요하기 때문에
'LIMIT 1' 걸린 SQL이 호출이 돼요

95
00:07:59,770 --> 00:08:06,910
그 다음 로직에서 '모든 User를 가져와'라고
다시 QuerySet 에게 요청을 하게 되면

96
00:08:07,630 --> 00:08:13,000
앞에 쿼리가 발생했었던 것들을 무시를 하고

97
00:08:13,030 --> 00:08:17,460
다시 모든 User를 가져오기 위해서 SQL을 다시 호출하게 되는 거죠

98
00:08:19,780 --> 00:08:26,950
개발자라면은 이 로직상에서 SQL을 한 번만
호출해가지고 데이터를 재사용하면 된다는 걸 알지만

99
00:08:26,980 --> 00:08:30,580
QuerySet은 그걸 알지를 못하는 거죠

100
00:08:30,610 --> 00:08:34,330
지금 당장 필요한 만큼만 SQL을 호출 하려하기 때문에

101
00:08:34,360 --> 00:08:38,430
첫 번째 로직에서는 'LIMIT 1'이 걸린

102
00:08:38,450 --> 00:08:40,960
제약이 있는 SQL을 호출하고

103
00:08:41,000 --> 00:08:46,770
그 다음번 로직에서 모든 User를 가져오는 SQL을 한번 더 호출하는 거죠

104
00:08:47,440 --> 00:08:50,410
이런 식으로 비효율적으로 동작을 할 수도 있어요

105
00:08:51,620 --> 00:08:57,190
우리는 ORM이 SQL 수행결과를 캐싱해야 된다는 거를 알아야 되고요

106
00:08:57,600 --> 00:09:02,830
QuerySet에서 SQL을 호출을 하면은 그 데이터 결과를 가지고 있습니다

107
00:09:02,860 --> 00:09:06,640
이거는 QuerySet에서 Result cache라고 부르는데

108
00:09:06,670 --> 00:09:14,100
위에서 2-3에서 문제가 되었던 거는 불필요한 쿼리가 두 번 호출되었다는 점이죠

109
00:09:14,130 --> 00:09:17,590
불필요한 쿼리가 한 번 더 호출되었다는 점이잖아요

110
00:09:17,620 --> 00:09:22,320
이러한 문제를 해결하기 위해서는 QuerySet Caching을 재사용하는 방식을 사용해야 돼요

111
00:09:22,350 --> 00:09:28,140
그러니까 이 예제에서는 아까 예제와 다른 점은 순서만 그냥 바뀐 거예요

112
00:09:28,170 --> 00:09:34,200
first_user를 먼저 호출하는 게 아니라
모든 User를 QuerySet에서 먼저 호출하게 돼요

113
00:09:34,220 --> 00:09:39,640
이렇게 QuerySet에서 모든 User를 호출하도록 하면

114
00:09:39,670 --> 00:09:44,800
이 users QuerySet에는 모든 User의 정보가 캐싱되어 있는 상태인 거예요

115
00:09:44,830 --> 00:09:52,600
현 시점에서
그렇기 때문에 그 다음번 로직인 '첫 번째 User를 가져와'라는

116
00:09:52,630 --> 00:09:54,730
요청을 QuerySet에게 날렸을 때

117
00:09:54,760 --> 00:09:59,710
SQL을 호출하지 않고 '어 나는 아직 모든 유저의 정보를 가지고 있는데'

118
00:09:59,740 --> 00:10:02,230
'그러면 0번째 User를 캐시에서 가져와야겠다'

119
00:10:02,260 --> 00:10:07,570
하면서 SQL을 굳이 날리지 않고도
첫 번째 User의 정보를 얻을 수 있는 거죠

120
00:10:07,590 --> 00:10:13,270
따라서 이 로직의 수행 결과로는 SQL이 한 번만 호출되게 됩니다

121
00:10:13,300 --> 00:10:19,700
QuerySet은 캐싱을 하기 때문에 호출하는 순서가
바뀌는 것만으로도 SQL이 달라질 수 있다는 점이에요

122
00:10:20,050 --> 00:10:26,000
지금까지 설명한 내용들이 Lazy-Loading 그리고 캐싱 이런 내용들이 있어요

123
00:10:26,410 --> 00:10:30,100
QuerySet은 기본적으로 Lazy-loading이라는 전략을 택합니다

124
00:10:30,130 --> 00:10:36,410
하지만 늘 그렇듯이 SQL로 한 번에 많은 데이터를
끌어오고 싶을 때가 매번 있기 마련이죠

125
00:10:36,430 --> 00:10:40,040
이를 ORM에서는 Eager Loading이라고 부르고

126
00:10:40,060 --> 00:10:46,990
QuerySet에서는 이걸 지원하기 위해서 select_related,
prefetch_related라는 메소드를 제공합니다

127
00:10:47,020 --> 00:10:54,260
이 예제에서는 ORM에서 Lazy-loading과
Eager-loading을 설명할 때 가장 흔히 이야기하는

128
00:10:54,280 --> 00:10:59,530
그리고 서버에서 ORM을 이해하지 못하고 사용했을 때 발생하는 문제인

129
00:10:59,560 --> 00:11:04,120
N+1 Problem이 발생하는 예제 중 하나입니다

130
00:11:04,150 --> 00:11:06,960
ERD를 잠깐 설명을 드리면

131
00:11:07,850 --> 00:11:13,560
이 로직에서 사용되는 user라는 테이블이 있고
userinfo라는 테이블이 있어요

132
00:11:13,580 --> 00:11:16,660
그 두 개의 테이블이 일대일 관계인 상황이에요 현재는

133
00:11:16,690 --> 00:11:23,740
그런 상황에서 users QuerySet을 선언 해놓고

134
00:11:23,970 --> 00:11:28,800
users QuerySet에서 userinfo라는 정보를 다시 땡겨오려고 하면

135
00:11:28,820 --> 00:11:32,840
QuerySet의 기본 전략은 Lazy-loading이기 때문에 모든 User의 정보를

136
00:11:32,860 --> 00:11:35,290
SQL로 한 번에 가져왔다 치더라도

137
00:11:35,320 --> 00:11:38,360
userinfo라는 테이블에 있는 정보는

138
00:11:38,380 --> 00:11:42,810
현 이시점에서 그러니까 당장 필요하지 않기 때문에
데이터를 가져오지 않는 거죠

139
00:11:42,830 --> 00:11:48,290
쿼리상에서. 그렇기 때문에 이 for문이 돌때 마다

140
00:11:48,940 --> 00:11:54,840
userinfo라는 테이블에 있는 정보를
가져오기 위해서 쿼리가 계속 나가게 되는데

141
00:11:54,860 --> 00:11:57,710
로직이 흐르는 방식으로 설명을 해드리면

142
00:11:57,730 --> 00:12:00,590
'users의 모든 정보를 가져올 거야'라고 해놓고

143
00:12:00,620 --> 00:12:04,090
이 시점에서 'users의 모든 정보를 가져오기' 이 시점에서

144
00:12:04,120 --> 00:12:07,490
users의 모든 정보를 가지고오기 위해서 이SQL이 호출되겠죠

145
00:12:07,510 --> 00:12:13,280
그런 다음에 for문으로 넘어가서 'userinfo를 찾아줘'라고 QuerySet에서 찾는데

146
00:12:13,300 --> 00:12:19,630
QuerySet에 이 정보가 없어요. 그러면은 QuerySet은
'어 비어있네?' 하면서 SQL을 한 번 더 호출을 하게 되겠죠

147
00:12:19,660 --> 00:12:25,340
그 다음에 for문이 다시 돌면서 다시 두 번째 User의
'userinfo를 가져와'라고 했을 때

148
00:12:25,370 --> 00:12:30,930
또 userinfo가 없다는 것을 알고 '어 없네?' 하면서 SQL를 한 번 더 호출하는 방식인 거죠

149
00:12:30,950 --> 00:12:36,280
같은 방식으로 for문이 계속 돌면서 첫 번째
유저의 유저정보 두 번째 유저의 유저정보

150
00:12:36,310 --> 00:12:37,690
세 번째 유저의 유전 정보

151
00:12:37,720 --> 00:12:44,070
이런 식으로 SQL이 계속해서 호출이 되는 문제가 생기는데

152
00:12:44,680 --> 00:12:48,720
이 예제에서는 더미 데이터의 유저가 100명이라서

153
00:12:48,740 --> 00:12:53,440
userinfo를 호출하는 SQL이 100번 더 호출되게 돼요

154
00:12:53,470 --> 00:12:57,300
그러니까 총 합쳐서 user를 호출하는SQL 한 번

155
00:12:57,330 --> 00:13:02,100
그리고 그 user N에 해당하는

156
00:13:02,130 --> 00:13:04,510
userinfo SQL이 100개라서

157
00:13:04,540 --> 00:13:09,200
N+1. 그러니까 100개 + 1 해가지고 101개의 쿼리가

158
00:13:09,230 --> 00:13:11,200
발생을 하게 되는 거죠

159
00:13:11,230 --> 00:13:16,930
이것이 N+1 Problem이라는 대표적인 ORM에서

160
00:13:16,960 --> 00:13:20,050
Lazy-loading으로 인해서 발생하는 문제의 예제예요

161
00:13:20,680 --> 00:13:26,650
userinfo라는 정보가 현 이 시점에서 당장 필요하지 않아서 호출이 지연되었고

162
00:13:26,680 --> 00:13:31,830
이로 인해서 user의 수만큼 userinfo SQL이 발생되게 되는 거죠

163
00:13:31,860 --> 00:13:36,380
이런 케이스에서는 이거 Eager-loading전략을 택하도록 QuerySet에 옵션을 줘야 됩니다

164
00:13:36,400 --> 00:13:40,540
이 내용 같은 경우에 3장에서 좀 더 자세히 다루도록 할게요

165
00:13:41,110 --> 00:13:46,680
다음은 QuerySet 상세 구성요소에 대한 설명입니다

166
00:13:47,260 --> 00:13:50,530
QuerySet은 다음과 같이 구성되어 있어요

167
00:13:50,560 --> 00:13:55,770
왼쪽은 실제로 Django의 QuerySet의 구현체예요

168
00:13:56,290 --> 00:14:00,620
하지만 여기 적혀진 내용들이 좀 복잡하고 많죠

169
00:14:00,940 --> 00:14:02,870
이 내용들은 전부 다 알 필요가 없습니다

170
00:14:02,900 --> 00:14:08,000
오른쪽에 제가 다시 QuerySet을 이해하기 위해서 필요한 것들만 재 정리를 해놨는데

171
00:14:08,560 --> 00:14:10,930
이 페이지에서는 하나만 기억하면 됩니다

172
00:14:10,960 --> 00:14:19,850
QuerySet은 한 개의 Query와 0 또는 N개의 추가 QuerySet으로 구성되어 있다는 점

173
00:14:19,920 --> 00:14:25,230
이걸 기반으로 이후에 필요한 내용들을 계속 설명드릴 거예요

174
00:14:25,600 --> 00:14:29,340
여기 있는 내용 간단하게 짚고 넘어가죠

175
00:14:29,370 --> 00:14:35,560
QuerySet은 일단 하나의 Query를 최소한 가지고
있고 이것를 저는 메인 쿼리라고 부르긴 하는데

176
00:14:35,590 --> 00:14:39,390
_result_cache 라고 해가지고 이 _result_cache에

177
00:14:39,430 --> 00:14:46,720
QuerySet이 가져온 캐싱하는 데이터들을
이 변수에다가 담아서 저장을 해놔요

178
00:14:46,750 --> 00:14:52,690
그러니까 QuerySet을 호출할 때
'이 _result_cache에 원하는 데이터가 없어'라고 하면은

179
00:14:52,720 --> 00:14:54,940
그러면은 인제 SQL을 호출하는 거죠

180
00:14:54,970 --> 00:14:57,950
그리고 prefetch_related_lookups 이라는 놈이 있는데

181
00:14:57,980 --> 00:15:03,320
여기에 해당하는 놈들은 추가 QuerySet이 될
타겟들을 여기에다가 저장을 해놔요

182
00:15:03,340 --> 00:15:06,090
이건 이따가 좀 더 자세히 설명을 드리려고 하고

183
00:15:06,110 --> 00:15:12,960
iterable_class라는 놈은 이 QuerySet에 반환 타입을
어떤 방식으로 반환할 것이냐에 대한 내용이에요

184
00:15:12,990 --> 00:15:18,910
일반적으로 추가적인 옵션을 주지 않으면은 Django의 Model을 반환 하게 되고

185
00:15:18,940 --> 00:15:23,920
직접 수정 하지는 않아요
values라는 옵션을 주면 dict 형태로 반환하게 되고

186
00:15:23,950 --> 00:15:31,140
values_list를 주게 된다면 tuple list 형태로 알아서
데이터 값을 반환하게 되는 거죠

187
00:15:31,590 --> 00:15:35,460
Eager-loading 옵션인 select_related 와 prefetch_related는

188
00:15:35,480 --> 00:15:38,770
다음과 같은 방식으로 SQL을 수행합니다

189
00:15:38,800 --> 00:15:44,890
select_related는 join을 통해서
데이터를 즉시 로딩하는 방식을 가지고 있고요

190
00:15:44,920 --> 00:15:51,430
prefetch_related는 추가 쿼리를
수행해가지고 데이터를 즉시 가져오는 방식이에요

191
00:15:51,460 --> 00:15:55,140
이게 말로 설명하면 어렵고 사실 예제를 보는게 제일 간단한데

192
00:15:55,170 --> 00:16:03,130
QuerySet을 만약에 이런 식으로 선언을 했다치면은
옆에 있는 구조로 SQL이 수행되요

193
00:16:03,250 --> 00:16:08,770
정방형 참조 필드 같은 경우에는, select_related에 넣은 값 같은 경우에는

194
00:16:08,790 --> 00:16:10,640
join 으로 데이터가 호출이되고

195
00:16:10,660 --> 00:16:17,620
prefetch_related의 옵션을 주게 되면은 쿼리가 하나 더 호출되게 되면서

196
00:16:17,650 --> 00:16:20,920
데이터를 전부 다 끌어오는 방식입니다

197
00:16:20,950 --> 00:16:25,270
요 구조를 좀 더 디테일하게 살펴보도록 할게요

198
00:16:25,810 --> 00:16:33,030
앞장에 언급드렸던 것처럼 select_related는 join,
prefetch_related는 추가 쿼리를 통해 수행하게 됩니다

199
00:16:33,100 --> 00:16:35,540
모델의 구성을 간단하게 설명을 드리면은

200
00:16:35,570 --> 00:16:41,650
한 명의 유저는 여러 개의 주문을 가질 수 있고
주문과 상품은 다대다 관계인 상태예요

201
00:16:41,680 --> 00:16:47,830
이런 간단한 모델 구성해서
이런 식으로 QuerySet 작성해서 수행을 하면은

202
00:16:47,860 --> 00:16:52,710
이런 식의 SQL이 된다 라는 것을 보여드리는 건데

203
00:16:52,740 --> 00:16:57,390
요거를 좀 더 자세하게 설명을 드리면은
Order의 리스트를 가져올 건데

204
00:16:57,410 --> 00:17:02,740
그 Order의 리스트를 가지고 올 때
select_related라는 옵션을 줘가지고

205
00:17:03,130 --> 00:17:07,180
User의 정보를 조인하겠어 라는 옵션을 현재 준 상태인 거죠

206
00:17:07,200 --> 00:17:13,210
그리고 prefetch_related로 '추가 쿼리를
통해서 상품의 정보를 전부 다 끌어오겠어'라고

207
00:17:13,240 --> 00:17:18,070
이 QuerySet은 지금 즉시 로딩 전략에서 그런 옵션을 준 거예요

208
00:17:18,100 --> 00:17:22,670
그렇기 때문에 이 QuerySet에서는 이런 식으로 SQL이 발생하게 되겠죠

209
00:17:22,700 --> 00:17:29,560
select_related에 'order_owner라는 놈을 조인해' 라고
옵션을 줬기 때문에 여기에서 조인이 되는 거고

210
00:17:29,590 --> 00:17:35,170
'추가 쿼리를 통해서 상품의 정보를 전부 다 가져오겠어'
라는 prefetch_related 옵션을 줬기 때문에

211
00:17:35,200 --> 00:17:41,350
쿼리가 하나 더 발생하게 되면서 상품의 정보를
전부 다 끌어오는 방식으로 SQL이 수행되는 거죠

212
00:17:41,380 --> 00:17:45,590
여기서 참고적으로 말씀드리고 싶은 거는
역참조 모델 같은 경우에는

213
00:17:45,620 --> 00:17:48,440
select_related에 옵션을 줄 수가 없어요

214
00:17:48,460 --> 00:17:54,250
그러니까 이 예제에서 말씀을 드리면
상품의 정보를 select_related 옵션에

215
00:17:54,280 --> 00:17:57,850
줄 수가 없는 거죠
하지만 그 역은 가능합니다

216
00:17:57,880 --> 00:18:01,500
'order_owner'를 prefetch_related에 옵션으로 줄 수는 있지만

217
00:18:01,530 --> 00:18:07,660
'product_set'이라는 이 필드를
select_related에는 줄 수가 없어요

218
00:18:07,690 --> 00:18:12,710
이거는 약간 Django에서 제약이 있는 부분 중에 하나이긴 합니다

219
00:18:13,480 --> 00:18:20,860
두 번째로 설명드릴 내용은 prefeth_related는
추가 QuerySet이다 라는 내용을 좀 더 자세하게 설명을 드리려고 해요

220
00:18:20,890 --> 00:18:28,420
앞에서 제가 말씀드렸던 것처럼 QuerySet은 한개의 Query와
N개의 추가 QuerySet으로 이루어져 있다고 했었는데

221
00:18:28,450 --> 00:18:32,580
여기에서 추가 QuerySet을 어떻게 정의하느냐에 대한 내용은

222
00:18:32,600 --> 00:18:37,840
prefetch_related에 제공된 옵션에 따라서 제어가 돼요

223
00:18:37,870 --> 00:18:42,600
왼쪽 예제를 보시면은 prefetch_related는 새로운 QuerySet을 수행을 합니다

224
00:18:42,620 --> 00:18:46,660
그리고 위에 있는 예제와 아래에 있는 예제는

225
00:18:46,690 --> 00:18:50,550
동일한 SQL을, 동일한 결과를 반환하게 되는데

226
00:18:50,570 --> 00:18:56,240
이 두 개가 어떻게 다 동일한 로직인지에 대해서 설명을 드리려고 해요

227
00:18:56,260 --> 00:19:01,150
'b_model_set'이라는 놈을 prefetch_related에 옵션으로 주고

228
00:19:01,180 --> 00:19:06,990
'c_model_set'이라는 놈을 옵션으로 이렇게 주는거하고

229
00:19:07,020 --> 00:19:09,240
Prefetch라는 함수를 사용해가지고

230
00:19:09,260 --> 00:19:16,450
요렇게 QuerySet을 재선언하는 방식으로
이렇게 두 가지 방식으로 줄 수가 있는데

231
00:19:16,480 --> 00:19:20,210
이 두 가지는 완전히 동일한 결과값을 보여준다는 거죠

232
00:19:20,230 --> 00:19:24,730
그리고 여기에 선언된
BModel.objects.all() 이란 놈을

233
00:19:24,750 --> 00:19:28,360
내가 원하는 QuerySet으로 다시 재정의하는 게 가능해요

234
00:19:28,390 --> 00:19:35,260
그렇기 때문에 이 예제에서 BModels.objecst.all()이라는 QuerySet을

235
00:19:35,290 --> 00:19:41,020
.filter(is_deleted=False)라는 옵션을 준 QuerySet으로 교체를 하게 되면은

236
00:19:41,050 --> 00:19:44,280
위와 같은 쿼리가 발생하게 되는 거죠

237
00:19:44,310 --> 00:19:48,550
이런 식으로 AModel을 가져오기 위해서 전부 데이터를 가져오고

238
00:19:48,580 --> 00:19:51,730
prefetch_related에서 두 개의 옵션을 줬기 때문에

239
00:19:51,760 --> 00:19:54,040
SQL이 2개 더 발생을 하게 되는데

240
00:19:54,060 --> 00:19:57,400
그때 CModel 같은 경우는 경우에는 별다른 옵션을 주지 않았죠

241
00:19:57,430 --> 00:20:01,460
그렇기 때문에 일반적인 노말한 SQL가 발생을 하게 되고

242
00:20:01,490 --> 00:20:05,860
BModel 같은 경우 QuerySet을 이런 식으로 옵션을 더 줬기 때문에

243
00:20:05,890 --> 00:20:12,030
'is_deleted is False'라는 where절에 조건이
들어간 쿼리가 하나 더 발생하게 되는 겁니다

244
00:20:12,400 --> 00:20:18,160
이 예제를 통해서 알려드리고 싶은 거는
prefetch_related는 새로운 QuerySet이고

245
00:20:18,180 --> 00:20:21,290
그 prefetch_related 안에 선언한 개수만큼

246
00:20:21,310 --> 00:20:25,860
쿼리가 추가적으로 더 호출이 된다
라는 것을 알려드리고 싶었어요

247
00:20:26,710 --> 00:20:32,300
앞에서 계속 얘기했었던 내용들을
이제 연습 문제로 다시 만들어봤어요

248
00:20:32,330 --> 00:20:38,300
이거는 이렇게 같이 보면서
천천히 예제들을 설명해 나가면 될 것 같아요

249
00:20:38,860 --> 00:20:45,000
이 QuerySet 같은 경우에는 어떤 SQL을 낼지에 한번 간단하게 맞춰볼게요

250
00:20:45,640 --> 00:20:53,920
Company에다가 filter에다가 옵션을 주고 prefetch_related에다가
'product_set'이라는 놈을 즉시 로딩하는 옵션을 줬어요

251
00:20:53,950 --> 00:21:00,340
이 QuerySet에서는 어떤 SQL이 나갈까라고
한 3초 정도 생각을 해보고 다시 넘기면

252
00:21:00,360 --> 00:21:01,780
이런 식의 쿼리가 나가겠죠

253
00:21:01,810 --> 00:21:07,930
왜냐하면 company라는 기본적인 한 개의 쿼리는 무조건 나가게 되고

254
00:21:07,960 --> 00:21:15,170
그리고 prefetch_related 옵션을 줬기 때문에
한 개의 쿼리가 더 나가게 되는 거죠

255
00:21:15,200 --> 00:21:20,080
그러면 이번 로직에서는 select_related에 옵션을 두 개를 줬어요

256
00:21:20,110 --> 00:21:25,360
그렇기 때문에 아까 말씀드렸던 것처럼 select_related는 join을 유도하죠

257
00:21:25,390 --> 00:21:31,960
그렇기 때문에 하나, 둘
두 개의 모델이 조인된 이 SQL이 발생을 하게 됩니다

258
00:21:32,750 --> 00:21:35,470
그러면 세 번째 예제를 다시 한 번 더 볼까요?

259
00:21:35,500 --> 00:21:37,360
이 로직에서는 어떻게 나갈까요?

260
00:21:37,390 --> 00:21:39,880
일단 기본적으로 하나의 쿼리가 발생을 하겠죠

261
00:21:39,910 --> 00:21:45,310
OrderedProduct라는 Model을 당겨오는 쿼리가
발생을 할 것이고 prefetch_related라는 옵션을 줬어요

262
00:21:45,340 --> 00:21:48,460
그렇기 때문에 1개 추가 쿼리가 더 발생을 할 거예요

263
00:21:48,490 --> 00:21:53,170
그런데 여기서 Prefetch라는 함수를 써가지고 QuerySet을 재선언을 해줬어요

264
00:21:53,200 --> 00:21:59,620
그 재선언을 해준 QuerySet은 select_related라는 옵션을 가지고 있어요

265
00:21:59,650 --> 00:22:04,580
그렇기 때문에 OrderedProduct를 가져오는 쿼리가 하나가 발생을 하고

266
00:22:04,610 --> 00:22:08,020
새로운 추가 QuerySet이 발생을 하는데 그 QuerySet에

267
00:22:08,050 --> 00:22:12,470
join하는 옵션인 select_related가 붙어 있는 거죠

268
00:22:12,490 --> 00:22:16,540
그렇기 때문에 추가 쿼리는 하나 더 발생을 하지만

269
00:22:16,570 --> 00:22:20,680
Mileage라는 Model을 join해서 하나 더 발생을 하게 되는 거죠

270
00:22:20,710 --> 00:22:25,600
이런 식으로 SQL들이 이렇게 동작을 하는 걸 보실 수가 있어요

271
00:22:25,630 --> 00:22:31,450
그리고 네 번째 예제예요
이건 좀 되게 많이 복잡하게 일부러 더 꼬왔는데

272
00:22:31,480 --> 00:22:37,390
prefetch_related 옵션에다가 이번에는 모델의 모델,

273
00:22:37,420 --> 00:22:43,910
related_product에 걸린 놈을 한 번 더 join하는 방식으로 주게 되었는데

274
00:22:45,520 --> 00:22:49,910
이 케이스에서는 어떻게 발생할지 한번 맞춰보시면은
어렵죠

275
00:22:49,940 --> 00:22:55,140
이런 케이스에서는 두 개의 추가 쿼리가 더 발생을 하게 됩니다

276
00:22:55,170 --> 00:22:58,530
왜냐하면 related_product도 모델이고

277
00:22:58,560 --> 00:23:04,030
그 related_product에 참조되어 있는
product_owned_company도 모델이기 때문에

278
00:23:04,060 --> 00:23:07,080
추가 쿼리가 두 개가 발생하게 되는 거죠

279
00:23:07,100 --> 00:23:11,910
그리고 Company에 대한, 타깃으로 하는 QuerySet을 제가 재선언을 해가지고

280
00:23:11,940 --> 00:23:19,500
name__contains='company_name' 라는 WHERE 절, filter를 걸어놓았기
때문에 여기에 LIKE문이 이런 식으로 붙게 되겠죠

281
00:23:20,140 --> 00:23:24,890
만약에 여기 있는 쿼리를 뭔가 제어를 하고 싶다 하면

282
00:23:24,920 --> 00:23:29,330
이런 식으로 QuerySet을 따로 쪼개가지고
다시 재선언을 하면 됩니다

283
00:23:29,360 --> 00:23:35,410
그렇게 되면. 여기에는 제가 좀 약간 의미없는
필터를 걸긴 했는데 id__isnull=False 라는

284
00:23:35,440 --> 00:23:40,330
이 조건절이 여기에 한 줄 더 붙게 되겠죠

285
00:23:40,360 --> 00:23:42,790
이번 장에서는 QuerySet을 테스트하는

286
00:23:42,820 --> 00:23:50,000
테스트 케이스를 짤 때 사용하면 좋은 유틸리티
펑션이 있어가지고 좀 소개를 드릴까 해요

287
00:23:50,030 --> 00:23:55,570
이거는 뭐 Django 최신 버전에서 나온 건 아니고
실제로 Django에 존재하는 로직이긴 한데

288
00:23:55,600 --> 00:24:01,570
Django 공식 문서에서도 이 내용이 따로
소개되고 있지는 않더라고요

289
00:24:01,600 --> 00:24:03,940
근데 저는 꽤 유용하게 써가지고 가져왔어요

290
00:24:03,970 --> 00:24:12,010
assertNumQueries라는 로직이 Django 공식 문서에서는
'QuerySet을 테스트 할 때 쓰세요'라고 소개를 해주긴 하는데

291
00:24:12,040 --> 00:24:14,970
저는 개인적으로 assertNumQueries를 별로 좋아하지 않습니다

292
00:24:15,010 --> 00:24:22,590
왜냐하면 제가 원하는 것은 N+1 문제 같이
크리티컬한 성능 이슈만 커버 하기를 원하는데

293
00:24:22,620 --> 00:24:25,510
assertNumQueries로 테스트 케이스를 작성해 놓으면

294
00:24:25,540 --> 00:24:30,000
API가 매번 수정할 때마다 SQL 갯수가 그때 그때마다 달라져가지고

295
00:24:30,030 --> 00:24:33,210
매번 그 테스트 케이스가 깨져서 그 체크를 해줘야 돼요

296
00:24:33,230 --> 00:24:37,210
그것 때문에 되게 피곤하더라구요
매번 체크해줘야 되기 때문에

297
00:24:37,240 --> 00:24:41,260
결국 더 꼼꼼하게 볼 수 있다는 장점이 있을 수도 있지만

298
00:24:41,290 --> 00:24:47,980
오히려 거꾸로 말하자면 매번 체크해줘야 되기 때문에
귀찮아가지고 대충 숫자만 변경하고 넘길 때도 되게 많아요

299
00:24:48,580 --> 00:24:52,100
대체로 회사일이라는 게 바쁘고 정신이 없으면은

300
00:24:52,120 --> 00:24:57,370
후자의 케이스를 더 많이 겪게 되는 것 같더라고요
저 개인적인 생각으로는

301
00:24:57,400 --> 00:25:05,960
그래가지고 옆에 처럼 이런 식으로 테스트 케이스를
짜는 거를 그냥 한번 추천 또는 제 개인적인 의견이에요

302
00:25:06,070 --> 00:25:20,590
그래서 이런 식으로 '이 API에서 발생하는 쿼리가 몇 개야'
라는 것을 캡쳐할 수 있는 테스트 유틸리티 거든요

303
00:25:20,620 --> 00:25:25,370
그래가지고 이런 식으로 선언해놓고 사용하는
것도 꽤 괜찮을 것 같다 싶어서

304
00:25:25,400 --> 00:25:30,310
제가 개인적으로 소개를 드리고 싶어서 가져온 예제입니다

305
00:25:31,300 --> 00:25:37,250
4장 부터는 실수하기 쉬운 QuerySet들의 특성들에 대해서 좀 알아보고자 해요

306
00:25:38,110 --> 00:25:41,440
일반적으로 일단 첫 번째로 설명드리고 싶은 거는

307
00:25:41,470 --> 00:25:47,310
prefetch_related와 filter는
완전 별개의 것이다 라는 걸 설명하고 싶어요

308
00:25:48,850 --> 00:25:55,960
Django QuerySet에 대해서 그렇게 이해가 깊지 않으신
분들이 주로 이렇게 이런 실수 자주 하실 수도 있는데

309
00:25:55,990 --> 00:25:58,990
prefetch_related로,
예를 들어서 이 예제를 보시면은

310
00:25:59,010 --> 00:26:03,760
prefetch_related로 'product_set'이라는
놈을 즉시 로딩을 하고

311
00:26:03,790 --> 00:26:08,820
그리고 그 'product_set에 이름이 비어
있지 않은 놈만 검색하고 싶어'라고 했을 때

312
00:26:08,840 --> 00:26:11,850
이런 식으로 옵션을 줄 때가 가끔씩 있는데

313
00:26:11,870 --> 00:26:17,680
이런 옵션을 주게 되면 이거는
잘못된 QuerySet의 작성 중 하나예요

314
00:26:17,710 --> 00:26:20,890
prefetch_related는 추가 쿼리에서 발생하는 로직이고

315
00:26:20,920 --> 00:26:26,770
filter에 주어진 옵션들 같은 경우에는
새로운 QuerySet이 아니라

316
00:26:26,800 --> 00:26:33,730
제가 아까 말씀드렸던 QuerySet은 한개 Query와 N개의
추가 QuerySet으로 구성되어 있다 말씀을 드렸잖아요

317
00:26:33,760 --> 00:26:39,160
거기서 filter는 한개 쿼리에 해당하는 내용들을 제어하는 놈이고

318
00:26:39,190 --> 00:26:43,520
prefetch_related는 추가 QuerySet에 있는 내용들을 제어하는 내용인데

319
00:26:43,550 --> 00:26:48,730
여기서 보시면 이런 식으로 SQL이 잘못되게 발생되요

320
00:26:48,760 --> 00:26:53,590
filter에서 product_name이 비어 있지 않은 놈을 검색하고 싶어

321
00:26:53,920 --> 00:26:58,180
라고했기 때문에 이 조건절을 검색하기 위해서

322
00:26:58,210 --> 00:27:02,690
이 조건절 같은 경우에는 이렇게 WHERE절로 들어가기
때문에 이거를 더 검색하기 위해서

323
00:27:02,720 --> 00:27:06,040
필연적으로 product를 JOIN할 수밖에 없는 거죠

324
00:27:06,070 --> 00:27:10,420
그렇기 때문에 여기서 JOIN을 해가지고
데이터를 불필요하게 한 번 더 검색을 하고

325
00:27:10,450 --> 00:27:15,890
prefetch_related라는 옵션을 줬기 때문에
product가 한 번 더 쿼리가 나가게 되는 거죠

326
00:27:16,720 --> 00:27:20,710
결과적으로 보면은 JOIN을 해가지고 데이터를 한 번더 끌어왔고

327
00:27:20,740 --> 00:27:27,820
그리고 추가 쿼리를 통해서 한 번 더
데이터를 끌어오는, 비효율적인 쿼리가 나가게 되는

328
00:27:27,850 --> 00:27:30,010
케이스 예제 중에 하나예요

329
00:27:30,520 --> 00:27:34,820
이런 케이스에서는 해결 방식이 두 가지가 있어요

330
00:27:34,840 --> 00:27:38,910
prefetch_related 옵션을 제거하는 방법이 하나가 있고

331
00:27:38,940 --> 00:27:41,630
filter에 넣여줬던 product 관련 조건절을

332
00:27:41,660 --> 00:27:45,040
Prefetch로 옮겨주는 방식이 하나가 있어요

333
00:27:45,060 --> 00:27:48,090
prefetch_related 옵션을 제거하게 되면

334
00:27:48,120 --> 00:27:53,260
JOIN으로 그냥 풀려가지고 쿼리 한줄로
데이터가 전부 다 끌어와질 것이고

335
00:27:53,290 --> 00:27:58,510
이 Prefetch라는 함수를 써가지고
사용하는 로직을 사용하게 되면

336
00:27:58,540 --> 00:28:00,610
Company라는 모델을 가져오는 쿼리 하나

337
00:28:00,640 --> 00:28:04,390
그리고 Product를 가져오는 쿼리 하나 해가지고

338
00:28:04,410 --> 00:28:08,570
두 개의 쿼리로 QuerySet이 수행이 되겠죠

339
00:28:08,600 --> 00:28:10,860
이 두 개 중에 하나를 쓰시면서 되고

340
00:28:10,890 --> 00:28:17,180
이런 방식으로 쓰게 되면 이거는 좀 비효율적인
쿼리가 나간다는 거를 좀 알려드리고 싶었습니다

341
00:28:19,660 --> 00:28:24,020
그리고 위에서 발생하는 문제들이 있어가지고

342
00:28:24,040 --> 00:28:29,380
제가 이것도 그냥 간단하게 설명하고자 넣었는데
이거는 되게 개인적인 내용이긴 해요

343
00:28:29,410 --> 00:28:32,440
개인적으로 추천하는 QuerySet의 작성 순서예요

344
00:28:32,470 --> 00:28:40,140
Model을 놓고 annotate, select_related, filter, 그리고 prefetch_related

345
00:28:40,170 --> 00:28:44,170
이 순서대로, 뭔가 이렇게 QuerySet을 작성할 때 나열하는 순서가

346
00:28:44,200 --> 00:28:47,260
이런 거 하면 좋겠다. 라고 개인적으로 생각을 해요

347
00:28:47,290 --> 00:28:51,300
왜냐하면 지금 제가 이렇게 작성한 이 순서가

348
00:28:51,330 --> 00:28:55,690
실제로 발생하는 SQL의 순서하고 가장 유사하기 때문이에요

349
00:28:55,720 --> 00:29:01,810
다른 거는 모르더라도 일단 prefetch_related가 filter 앞에 있는 거는 웬만하면은

350
00:29:01,840 --> 00:29:05,260
하지 않는 게 좋지 않을까라고 생각을 해요
왜냐하면

351
00:29:05,280 --> 00:29:09,440
이런 로직에서 보시면은 prefetch_related가
붙어 있고 filter가 붙어 있으면

352
00:29:09,460 --> 00:29:16,840
마치 하나의 쿼리에서 이게 다 동작하는 것처럼
착각하기 쉽기 때문에 그렇습니다

353
00:29:16,870 --> 00:29:18,940
그렇기 때문에 prefetch_related 같은
경우에

354
00:29:18,960 --> 00:29:24,490
filter 아래에 두면은 좀 더 이해하는데
도움이 되지 않을까라고 생각을 합니다

355
00:29:24,520 --> 00:29:31,350
이거는 되게 개인적인 의견이라서 사실 그렇게..
그냥 개인적인 의견일뿐입니다

356
00:29:32,170 --> 00:29:34,690
그러면 다음 장 넘어가 보도록 하겠습니다

357
00:29:36,970 --> 00:29:41,380
이번 문제 같은 경우에는
QuerySet 캐시를 재활용하지 못할 때가 있어요

358
00:29:41,410 --> 00:29:47,440
QuerySet을 호출할 때. 그런 케이스에서 어떻게
사용해야 되는지를 먼저 얘기를 해드리려고 해요

359
00:29:47,460 --> 00:29:50,950
이 예제를 보시면 Company의 정보를 가져오는데

360
00:29:50,980 --> 00:29:56,900
'이 회사가 가진 상품들의 정보를 전부 다 즉시 로딩해'라는 예제예요

361
00:29:57,070 --> 00:30:02,800
이런 예제에서 데이터를 전부 끌어 왔을 때

362
00:30:02,830 --> 00:30:09,020
company_list의 0번째를 가져오더라도
여기서도 쿼리가 하나 더 추가적으로 나가지 않겠죠

363
00:30:09,040 --> 00:30:14,950
왜냐면 이 앞에서 이미 모든 Company의 정보가 캐싱되어 있기 때문에

364
00:30:14,980 --> 00:30:18,820
그리고 이 로직에서도 추가 쿼리가 나가지 않습니다

365
00:30:18,850 --> 00:30:22,250
왜냐하면 prefetch_related를 통해서 product_set이라는 놈을

366
00:30:22,280 --> 00:30:26,190
이미 Eager-loading으로 즉시 로딩을 해서 한 번에 다 끌어왔기 때문이죠

367
00:30:26,210 --> 00:30:29,180
그런데 약간 좀 이렇게 의아한 부분이긴 한데

368
00:30:29,210 --> 00:30:32,250
이 로직을 쓸 때는 쿼리가 발생을 해요

369
00:30:32,560 --> 00:30:38,230
그러니까 내가 가져온 product_set 중에서 상품의 이름이 '불닭볶음면'인

370
00:30:38,260 --> 00:30:43,830
상품을 전부 가지고와 라는 QuerySet을 작성하게 되면은

371
00:30:43,860 --> 00:30:52,950
이 경우에는 QuerySet의 캐시를 재사용하지 않고
SQL을 무조건 호출하게 됩니다

372
00:30:53,540 --> 00:30:58,540
이건 약간 버그는 아닌 거 같고 Django 쪽에서
이렇게 의도한 동작이긴 한데

373
00:30:58,570 --> 00:31:02,570
일반적으로 뭔가 가끔씩 착각하기 쉬운
부분 중에 하나인 거죠

374
00:31:02,600 --> 00:31:06,790
그렇기 때문에 SQL을 발생 시키지 않으려면

375
00:31:06,820 --> 00:31:09,860
company.product_set.all()을 무조건 호출해가지고

376
00:31:09,880 --> 00:31:17,260
그 안에 있는 로직에서 파이썬 list comprehension으로
이렇게 찾아주는 방식으로 써야 돼요

377
00:31:17,290 --> 00:31:21,570
그러니까 filter(name='불닭볶음면') 이런 식으로 주는 게 아니라

378
00:31:22,270 --> 00:31:29,980
파이썬의 list comprehension을 써가지고
if product.name == '불닭볶음면' 이렇게 쓰면

379
00:31:30,010 --> 00:31:31,940
추가 쿼리가 호출되지 않습니다

380
00:31:31,970 --> 00:31:38,260
이거는 되게 뭔가 착각하기 쉽고 실수하기 쉬운
부분들이라서 한 번 담아봤습니다

381
00:31:39,760 --> 00:31:44,970
네 번째로 설명드릴 내용은
RawQuerySet은 Native SQL이 아니다입니다

382
00:31:45,520 --> 00:31:50,510
가끔씩 원하는 SQL을 수행하기 위해서 QuerySet을 완전하게 포기할 때가 있어요

383
00:31:50,530 --> 00:31:56,050
그러니까 Django connection에서 cursor.execute() 식으로 로직을 쓸 때가 있는데

384
00:31:56,080 --> 00:32:00,310
굳이 그러지 않고 RawQuerySet이라는 놈이 있어서

385
00:32:00,330 --> 00:32:07,060
이거 사용해도 괜찮다 라는 거를 좀 설명을
드리고 싶어서 이 내용을 가지고 왔어요

386
00:32:07,090 --> 00:32:11,080
RawQuerySet과 QuerySet은 크게 다르지 않아요

387
00:32:11,110 --> 00:32:14,950
그냥 메인 쿼리를 Native SQL로 구현 한다는 차이만 있고

388
00:32:14,970 --> 00:32:20,020
나머지는 대부분의 것들이 되게 동일하고

389
00:32:20,050 --> 00:32:25,150
RawQuerySet 또한 아직 ORM의 제어권 안쪽에 있는 구현체입니다

390
00:32:25,180 --> 00:32:28,540
여기서 RawQuerySet 같은 경우에는 어떻게 쓰는 거냐면

391
00:32:28,570 --> 00:32:33,700
다른 일반적인 로직들은
Model.objects.filter 해가지고 이런 식으로 쓰는데

392
00:32:33,730 --> 00:32:39,660
그러지 않고 Model.objects 한 다음에
.raw() 해가지고 원하는 쿼리를 작성하시면 됩니다

393
00:32:41,350 --> 00:32:46,600
이런 RawQuerySet 같은 경우에는 일단

394
00:32:46,630 --> 00:32:49,110
Native SQL이 아니라고 얘기한 것 중에 하나가

395
00:32:49,130 --> 00:32:54,450
가장 QuerySet과 RawQuerySet의
가장 큰 차이점을 얘기드리면은

396
00:32:54,500 --> 00:32:55,900
딱 하나밖에 없어요

397
00:32:55,930 --> 00:33:02,310
QuerySet 같은 경우에는 메인 쿼리를 작성하는데 있어서
Django의 Query라는 구현체를 쓰고

398
00:33:02,350 --> 00:33:07,980
RawQuerySet 같은 경우에는 Django에서
제공하는 Query 구현체로 쓴 게 아니라

399
00:33:08,000 --> 00:33:11,150
사용자가 직접 제공해준 Raw SQL을 가져다가

400
00:33:11,180 --> 00:33:13,520
그대로 사용하는 방식을 쓰고 있는 거죠

401
00:33:13,550 --> 00:33:18,820
그 이외에는 동일하다는 것을 제가 얘기 드리는
예제 중에 하나가 이거입니다

402
00:33:19,660 --> 00:33:26,050
왼쪽 예제를 보시면
위에 있는 로직하고 아래에 있는 로직이

403
00:33:26,070 --> 00:33:30,860
완전 동일하다는 것을, 동일한 결과를 가져온다는 거를 제가 보여드리고 싶어요

404
00:33:30,880 --> 00:33:35,980
그러니까 위에 있는 예제 같은 경우는 RawQuerySet 작성을 했고

405
00:33:36,010 --> 00:33:39,550
아래에 있는 것 같은 경우는 순수 QuerySet으로 작성하는 로직이에요

406
00:33:39,580 --> 00:33:45,180
위에 있는 로직을 보시면 Order를 조회 하는데 'FROM ~order'를 하고

407
00:33:45,240 --> 00:33:48,080
그리고 ~user를 JOIN한 로직이에요

408
00:33:48,110 --> 00:33:51,430
그러니까 이런 식으로 순수 SQL을 작성한 거하고

409
00:33:51,460 --> 00:33:56,350
아래쪽에 보시면은 select_related 해가지고
'Owner를 JOIN 할 거야'라는 옵션을 주고

410
00:33:56,380 --> 00:34:00,520
filter에다가 username 뭐야라고 이렇게 작성을 해놨는데요

411
00:34:00,550 --> 00:34:03,890
이 내용이 위에 있는 내용과 완전히 동일하다는 거죠

412
00:34:04,810 --> 00:34:08,240
아래에 있는 select_related, '난 JOIN을 할 거야' 라는 옵션을

413
00:34:08,270 --> 00:34:13,870
여기서 내가 순수 네이티브 SQL로 '난 JOIN을 할 거야' 라고
이렇게 SQL로 작성을 해줬고

414
00:34:13,900 --> 00:34:17,920
WHERE절에 username이 뭐뭐야 라는 내용을

415
00:34:17,940 --> 00:34:22,060
여기에다가 filter에다가 username은 뭐뭐야 라고 작성을 해준 거죠

416
00:34:22,090 --> 00:34:25,390
그렇게 작성을 해주는 것 까지는 동일하고

417
00:34:25,420 --> 00:34:31,220
여기서 이제 RawQuerySet이 Native SQL이
아니라는 것이 여기서 이제 나오는 거죠

418
00:34:31,240 --> 00:34:33,820
prefetch_related라는 옵션을 여전히 쓸 수가 있어요

419
00:34:33,850 --> 00:34:38,680
그러니까 이런 식으로 내가 Raw native SQL을 따로 작성을 하더라도

420
00:34:38,700 --> 00:34:43,020
좀 더 많은 정보를 추가 QuerySet으로 뭔가를 더 가져오기 위해서는

421
00:34:43,050 --> 00:34:47,180
여전히 prefetch_related라는 옵션이 사용이 가능하다는 점이죠

422
00:34:47,980 --> 00:34:51,990
그게 RawQuerySet에서 뭔가 이렇게 이것만 딱 바꿔주고

423
00:34:52,020 --> 00:34:54,630
나머지 prefetch_related 옵션을 쓰면서

424
00:34:54,660 --> 00:35:00,070
자유롭게, 아직 QuerySet의 제어권 안쪽에 있기 때문에 사용이 가능하다는 점입니다

425
00:35:00,590 --> 00:35:07,270
같은 방식에서 말씀을 드리면 RawQuerySet을 쓰게 되면은
여기에 보이시는 이 로직들은 사용할 수가 없게 돼요

426
00:35:07,300 --> 00:35:14,290
왜냐면 여기에 있는 메소드들은 메인 쿼리를 제어하기
위해서 사용되는 메소드들이기 때문이에요

427
00:35:14,310 --> 00:35:18,690
select_related, FilteredRelation, annotate, order_by

428
00:35:18,720 --> 00:35:21,490
extra 그리고 limit 옵션 같은 경우

429
00:35:21,520 --> 00:35:23,970
이런 것들은 이제 네이티브 SQL에다

430
00:35:23,990 --> 00:35:28,270
저희가 이 안에서 직접 SQL로 작성을 해줘야겠죠

431
00:35:29,020 --> 00:35:34,690
다섯 번째로 얘기드리고 싶은 거는 서브쿼리의 발생 조건입니다

432
00:35:34,720 --> 00:35:40,340
일반적으로 서브쿼리는 프로덕트 환경에서

433
00:35:40,370 --> 00:35:44,330
슬로우 쿼리를 되게 많이 야기하고는 하는데

434
00:35:44,400 --> 00:35:49,100
그렇기 때문에 서브쿼리를 뭔가 의도하고 쓰는 케이스가 생각보다 많이 잘 없어요

435
00:35:49,120 --> 00:35:51,360
그렇기 때문에 작성을 하실 때

436
00:35:51,380 --> 00:35:56,140
'서브쿼리가 안 나가게 해야지'라고
이렇게 작성하는 케이스들이 많은데

437
00:35:56,170 --> 00:36:00,350
가끔씩 QuerySet이 개발자의 의도와 다르게

438
00:36:00,370 --> 00:36:05,170
아니면 예상하지 못하게 서브쿼리를 수행할 때가 있는데

439
00:36:05,190 --> 00:36:09,840
그런 어떤 경우에 서브쿼리가 발생하는지에 대해서 얘기를 드리고자 해요

440
00:36:09,860 --> 00:36:14,380
Django ORM에서 서브쿼리를 강제로 제공할 수 있는 옵션이 있긴 한데

441
00:36:14,400 --> 00:36:20,160
그 옵션을 주지 않았을 때도 가끔씩 발생할 수 있다는
경우을 보여드리고자 나왔습니다

442
00:36:20,190 --> 00:36:23,050
첫 번째로 서브쿼리가 발생하는 조건은

443
00:36:23,070 --> 00:36:27,570
QuerySet안에 QuerySet이 있으면 서브쿼리가 발생을 합니다

444
00:36:28,840 --> 00:36:32,880
왼쪽에 예제를 보시면은
companies_queryset 이라는 놈을 작성을 해놓고

445
00:36:32,900 --> 00:36:38,140
product_queryset 안에 조건절로다가
companies_queryset을 집어넣은 케이스인 거죠

446
00:36:38,170 --> 00:36:42,350
이런 케이스에서는 이 QuerySet이 아직 수행되지 않았기 때문에

447
00:36:42,380 --> 00:36:47,200
product_queryset 안에 들어가는 시점에도 아직 QuerySet인 거죠

448
00:36:47,220 --> 00:36:52,320
그래가지고 product_queryset과 company_queryset이 합쳐서 수행이 되는 케이스예요

449
00:36:52,350 --> 00:36:56,270
그렇기 때문에 결과적으로 이러한 쿼리셋이 발생하게 되는 거죠

450
00:36:56,330 --> 00:37:03,830
company_queryset에 주어진 이 로직이 서브쿼리로
이런 식으로 수행이 돼버리는 케이스예요

451
00:37:03,880 --> 00:37:07,890
그렇기 때문에 이런 케이스들을 막기 위해서는

452
00:37:07,920 --> 00:37:12,240
QuerySet을 그 즉시 수행해버리는 이런 식으로 로직을 작성해줘돼요

453
00:37:12,270 --> 00:37:16,940
그러니까 여기서 변수명이 company_queryset 이긴 하지만

454
00:37:16,970 --> 00:37:21,850
list라는 옵션으로 이 QuerySet을 바로 즉발 수행을 해버렸기 때문에

455
00:37:21,880 --> 00:37:27,670
이 company_queryset에 리턴되는 이 값과 같은 경우
실제로는 QuerySet이 아니게 되어버리는 거죠

456
00:37:27,700 --> 00:37:33,190
그렇기 때문에 여기서 이런 식으로 수행했을 때
오른쪽 결과값을 보시면은

457
00:37:33,220 --> 00:37:37,030
의도하신 대로 서브쿼리셋이 나가지 않고

458
00:37:37,060 --> 00:37:40,870
쿼리가 두 개로 쪼개져가지고 나가는 걸 보실 수 있습니다

459
00:37:40,900 --> 00:37:45,780
이런 식으로 서브쿼리가 발생하지 않게 작성을 해주시면 좋을 것 같고요

460
00:37:45,800 --> 00:37:49,390
그리고 이거 같은 경우 약간 버그성 동작이긴 한데

461
00:37:49,410 --> 00:37:53,920
exclude() 조건절을 줄 때 조심하셔야 되는 부분이 있어요

462
00:37:55,090 --> 00:38:00,090
exclude 같은 경우 원래 이렇게 사람들이나 우리들이 사용할 때

463
00:38:00,120 --> 00:38:03,070
filter 옵션 같은 경우에는

464
00:38:03,100 --> 00:38:08,590
그 바른 옵션 exclude를 쓰면은 not 옵션
이런 식으로 해가지고 사용할 때가 많은데

465
00:38:08,620 --> 00:38:12,670
가끔씩 exclude 옵션에서 서브쿼리가 발생할 때가 있습니다

466
00:38:12,700 --> 00:38:15,800
이 케이스 같은 경우에는 정상적으로 잘 동작을 해요

467
00:38:15,820 --> 00:38:20,500
filter 안에다가 product_set의 name이 asdfsdf인 놈을

468
00:38:20,530 --> 00:38:24,190
찾을 거야 라고 이렇게 QuerySet을 주었을 때

469
00:38:24,220 --> 00:38:29,950
우리가 원하는 대로 이 값 같은 경우에 JOIN되고 JOIN돼가지고
순수하게 발생을 하죠

470
00:38:29,980 --> 00:38:36,340
그런데 이 로직을 그냥 exclude에다가 그대로 넣었어요

471
00:38:36,370 --> 00:38:41,170
위에서 보시면 알겠지만 여기 filter에다 주어졌던 이 옵션을

472
00:38:41,200 --> 00:38:45,280
그냥 단순하게 exclude로다가 옮겨가지고 그대로 주기만 했는데

473
00:38:45,300 --> 00:38:47,750
이런 케이스에서는 서브쿼리가 발생을 합니다

474
00:38:48,160 --> 00:38:51,040
이거는 약간 좀 버그성 동작으로 저는 생각을 하고 있는데

475
00:38:51,060 --> 00:38:56,060
이게 Django 초반 버전에서도 발생을 하고

476
00:38:56,090 --> 00:39:03,040
현재 3.1에서도 발생을 하는
문제인지 아니면 의도된 건지는 모르겠는데

477
00:39:03,070 --> 00:39:05,590
아무튼 이런 식으로 서브쿼리가 발생을 해요

478
00:39:05,620 --> 00:39:10,400
그래가지고 장기간에 걸쳐서 이렇게 동작을 하는
거면은 '버그가 아닌가?' 싶긴 한데

479
00:39:10,430 --> 00:39:12,830
사실 되게 당황스럽긴 하거든요

480
00:39:12,860 --> 00:39:15,990
위에 보셨던 것처럼 filter에서 넣었을 땐 JOIN이되는데

481
00:39:16,010 --> 00:39:18,770
exclude에 넣었을 때 서브쿼리가 발생을 한다

482
00:39:19,480 --> 00:39:21,830
되게 좀 이렇게 당황스러운 동작이기는 해요

483
00:39:21,850 --> 00:39:27,330
그렇기 때문에 이 exclude에다가 역방향 참조 모델을

484
00:39:27,360 --> 00:39:31,100
이런 식으로 조건절 옵션을 줬을 때
서브쿼리가 발생하기도 하고

485
00:39:31,120 --> 00:39:36,580
filter절에다가 ~Q 옵션을 줘가지고 했을 때도 여전히 서브쿼리가 발생을 해요

486
00:39:36,610 --> 00:39:42,710
그리고 마찬가지로 select_related 옵션을 줘서
강제로 '조인을 유도해'라고

487
00:39:42,730 --> 00:39:46,270
옵션을 주더라도 무조건 발생을 합니다

488
00:39:46,300 --> 00:39:52,370
그래가지고 이 옵션은 어떻게 풀지라고 생각을 해서 계속 로직을 뜯어보고 했는데

489
00:39:52,440 --> 00:39:55,750
로직을 JOIN으로 풀리게 유도하는 게 안되더라고요

490
00:39:55,770 --> 00:39:59,520
제가 좀 더 정확하게 분석을 못해봐서 그런 건지 모르겠는데

491
00:39:59,550 --> 00:40:06,490
제가 계속 제약 조건을 주고 브레이크를 걸면서 내부
QuerySet이 어떻게 동작하는지 계속 체크를 해봤는데도

492
00:40:06,550 --> 00:40:07,580
풀리지가 않더라고요

493
00:40:07,600 --> 00:40:12,620
그래가지고 이런 케이스에서는 차선책으로 prefetch_related 옵션을 줘가지고

494
00:40:12,640 --> 00:40:19,060
이 product_set을 prefetch_related에
따로 이렇게 제약을 주는 방법으로

495
00:40:19,090 --> 00:40:21,590
저는 결국 제약을 해결했어요

496
00:40:21,620 --> 00:40:26,200
실제로 exclude 절에서 이런 식으로 역방향 참조 모델을 줬을 때

497
00:40:26,230 --> 00:40:31,960
서브쿼리가 발생하는 문제가 저희 시스템에서 제가 이렇게 QuerySet을 작성할 때

498
00:40:31,990 --> 00:40:35,590
제안을 '이런 식으로 해도 돼'라고 했다가

499
00:40:35,620 --> 00:40:42,340
슬로우쿼리가, 이런 식으로서 서브쿼리가 발생을 해서
슬로우쿼리로 인해서 각 배포 직후 5분에서 10분 정도

500
00:40:42,370 --> 00:40:44,290
장애가 난 경험이 있습니다

501
00:40:44,320 --> 00:40:50,980
그렇기 때문에 다른 분들은 이 문제를 좀 알아두시면
좋을 것 같아서 제가 공유하고자 가져왔습니다

502
00:40:52,390 --> 00:40:57,840
이것도 재미있는 게 정방형 참조 모델에서는 완전히 정상적인 동작을 해요

503
00:40:57,860 --> 00:41:02,080
exclude 절에다가 정방형 참조 모델에 대한 옵션을 줬을 때는

504
00:41:02,110 --> 00:41:03,670
여전히 JOIN이 되는데

505
00:41:03,700 --> 00:41:10,590
이게 역방향 참조 모델에 대해서 exclude절에다가
옵션을 줬을 때만 발생하는 버그성 동작이긴 하거든요

506
00:41:10,690 --> 00:41:13,660
그렇기 때문에 참고해 주시면 좋을 것 같아요

507
00:41:14,490 --> 00:41:19,750
요거는 그렇게 설명할 건 없긴 하지만
좀 도움이 될 것 같아서 가져왔어요

508
00:41:19,780 --> 00:41:23,480
QuerySet의 반환 타입은 되게 다양한 종류들이 많아요

509
00:41:23,510 --> 00:41:29,870
values()와 values_list()를 썼을 때 이런 식으로
데이터들이 다양하게 반환될 수 있고

510
00:41:29,910 --> 00:41:34,180
values_list() 같은 경우에는 flat=True라는 옵션이 있고 named=True라는 옵션이 있어요

511
00:41:34,210 --> 00:41:38,200
이건 named=True 같은 경우 2.대에 들어와 가지고 생긴 옵션이에요

512
00:41:38,230 --> 00:41:41,900
named=True를 쓰게 되면은 반환되는 값이 namedtuple이에요

513
00:41:41,920 --> 00:41:45,690
그래가지고 데이터를 부르실 때 좀 더 namedtuple 좋아하시는,

514
00:41:45,720 --> 00:41:48,790
이렇게 편하게 쓸 수 있는 장점들이 있잖아요

515
00:41:48,820 --> 00:41:53,640
그런 것들 좋아하시는 분들은 named=True 옵션 쓰시면 좋을 것 같아요

516
00:41:53,670 --> 00:41:57,700
values_list() 그리고 values() 이런 식으로

517
00:41:57,730 --> 00:42:02,440
옵션을 줬을 때 데이터 값들이 이런 형태로
넘어온다는 것을 알고 있으면

518
00:42:02,470 --> 00:42:04,890
좋을 것 같아서 참고 삼아 가져와 봤습니다

519
00:42:05,500 --> 00:42:10,710
위에서 설명한 내용들은 사실 그냥 참고삼아 가져온 내용들이긴 한데

520
00:42:10,730 --> 00:42:14,680
이 내용들을 사실 설명하고 싶어서 가져온 것들이에요

521
00:42:14,710 --> 00:42:20,830
values와 values_list를 사용하게 되면은
Eager-loading 옵션들을 전부 무시하는 특성이 있어요

522
00:42:20,860 --> 00:42:21,790
QuerySet은

523
00:42:21,820 --> 00:42:27,650
그렇기 때문에 QuerySet에 주어진 select_related와
prefetch_related를 전부 무시하게 됩니다

524
00:42:27,680 --> 00:42:30,350
이 예제를 보시면 알 수가 있을 거예요

525
00:42:30,380 --> 00:42:33,760
Product를 전부 가져오는데 Company라는 놈을

526
00:42:33,790 --> 00:42:36,090
조인해서 가져와라는 옵션을 여기다가 줬어요

527
00:42:36,110 --> 00:42:39,920
select_related로, 그리고 values()라는 옵션을 붙였을 때

528
00:42:39,950 --> 00:42:44,140
이 select_related JOIN을 하지 않죠
그러니까 이 select_related

529
00:42:44,170 --> 00:42:45,790
옵션을 무시하죠

530
00:42:45,820 --> 00:42:50,390
두 번째 케이스 같은 경우에는, values에다가
정말 JOIN 해야지만 가져올 수 있는 데이터를

531
00:42:50,410 --> 00:42:54,100
이렇게 명시를 해야만 그제서야 얘가 조인을 해요

532
00:42:54,130 --> 00:42:58,240
그렇기 때문에 이 select_related가 있든 없든 values에

533
00:42:58,270 --> 00:43:01,510
필요한 정보를 담아야만 이게 호출되는 걸 볼 수 있는 거죠

534
00:43:01,540 --> 00:43:04,540
마찬가지로 prefetch_related도 무시가 됩니다

535
00:43:04,570 --> 00:43:09,940
추가 쿼리로 '유저의 퍼미션 정보를 전부 가져와'라고
prefetch_related 옵션을 주었고

536
00:43:09,970 --> 00:43:14,480
values_list라는 옵션을 주게 되면은

537
00:43:14,510 --> 00:43:18,430
prefetch 추가 쿼리가 발생하지 않죠
그냥 무시해버리는 케이스가 있습니다

538
00:43:18,460 --> 00:43:22,270
그리고 user_permission 이라는 놈은 Model을
가져오는 게 아니라

539
00:43:22,290 --> 00:43:25,820
포린키 그러니까 FK의 정보를 그냥 가져오기만 하는 거죠

540
00:43:25,850 --> 00:43:30,530
이런 식으로 3, 4 이런 식으로
Permission Model을 가져오는 게 아니라요

541
00:43:30,580 --> 00:43:33,460
네 아래쪽에서도 마찬가지로 보시면

542
00:43:33,490 --> 00:43:36,830
prefetch_related 옵션을 주더라도

543
00:43:36,850 --> 00:43:41,620
values_list를 쓰게 되면은 나는 이런 건 모르겠고
그냥 조인해서 가져와 버립니다

544
00:43:41,650 --> 00:43:45,910
그렇기 때문에 이거 좀 생각을 해주시면 좋을 것 같아요

545
00:43:45,940 --> 00:43:53,420
어떻게 보면 select_related랑 prefetch_related를
무시하는 이 동작이 어떻게 보면 당연하기도 해요

546
00:43:53,500 --> 00:43:59,170
왜냐하면 values랑 values_list 같은 경우에는
아래와 같이 DB Raw 단위로 데이터를 반환하거든요

547
00:43:59,200 --> 00:44:02,860
DB로 Raw 단위라는 거는 이렇게
한 줄, 한 줄, 한 줄을 말하는 거예요

548
00:44:02,890 --> 00:44:09,830
이 말은 즉 ORM의 특성인 객체와 관계지향 간의
매핑이 일어나지 않는다는 거죠

549
00:44:09,850 --> 00:44:15,190
values랑 values_list를 사용하는 케이스에서는
그냥 관계 지향적인 데이터의 'list를

550
00:44:15,220 --> 00:44:18,820
그냥 리턴해버려' 라는 옵션인 거예요

551
00:44:18,850 --> 00:44:25,570
그렇기 때문에 ORM의 Eager-loading이라는
개념은 사실 select_related와

552
00:44:25,600 --> 00:44:28,260
prefetch_related를 통해서

553
00:44:28,280 --> 00:44:33,200
추가 모델들을 한 번에 다 가져와
라는 건데 values와 values_list를 쓰면은

554
00:44:33,220 --> 00:44:38,060
이런 거 필요없고 그냥 '난 DB의 로우 단위로 데이터를 볼 거야'라는 옵션이기 때문에

555
00:44:38,090 --> 00:44:43,330
어떻게 보면 select_related랑 prefetch_related가
무시되는 게 당연한 결과일 수도 있어요

556
00:44:43,360 --> 00:44:46,650
그렇기 때문에 참고해 주시면 좋을 것 같아요

557
00:44:46,770 --> 00:44:52,500
네 지금까지 Django ORM의 QuerySet에 대해서 알아봤고요

558
00:44:52,520 --> 00:45:00,200
마치면서 QuerySet을 잘 쓰려면 어떻게 쓰면 좋을지에 대해서
간략하게 얘기를 해보고 넘어갈까 합니다

559
00:45:00,340 --> 00:45:05,250
QuerySet은 일단 한 개의 Query와 0 또는 N개의 QuerySet으로 이루어져 있다

560
00:45:05,280 --> 00:45:08,470
이거를 알고 항상 쓰시면 좋을 것 같아요

561
00:45:08,500 --> 00:45:12,230
그리고 수행하고자 하는 SQL을 먼저 떠올리지 말고

562
00:45:12,260 --> 00:45:16,350
내가 필요한 데이터 리스트를 먼저 떠올리고 쓰는 게 좋은 거 같아요

563
00:45:16,380 --> 00:45:20,230
'나는 이 SQL을 만들 거야'라고 생각을 하고 쿼리를

564
00:45:20,260 --> 00:45:23,510
QuerySet으로 뭔가 내가 원하는 쿼리셋을 작성하려고 하면은

565
00:45:23,530 --> 00:45:25,210
가끔씩 좀 막막할 때가 많아요

566
00:45:25,240 --> 00:45:29,230
그렇기 때문에 내가 원하는 데이터 리스트를 먼저 생각을 하고

567
00:45:29,250 --> 00:45:32,550
이 데이터 리스트를 가져오려면 쿼리셋에 어떤 옵션을 줘야되지?

568
00:45:32,570 --> 00:45:37,900
이런 식으로 뭔가 거꾸로 생각하는게 가끔씩은 좀 더 편할 때가 많습니다

569
00:45:38,530 --> 00:45:43,990
그리고 QuerySet이 제공하는 기초적인 SQL의
구조를 항상 기억하고 있으면 좋을 것 같아요

570
00:45:44,020 --> 00:45:50,380
이 구조를 벗어난다면 그때는 이제 RawQuerySet으로
내가 직접 SQL을 작성해주는 게 좋을 것 같아요

571
00:45:50,410 --> 00:45:58,700
QuerySet이 제공하는 기초적인 SQL 구조는
4-2에 제가 제공해 드린 그 예제를 참고하면 좋을 것 같아요

572
00:45:58,730 --> 00:46:03,070
그리고 ORM에서 복잡한 SQL을 ORM으로 구현했다고

573
00:46:03,100 --> 00:46:07,590
이게 SQL을 잘 쓰는 게 아니라고 저는 개인적으로 생각을 합니다

574
00:46:07,620 --> 00:46:13,080
어떤 로직을 작성하는데
ORM의 장점 중의 하나인

575
00:46:13,120 --> 00:46:14,980
단조로운 SQL 작업을 줄이고

576
00:46:15,000 --> 00:46:21,330
Object와 Relational간에 매핑을 해준다는 장점을 얻을 수 없을 때

577
00:46:21,360 --> 00:46:26,900
그때는 그냥 망설이지 말고 차라리
네이티브 SQL을 작성하는 게 좀 더 좋다고 생각을 해요

578
00:46:26,930 --> 00:46:30,410
ORM으로 굉장히 어려운 SQL을 이렇게 작성해 놓으면

579
00:46:30,440 --> 00:46:34,150
그게 나중에 정말 보기가 어렵거든요

580
00:46:34,180 --> 00:46:38,110
그렇기 때문에 무조건 뭔가 이렇게 복잡한 SQL이 있을 때

581
00:46:38,130 --> 00:46:45,010
그것을 너무 ORM으로 구현하려고 애를 쓰지 말자
라고 개인적으로 추천드리고 싶습니다

582
00:46:45,040 --> 00:46:48,950
네. 위에 있었던 내용들을 그냥 정리해서 설명을 하면

583
00:46:48,970 --> 00:46:53,250
날쿼리를 사용하는 데 있어서 그렇게 막 망설이지 않았으면 좋겠어요

584
00:46:53,280 --> 00:46:56,760
특히 SQL 성능이 중요한 경우라면 더더욱 그러고요

585
00:46:56,790 --> 00:47:03,430
가끔씩은 ORM으로 이렇게 원하는 쿼리결과를 얻을 수 없을 때가 많은데

586
00:47:03,460 --> 00:47:07,330
그럴 때나 또는 가독성이 높은 코드가 이렇게 필요할 때도 있어요

587
00:47:07,350 --> 00:47:12,740
그럴 때는 QuerySet으로 이렇게 작성했을 때
뭔가 가독성이 되게 어려워질 때도 있거든요

588
00:47:12,760 --> 00:47:16,140
그런 경우에는 날쿼리를 쓰는 게 좀 더 적절할 수도 있겠죠

589
00:47:16,170 --> 00:47:18,760
결국은 개발자의 판단이 중요한 거고

590
00:47:18,790 --> 00:47:24,110
그 안에서 ORM을 얼마나, Django의 QuerySet에 대한 이해도가 많이 깊느냐

591
00:47:24,140 --> 00:47:29,650
아니면 새로운 QuerySet에 대해서 이렇게 이해하지
못하는 사람들이 자주 자주 많이 들어오느냐

592
00:47:29,680 --> 00:47:34,760
그런 것들에 따라서 그 프로젝트에서 QuerySet을 더 깊게 쓸지

593
00:47:34,790 --> 00:47:39,320
아니면은 네이티브 SQL로 그냥 풀어쓸지가
결정될 수 있을 것 같습니다

594
00:47:40,240 --> 00:47:45,370
이걸로 발표를 마치려고 하고요
참고자료로 이렇게 작성을 해놨어요

595
00:47:45,400 --> 00:47:53,260
실제로 제가 이 프로젝트 진행하는데 썼던
로직들을 다 이 프로젝트에다가 저장을 해놨고

596
00:47:53,290 --> 00:47:58,750
나머지 내용들은 이 프로젝트에 적힌 내용들을

597
00:47:58,780 --> 00:48:02,170
선수작업으로 제가 저희 회사 블로그에다가 글을 좀 몇 개 작성해 놓은 게 있어요

598
00:48:02,190 --> 00:48:06,600
그래서 여기에 담지 못한 내용들이 담겨져 있기는 합니다

599
00:48:06,880 --> 00:48:12,440
들어와서 보셔도 좋을 것 같아서
혹시 몰라서 링크를 첨부해 두었습니다. 감사합니다

