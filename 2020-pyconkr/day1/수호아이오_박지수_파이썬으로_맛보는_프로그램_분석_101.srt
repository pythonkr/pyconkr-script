1
00:00:10,480 --> 00:00:11,722
안녕하세요
 

2
00:00:11,792 --> 00:00:15,556
파이썬으로 맛보는 프로그램 분석 101 발표를 맡은
 

3
00:00:15,580 --> 00:00:17,362
수호아이오의 박지수입니다
 

4
00:00:18,220 --> 00:00:22,188
저는 파이썬을 알게 된 지 오래됐지만
 

5
00:00:22,213 --> 00:00:25,186
접한지는 사실 그렇게까지 오래되지는 않았는데요
 

6
00:00:25,210 --> 00:00:29,645
이번에 처음으로 파이썬 커뮤니티에 조금이나마 기여할 수 있어서
 

7
00:00:29,670 --> 00:00:32,849
너무 영광이고 이 자리를 위해서 준비해주신
 

8
00:00:32,874 --> 00:00:35,084
준비위원회분들께도 감사의 말씀을 드립니다
 

9
00:00:36,040 --> 00:00:40,665
저는 제 이름 그대로 @jisupark 이라고 하는 깃허브 아이디로
 

10
00:00:40,690 --> 00:00:44,510
오픈소스나 여러 가지 개발일들을 해오고 있고요
 

11
00:00:45,100 --> 00:00:51,106
저는 '두나무'라고 하는 이 핀테크 회사에서 15년도부터 개발을 시작했고
 

12
00:00:51,130 --> 00:00:56,864
지금은 '수호'라고 하는 보안회사를 창업한 스타트업 대표입니다
 

13
00:00:59,094 --> 00:01:03,078
저는 보안이나 블록체인 그리고 핀테크 쪽에 관심이 많으니깐
 

14
00:01:03,550 --> 00:01:06,854
이러한 키워드로 언제든지 얘기 나눌 수 있으면 좋을 것 같습니다
 

15
00:01:08,860 --> 00:01:11,820
개발 커뮤니티나 컨퍼런스들을 봤을 때는
 

16
00:01:11,845 --> 00:01:16,789
보통 개발 생산성, 코드 안정성 등의 얘기가 많은데요
 

17
00:01:17,350 --> 00:01:21,725
저는 오늘 코드 안정성에 대해서 조금 얘기를 나눠보고자 합니다
 

18
00:01:23,260 --> 00:01:26,392
그 전에 먼저 좀 드리고 싶은 질문이 있는데요
 

19
00:01:26,860 --> 00:01:30,633
안전한 소프트웨어를 만들고 계신지 한번 여쭙고 싶습니다
 

20
00:01:31,870 --> 00:01:32,635
어떠세요
 

21
00:01:32,666 --> 00:01:34,862
안전한 소프트웨어를 개발하고 계신가요?
 

22
00:01:37,240 --> 00:01:41,232
대답에 앞서서 안전한 이라고 하는 단어의 뜻을 살펴보면요
 

23
00:01:42,070 --> 00:01:47,280
표준국어대사전에 따르면 위험이 생기거나 사고가 날 염려가 없음을 뜻합니다
 

24
00:01:49,270 --> 00:01:54,738
위험하거나 사고가 나지 않을 만한 소프트웨어를 개발하는지 한번 여쭙겠습니다
 

25
00:01:56,680 --> 00:02:00,555
사실 이러한 안전한 소프트웨어를 만든다 라고
 

26
00:02:00,580 --> 00:02:03,148
대답하기는 쉽지가 않을 것 같습니다
 

27
00:02:03,556 --> 00:02:08,275
왜냐하면 개발자의 숙명 혹은 프로그램의 숙명이라고도 할 수 있겠는데요
 

28
00:02:08,595 --> 00:02:13,040
그러면 이런 결함이나 버그. 버그나 취약점 등을 의미하는 결함은
 

29
00:02:13,376 --> 00:02:17,149
사실은 굉장히 많이 빈번하게 발생을 하고 있습니다
 

30
00:02:17,890 --> 00:02:23,241
실제로 이런 소프트의 결함으로 인한 피해는 정말로 어마어마하게 많은 상황입니다
 

31
00:02:24,400 --> 00:02:26,462
17년도 조사에 따르면은
 

32
00:02:26,487 --> 00:02:31,204
가운데 있는 엄청난 숫자만큼의 피해가 발생하고 있습니다
 

33
00:02:32,620 --> 00:02:36,518
300여 개 회사에서 발생한 피해임에도 불구하고
 

34
00:02:36,543 --> 00:02:40,354
엄청나게 많은 금액의 피해가 존재합니다
 

35
00:02:41,350 --> 00:02:45,240
단순히 이런 금액이나 비용과 같은 문제가 아니라
 

36
00:02:45,640 --> 00:02:49,069
정말로 많은 생활의
 

37
00:02:49,094 --> 00:02:53,225
실질적인 문제를 일으킬 만큼 심각하다고 말할 수 있겠습니다
 

38
00:02:54,070 --> 00:02:57,788
뭐 소프트웨어 결함은 아주 예전부터 발생했던 문제이기 때문에
 

39
00:02:58,270 --> 00:03:01,324
갑작스럽게 새로 대두되고 있는 문제는 아니지만요
 

40
00:03:01,870 --> 00:03:06,955
예를 들면 제가 조사했을 때는 뭐 1996년도에도 발생하고
 

41
00:03:07,480 --> 00:03:12,238
계속 발생을 했지만 11년도 최근에 들어서도 문제가 발생하고 있습니다
 

42
00:03:12,277 --> 00:03:17,086
로켓의 폭발을 하거나 자동매매 프로그램의 결합으로 인해서
 

43
00:03:17,110 --> 00:03:23,406
수십억 달러, 수천억 원에 대한 재산상의 피해도 발생했고
 

44
00:03:23,860 --> 00:03:28,297
최근에는 목숨을 잃을 정도의 사고도 많이 발생을 하고 있습니다
 

45
00:03:29,560 --> 00:03:33,044
그래서 생각보다 이런 소프트웨어 결함으로 인한 문제는
 

46
00:03:33,069 --> 00:03:38,123
단순히 재산뿐만이 아니라 일상생활에 저희의 영향을 많이 줄 만큼
 

47
00:03:38,163 --> 00:03:39,825
심각한 문제가 되고 있습니다
 

48
00:03:39,850 --> 00:03:45,466
특히 머신러닝이나 뭐 빅데이터 등 그리고 뭐 개인정보 이슈까지
 

49
00:03:45,490 --> 00:03:51,216
이제는 저희 생활에 아주 밀접한 문제까지도
소프트웨어로 인해서 발생하고 있는 상황입니다 

50
00:03:52,870 --> 00:03:57,680
그래서 저는 오늘 조금 뭐 논의했으면 좋겠는
 

51
00:03:57,705 --> 00:04:03,205
그리고 같이 이렇게 생각했으면 좋겠다는
주제로 이러한 것들을 좀 말씀드리려고 합니다 

52
00:04:04,000 --> 00:04:09,616
소프트웨어로 저희가 세상을 바꾸고 그 소프트웨어를 저희가 즐기는 사람으로써
 

53
00:04:09,640 --> 00:04:12,810
저희는 앞으로 더더욱 큰 책임감을 가져야 되지 않을까?
 

54
00:04:12,835 --> 00:04:14,390
저는 생각을 하고 있습니다
 

55
00:04:14,830 --> 00:04:19,923
그래서 이런 제 생각을 한 번씩 고민해봐주면 어떨까 싶은 생각도 있습니다
 

56
00:04:21,459 --> 00:04:24,326
그래서 한번 제가 발췌해봤는데요
 

57
00:04:25,420 --> 00:04:28,677
이제 한국정보과학회에서 감사하게도
 

58
00:04:28,702 --> 00:04:31,662
이제 번역을 해주셔서 그대로 제가 발제를 했습니다
 

59
00:04:32,380 --> 00:04:34,309
소프트웨어 공학 윤리강령
 

60
00:04:34,357 --> 00:04:38,465
그리고 원제목은 Software Ethics라고 하는 윤리학인데요
 

61
00:04:39,627 --> 00:04:43,244
윤리 강령에 따르면 요약하자면
 

62
00:04:43,269 --> 00:04:46,931
이제 소프트웨어 엔지니어 혹은 소프트웨어를 개발하는 사람들은
 

63
00:04:47,830 --> 00:04:53,431
결국에 자기가 만든 결과물에 대한 책임감을
가져야 된다는 말로 요약을 할 수가 있겠습니다 

64
00:04:54,062 --> 00:04:57,124
저희가 그런 책임감을 가지기 위해서
 

65
00:04:57,179 --> 00:05:01,218
가장 할 수 있는 것들이 어떤 것들이 있을지 한번 말씀을 드려보면요
 

66
00:05:01,870 --> 00:05:04,424
작년의 이창희님이 발표하셨던
 

67
00:05:04,449 --> 00:05:07,682
'정적 타입 검사로 더 나은 파이썬 코드 작성하기'
 

68
00:05:08,230 --> 00:05:10,534
발표를 보시면 아시겠지만
 

69
00:05:10,558 --> 00:05:13,839
파이썬 커뮤니티에서도 굉장히 많은 노력들을 하고 있습니다
 

70
00:05:14,320 --> 00:05:18,038
타입힌팅(Type Hinting)과 같은 파이썬에서 제공하고 있는
 

71
00:05:18,063 --> 00:05:21,202
타입검사 등을 저희가 쓸 수도 있겠습니다
 

72
00:05:21,850 --> 00:05:24,920
혹은 CVE 라고 하는
 

73
00:05:24,945 --> 00:05:30,123
공개된 취약점 데이터베이스에 관심을 갖는 것도 저희가 할 수 있는 노력입니다
 

74
00:05:31,686 --> 00:05:34,709
왼쪽에 보이는 이미지는 Flask라고 하는
 

75
00:05:34,734 --> 00:05:39,959
파이썬 웹 프레임워크에서 발견된 취약점을
 

76
00:05:39,984 --> 00:05:42,296
CVE에 누군가 제보한 내용입니다
 

77
00:05:43,300 --> 00:05:48,586
다음과 같이 저희가 많이 쓰고 있는 
프레임워크나 라이브러리에 대한 취약점들도 

78
00:05:48,610 --> 00:05:51,883
이 CVE에 지속적으로 제보가 되고 있으니까
 

79
00:05:52,030 --> 00:05:56,365
우리가 사용하고 있는 오픈소스에 대해서도
지속적으로 보안 이슈는 없는지 

80
00:05:56,428 --> 00:06:01,170
결함은 없을지 관심을 갖는 게 저희가 할 수 있는 일인 것 같습니다
 

81
00:06:03,190 --> 00:06:07,275
그러면 이렇게 소극적이지 않고 조금 더 능동적으로
 

82
00:06:07,604 --> 00:06:10,229
저희가 관심을 가질 수 있는 방법은 무엇일까요?
 

83
00:06:10,960 --> 00:06:15,288
저는 우리가 만드는 프로그램은 우리가 가장 잘 알기 때문에
 

84
00:06:15,313 --> 00:06:18,530
직접 소프트웨어를 분석하는 방법도 있다고 생각합니다
 

85
00:06:20,350 --> 00:06:25,336
소프트웨어를 분석한다는 의미는 소프트웨어의 실행 성질를 분석해서
 

86
00:06:25,360 --> 00:06:28,149
사전에 오류를 감지하는 것을 의미합니다
 

87
00:06:28,600 --> 00:06:35,576
목표로 하고요
그래서 비용을 X축 검증능력을 Y축으로 놨을 때 

88
00:06:35,623 --> 00:06:37,966
다양한 분석 방법들이 존재합니다
 

89
00:06:38,860 --> 00:06:42,391
가장 쉽고 빠르게 분석할 수 있는 방법으로는
 

90
00:06:42,416 --> 00:06:45,266
퍼징 혹은 랜덤 테스팅 등이 존재하고요
 

91
00:06:46,120 --> 00:06:48,932
그리고 '기호 실행'이나 '정적 분석'과 같은
 

92
00:06:48,957 --> 00:06:52,574
조금 고도화된 기법
그리고 아주 최신 기법으로 볼 수 있는 

93
00:06:52,613 --> 00:06:55,066
'소프트웨어 증명'기법도 존재합니다
 

94
00:06:55,810 --> 00:06:58,231
그래서 오늘은 파이썬을 이용해서
 

95
00:06:58,256 --> 00:07:04,638
이러한 분석 기법들에 대해서 간단하게 배우고 얘기 나누는 시간을 준비했습니다
 

96
00:07:06,640 --> 00:07:09,405
먼저 랜덤 테스팅을 구현을 해보면요
 

97
00:07:10,210 --> 00:07:14,405
이름에서 알다시피 무작위로 테스트를 하는 방법인데
 

98
00:07:14,740 --> 00:07:20,716
테스트 방식이 입력을 무작위로 생성해서
테스트하는 것이라고 이해하시면 쉽겠습니다 

99
00:07:21,656 --> 00:07:26,078
그래서 왼쪽에 보이는 열두 줄짜리 프로그램을 살펴보시면
 

100
00:07:26,500 --> 00:07:32,085
중간에 열한 번째 줄이는 에러에 도달하는 것이 랜덤 테스팅의 목표입니다
 

101
00:07:33,368 --> 00:07:38,446
에러에 도달한다는 것은 여기서 취약점이 발현된다 라는 것과
 

102
00:07:38,470 --> 00:07:41,071
동치라고 생각하시면 됩니다
 

103
00:07:42,040 --> 00:07:44,540
그래서 열한 번째 줄에 도달해야지
 

104
00:07:44,565 --> 00:07:48,055
'Crash Occured'라고 하는 문장이 프린트가 되고
 

105
00:07:48,760 --> 00:07:52,220
실제로 프로그램에서 에러가 발생한다고 이해하시면 되겠습니다
 

106
00:07:53,290 --> 00:07:58,125
그러면 x와 y값. 그러니까 test 함수에 들어온 인자값이
 

107
00:07:58,150 --> 00:08:01,187
각각 0에서부터 100라고 가정했을 때
 

108
00:08:01,212 --> 00:08:05,399
무작위로 입력을 생성해서 에러에 도달하게끔 하는 프로그램이
 

109
00:08:05,424 --> 00:08:07,774
랜덤 테스팅 프로그램이라고 보시면 됩니다
 

110
00:08:09,310 --> 00:08:12,474
그러면 바로 코드를 공개하기 앞서서
 

111
00:08:12,499 --> 00:08:16,427
간단하게 한번 어떤 식으로 짜면 좋을지 생각을 해보겠습니다
 

112
00:08:21,640 --> 00:08:26,538
네 너무 많은 시간을 드릴 수는 없으니까
한 번 생각하셨다고 생각하고 

113
00:08:26,563 --> 00:08:27,952
저도 한번 넘어가 보겠습니다
 

114
00:08:29,780 --> 00:08:34,944
공교롭게도 12줄자리 프로그램에 12줄짜리 렌덤 테스팅 프로그램이 나왔는데요
 

115
00:08:36,490 --> 00:08:41,544
무작위로 입력을 생성해서 테스트를 어떤
식으로 진행했는지 간단하게 살펴보겠습니다 

116
00:08:42,789 --> 00:08:46,710
우선 0에서부터 100까지의 값을 가지기 때문에
 

117
00:08:46,735 --> 00:08:49,382
랜덤으로 입력을 생성을 첫 번째로 하게 됩니다
 

118
00:08:51,310 --> 00:08:56,036
두 번째로 테스트 함수의 에러가 발생했는지를 살펴보기 위해서
 

119
00:08:56,410 --> 00:09:01,527
테스트를 실행을 하고 실행 결과값을 저장을 하게 됩니다
 

120
00:09:02,440 --> 00:09:07,756
그 저장한 결과값이 기대하고 있는 'Crash Occured' 스트링과 같은지를
 

121
00:09:07,780 --> 00:09:11,213
비교하고 나올 때까지 반복을 하게 됩니다
 

122
00:09:12,010 --> 00:09:17,478
이렇게만 하면 랜덤하게 테스팅하는 프로그램을 저희가 만들게 된 겁니다
 

123
00:09:18,431 --> 00:09:22,048
생각보다 굉장히 간단하게 만들 수 있습니다
 

124
00:09:23,620 --> 00:09:27,604
물론 개념적으로도 랜덤으로 입력해서
테스트를 하는 거다 보니까 

125
00:09:27,629 --> 00:09:29,940
쉽게 만들 것이라고 짐작하셨겠지만
 

126
00:09:30,340 --> 00:09:35,183
막상 코드로 보니 훨씬 더 간단한 것을 확인하실 수가 있습니다
 

127
00:09:36,850 --> 00:09:41,467
그러면 실제로 저 while 루프를 탈출하기까지
 

128
00:09:41,492 --> 00:09:45,842
몇 번의 랜덤 생성이 있었는지를 예측해볼 수 있을까요?
 

129
00:09:46,600 --> 00:09:50,131
저 'count'의 값이 어떻게 될지 한번 상상해 보겠습니다
 

130
00:09:50,920 --> 00:09:54,451
x와 y가 0에서부터 100사이에 값일 때
 

131
00:09:54,476 --> 00:10:00,724
에러에 도달할 x, y값이 만들어질 확률은 0.4% 미만입니다
 

132
00:10:01,660 --> 00:10:07,276
물론 x와 y가 int이기 때문에 훨씬 더 많은 경우의 수가 존재하겠지만
 

133
00:10:07,300 --> 00:10:10,698
저희가 전제한 기준으로 했을 때는 0.4% 미만이됩니다
 

134
00:10:11,590 --> 00:10:16,113
실제로 저 코드를 실행시켰을 때도 무수히 많은 시도와 실패가
 

135
00:10:16,138 --> 00:10:19,215
터미널에 노출되는 것을 확인하실 수가 있습니다
 

136
00:10:20,050 --> 00:10:22,120
저도 돌리다가 껐습니다
 

137
00:10:23,176 --> 00:10:29,231
물론 랜덤 테스팅이 그러면 쓸모가 없는 거냐 
0.4%면 별로인 거 아니냐 라고 생각하실 수 있겠는데요 

138
00:10:29,920 --> 00:10:35,356
저희가 아무래도 간단히 짠 거다 보니깐 더 많은 최신 기법들을 적용하면
 

139
00:10:35,380 --> 00:10:38,802
더 높은 성능의 분석기가 나올 수가 있습니다
 

140
00:10:39,550 --> 00:10:43,589
예를 들어서 앞서 설명드렸던 첫 번째 값을
 

141
00:10:43,614 --> 00:10:45,534
랜덤 값을 무엇으로 하는가?
 

142
00:10:46,600 --> 00:10:50,889
어떤 값을 맨 처음에 랜덤 값으로 둘 때
 

143
00:10:50,914 --> 00:10:55,514
성능이 좋아지는가에 대한 연구도 현재 많이 진전이 되고 있고요
 

144
00:10:56,050 --> 00:11:00,175
중간 중간 값을 저장하거나 다른 분석기법을 활용에서
 

145
00:11:00,200 --> 00:11:06,385
더 빠르게 실행할 수 있는 방법들, 값들을 찾는 연구들도 많이 존재하고 있습니다
 

146
00:11:07,867 --> 00:11:12,836
이 퍼징은 코드가 없는 상황에서도 실행하는 것만으로도
 

147
00:11:12,861 --> 00:11:18,439
취약점을 찾을 수 있는 블랙박스 테스팅에 아주 대표적인 기술 중 하나인데요
 

148
00:11:19,780 --> 00:11:23,819
이러한 기법들에서 많이 활용이 되고 있기 때문에
 

149
00:11:23,844 --> 00:11:27,725
여전히 많은 사람들이 관심을 갖고 연구를 하고 있습니다
 

150
00:11:28,000 --> 00:11:32,776
뭐 리눅스와 같은 혹은 비트코인 데몬과 같은 프로그램에
 

151
00:11:32,800 --> 00:11:36,839
테스팅 퍼징을 통해서 많은 취약점들이 여전히 발견이 되고 있기 때문에
 

152
00:11:37,150 --> 00:11:41,126
여러분들도 한번 관심을 가져주시면 좋을 것 같습니다
 

153
00:11:43,450 --> 00:11:47,035
그럼 다음으로는 '기호 실행'을 한번 구현해 보겠습니다
 

154
00:11:47,740 --> 00:11:52,349
'기호 실행'은 앞서 실제값을 이용에서 실행을 하기보다는
 

155
00:11:52,374 --> 00:11:55,669
기호를 이용해서 실행하는 방법입니다
 

156
00:11:56,252 --> 00:12:00,735
마찬가지로 앞서 살펴본 열두 줄짜리 프로그램에 대해서
 

157
00:12:00,760 --> 00:12:03,002
구현을 해보는 시간을 가져보겠습니다
 

158
00:12:03,627 --> 00:12:08,369
전제는 모두 동일하게 0에서부터 100에 입력이 들어온다고 가정하겠습니다
 

159
00:12:10,000 --> 00:12:14,539
기호 실행이 뭔지 아직 말씀을 안드렸기 때문에 설명을 먼저 드리겠습니다
 

160
00:12:15,910 --> 00:12:20,464
예전에 저희가 수학 시간에 배웠던 그런 사고와 되게 유사합니다
 

161
00:12:21,419 --> 00:12:26,302
이 테스트 함수는 인자로 x와 y가 들어오기 때문에
 

162
00:12:26,982 --> 00:12:30,435
x를 α, y를 β라고 둘 수 있습니다
 

163
00:12:31,480 --> 00:12:35,237
구현을 한다 했을 때는 테이블을 만들어서 관리하거나
 

164
00:12:35,262 --> 00:12:37,401
변수를 만들거나 하는 방법이 존재하겠죠
 

165
00:12:38,890 --> 00:12:42,890
그 다음으로는 8번째줄이 실행됐을 때에는
 

166
00:12:42,915 --> 00:12:48,749
z는 double(y)가 되기 때문에 결국 z는 2*β라는 값이 성립이 됩니다
 

167
00:12:50,324 --> 00:12:54,956
9번째 줄이 실행이 되면은
 

168
00:12:54,981 --> 00:13:00,550
10번째 줄로 넘어가기 위해서는 9번째 줄의 조건문이 참이 되어야 합니다
 

169
00:13:01,360 --> 00:13:04,219
그래서 z는 x일 경우
 

170
00:13:04,244 --> 00:13:08,219
2*β == α라고 하는 조건식이 추출이 될 수가 있습니다
 

171
00:13:10,600 --> 00:13:14,806
9번째 줄이 참일 경우에는 10번째 줄이 마찬가지로 실행이 될 수가 있고요
 

172
00:13:14,830 --> 00:13:19,326
10번째 줄에서 11번째 줄이 실행이 되기 위한 조건이
 

173
00:13:19,351 --> 00:13:21,316
x는 y+10보다 크다
 

174
00:13:21,340 --> 00:13:26,476
즉 α는 β+10보다 큰 조건식이 하나 더
 

175
00:13:26,500 --> 00:13:27,394
나오게 됩니다
 

176
00:13:28,300 --> 00:13:32,214
그래서 11번째 줄로 가기 위해서는 9번째 줄에서 도출한 조건과
 

177
00:13:32,239 --> 00:13:36,245
10번째 줄에서 도출된 조건 두 가지가 모두 참이 되어야 합니다
 

178
00:13:36,730 --> 00:13:39,722
즉 AND 조건이 성립을 하게 됩니다
 

179
00:13:40,690 --> 00:13:45,088
그래서 다음 라인인 11번째 줄로 와서 error라고 하는 함수에
 

180
00:13:45,113 --> 00:13:48,105
실행할 수 있는 조건들을 모두 도출할 수 있게 되었습니다
 

181
00:13:49,060 --> 00:13:53,106
그래서 에러에 도달하기 위해서는 x=α
y=β라고 뒀을 때 

182
00:13:53,131 --> 00:13:56,623
z=2*β, 그리고 2*β는 α이면서
 

183
00:13:56,639 --> 00:14:00,552
α는 β+10보다 커야 되는 조건들이 존재합니다
 

184
00:14:01,330 --> 00:14:05,009
앞서서 랜덤 테스팅은 이러한 α, β 값들을
 

185
00:14:05,034 --> 00:14:08,057
랜덤으로 생성해서 대입하는 것이라고 볼 수 있는데요
 

186
00:14:08,590 --> 00:14:11,863
'기호 실행'은 α와 β를 이용해서
 

187
00:14:11,888 --> 00:14:16,246
조건식들을 만들었기 때문에 위 조건식을 만족하는 값들을
 

188
00:14:16,270 --> 00:14:21,785
Solver라고 하는 라이브러리 그리고 도움을 통해서 풀어낼 수가 있습니다
 

189
00:14:23,080 --> 00:14:27,197
Solver는 쉽게 말하면 방정식 풀이기라고 보시면 될 것 같습니다
 

190
00:14:28,000 --> 00:14:32,445
그래서 'z3-solver'라고 하는 파이썬 라이브러리를 이용해서
 

191
00:14:32,476 --> 00:14:35,981
z3-solver를 이용해 값을 도출을 하면
 

192
00:14:36,006 --> 00:14:43,006
x=22, y=11과 같이 조건식을 만족하는 값을 도출할 수가 있습니다
 

193
00:14:43,030 --> 00:14:46,780
이렇게 진행되는 게 '기호 실행'이라고 보시면 될 것 같습니다
 

194
00:14:47,350 --> 00:14:52,748
너무나도 당연하게 직관적으로 받아들일 수 있을 거라고 예상하는데요
 

195
00:14:54,670 --> 00:14:57,224
코드로 옮긴다면 어떻게 돼야 될까요?
 

196
00:14:57,560 --> 00:15:00,645
x나 y 그리고 z에 대해서는
 

197
00:15:00,677 --> 00:15:03,106
라인-바이-라인으로 도출하는 방법
 

198
00:15:03,130 --> 00:15:09,286
혹은 파싱을 해서 도출하거나 여러 가지
방법들로 도출할 수 있기 때문에 생략을 하겠습니다 

199
00:15:10,450 --> 00:15:14,457
대신에 이 Solver를 푸는 코드를 한번 공유를 드리면요
 

200
00:15:14,860 --> 00:15:17,360
Jupyter를 이용해 다음과 같이 작성할 수 있습니다
 

201
00:15:18,190 --> 00:15:20,088
'z3-solver'를 설치를 하고요
 

202
00:15:20,596 --> 00:15:26,206
z3에서 변수를 선언하는 Int x, y, z 를 선언해주고
 

203
00:15:26,230 --> 00:15:29,876
z = 2*y 그리고 앞서 말씀드렸던 조건식 두 가지
 

204
00:15:29,901 --> 00:15:33,697
z는 x 여야 되고 x는 y+10보다 큰
 

205
00:15:33,722 --> 00:15:36,143
것이 AND로 묶인 다음에
 

206
00:15:36,550 --> 00:15:40,971
풀어내면은 Solver가 y = 11, x = 22라는 값을
 

207
00:15:41,860 --> 00:15:42,550
알려줍니다
 

208
00:15:43,570 --> 00:15:49,702
물론 x는 22일 필요는 없고 Solver가 다른 값을 아웃풋으로 줄 수도 있습니다
 

209
00:15:50,218 --> 00:15:55,530
앞서 살펴본 랜덤 테스팅과 비교했을 때
 

210
00:15:55,555 --> 00:15:58,577
굉장히 빠르게 접근할 수 있는
 

211
00:15:58,624 --> 00:16:02,616
에러 스테이트먼트를 실행시킬 수 있는 x,y 값이 도출이 됩니다
 

212
00:16:04,210 --> 00:16:08,624
그래서 앞서 살펴봤던 그래프 기준으로
 

213
00:16:08,678 --> 00:16:14,490
랜덤 테스팅보다 조금 더 검증능력이 높다고 많이 비교적 평가받고 있습니다
 

214
00:16:15,940 --> 00:16:20,956
아직 말씀드리지 않은 더 많은 분석 기법들을 
파이썬으로 쉽게 구현할 수가 있습니다 

215
00:16:22,570 --> 00:16:27,687
지금까지 살펴봤던 기법들이 'Bug Finding' 관점에서의 분석 방법입니다
 

216
00:16:28,480 --> 00:16:33,697
테스팅 툴은 점들이 프로그램이 실행 실제 실행환경이라고 봤을 때
 

217
00:16:33,722 --> 00:16:36,565
중간 중간에 숨어있는 이 버그들을
 

218
00:16:36,590 --> 00:16:40,182
타게팅해서 찾는 방법이라고 보시면 될 것 같습니다
 

219
00:16:40,990 --> 00:16:42,990
하지만 '기호 실행' 같은 경우는
 

220
00:16:44,161 --> 00:16:48,646
프로그램 내부의 한 영역을 검색하는 것이라고 볼 수가 있는데요
 

221
00:16:48,670 --> 00:16:51,974
그 이유는, 전체가 아닌 이유는
 

222
00:16:52,068 --> 00:16:56,446
프로그램의 실행. 뭐 메모리나 스택 등이 제한이 있기 때문에
 

223
00:16:56,470 --> 00:17:01,313
모든 프로그램의 실행에 대해서 확인할 수가 없습니다
 

224
00:17:01,631 --> 00:17:04,310
예를들어서 분기가 계속 계속 생긴다면
 

225
00:17:04,810 --> 00:17:08,755
2의 n제곱 만큼의 여러 가지 스테이트가 발생하기 때문에
 

226
00:17:08,919 --> 00:17:14,067
그 각각을 모두 도달하는 거에는 물리적인 한계가 존재합니다
 

227
00:17:14,341 --> 00:17:17,505
그래서 이렇게 영역 형태로 표시가 되는 거고요
 

228
00:17:18,130 --> 00:17:22,762
이런 Bug Finding 관점이 아니라 프로그램을 증명하는 방법도 존재합니다
 

229
00:17:23,290 --> 00:17:25,711
오른쪽에 보이는 Verification의 영역인데요
 

230
00:17:26,829 --> 00:17:31,508
프로그램이 실행 영역 점들을 수학적인 영역으로 치환을 하게 됩니다
 

231
00:17:31,690 --> 00:17:33,338
도메인을 치환하는 건데요
 

232
00:17:33,408 --> 00:17:38,634
수학적인 수식으로 프로그램을 완전히 번역해서
 

233
00:17:39,070 --> 00:17:42,913
이 프로그램을 수학적으로 증명하는 성질을 증명하는
 

234
00:17:42,938 --> 00:17:45,359
기법이 바로 베리파이어(Verifier)라고 볼 수 있겠습니다
 

235
00:17:45,850 --> 00:17:48,326
그래서 점들을 넘어서는
 

236
00:17:48,351 --> 00:17:52,021
큰 원으로 이 프로그램을 분석하는 것이 되고요
 

237
00:17:52,330 --> 00:17:55,181
대신에 뭐 오탐이라고 할 수 있는
 

238
00:17:55,206 --> 00:17:58,150
False positive가 발생하는 그런 특징이 존재합니다
 

239
00:17:58,720 --> 00:18:03,586
이런 배경들을 살펴봤을 때 
꼭 알려져 있는 분석 방법이 아니라 

240
00:18:03,610 --> 00:18:09,547
우리가 가장 잘 알고 있는 프로그램의 특성을
고려해서 우리만의 분석기도 구현을 할 수가 있습니다 

241
00:18:10,480 --> 00:18:15,737
예를 들어서 프로그램상에 이미 알려진
취약코드가 존재하는지를 탐지해주는 

242
00:18:15,762 --> 00:18:17,144
분석기를 만들 수도 있습니다
 

243
00:18:18,520 --> 00:18:24,746
지금 소개해드릴 오픈소스 소프트웨어는
 

244
00:18:24,790 --> 00:18:28,094
VUDDY라고 하는 연구회에서 오픈소스로 공개한 분석기인데요
 

245
00:18:28,696 --> 00:18:32,813
고려대학교를 지금은 졸업한 김슬배 연구원님이
 

246
00:18:32,838 --> 00:18:35,391
논문을 투고하고
 

247
00:18:35,416 --> 00:18:38,916
오픈소스로 공개한 VUDDY라고 하는 분석기입니다
 

248
00:18:39,490 --> 00:18:41,661
파이썬2로 작성이 되었구요
 

249
00:18:41,686 --> 00:18:45,716
C++ 에 취약 코드 클론을 탐지하는 분석기입니다
 

250
00:18:46,990 --> 00:18:50,872
코드 클론은 쉽게 말하면 비슷한 코드뭉치를 의미하는데요
 

251
00:18:51,130 --> 00:18:56,387
아래 보이는 것처럼 완벽하게 동일한 코드의 경우에는 타입1 클론이 됩니다
 

252
00:18:57,310 --> 00:19:00,466
이건 메모장에 있는 찾기로도 충분히 찾아낼 수 있겠죠
 

253
00:19:01,090 --> 00:19:05,355
타입2는 코멘트가 생기거나 변수명이 변경되거나
 

254
00:19:05,560 --> 00:19:09,435
코드 자체는 다르지만
 

255
00:19:09,460 --> 00:19:13,067
프로그램상으로 영향을 주지 않는 것들을 의미하고요
 

256
00:19:13,720 --> 00:19:19,876
타입3는 시멘틱하겐 동일하지만, 프로그램 의미적으로는 동의를 하지만
 

257
00:19:20,620 --> 00:19:23,877
신텍스적으로, 문법적으로 다른 코드를 의미합니다
 

258
00:19:24,910 --> 00:19:27,035
변수가 하나 더 선언이 될 수도 있고요
 

259
00:19:27,340 --> 00:19:32,269
혹은 뭐 더했다 빼기 플러스1 마이너스 1만 해도 신텍스는 바뀌게 되는 거겠죠
 

260
00:19:32,950 --> 00:19:38,476
그리고 타입4는 문법도 다르고 그리고 뭐 함수가 더 선언됐다거나
 

261
00:19:38,500 --> 00:19:43,351
프로그램의 시멘틱도 다르지만 결과는 동일한 코드를 의미합니다
 

262
00:19:43,780 --> 00:19:49,194
그래서 이 VUDDY는 타입 1, 2를 탐지하는
것을 목표로 만들어진 그런 분석기입니다 

263
00:19:51,045 --> 00:19:54,076
그래서 프로그램 1에 코드 V가 있을 때
 

264
00:19:54,130 --> 00:19:59,223
프로그래밍 2에 동일한 취약한 코드 V가 있다면은, 비슷한 코드 V가 있다면
 

265
00:19:59,301 --> 00:20:02,270
마찬가지로 P2도 높은 확률로 취약하다 라는
 

266
00:20:02,317 --> 00:20:05,567
그런 직관으로 만들어진 프로그램입니다
 

267
00:20:07,030 --> 00:20:12,358
그래서 실제로 VUDDY라고 하는 프로그램의 코드를 살펴봤을 때는
 

268
00:20:12,970 --> 00:20:18,149
크게, 함수를 파싱에서 DB에 저장하는 것들을 살펴보실 수가 있습니다
 

269
00:20:18,760 --> 00:20:21,806
지금 슬라이드에 있는 내용들인데요
 

270
00:20:22,493 --> 00:20:26,938
오른쪽에 보이는 것처럼 취약한 코드로부터 취약코드를 추출을 하고
 

271
00:20:27,243 --> 00:20:31,360
그 코드를 DB에 집어넣는 코드가 버디에 존재합니다
 

272
00:20:31,810 --> 00:20:35,776
그래서 그 데이터베이스에 존재하는 정보와 대조함으로써
 

273
00:20:35,800 --> 00:20:38,760
취약한 코드가 존재하는지를 살펴볼 수가 있습니다
 

274
00:20:39,460 --> 00:20:43,889
이런 식으로 자기만의 분석기들을 만드는 것이
 

275
00:20:44,110 --> 00:20:47,750
우리에게 한번 재밌는
 

276
00:20:47,775 --> 00:20:52,867
토이 프로젝트가 될 수 있을 거라 생각을 해서 
이번에 발표를 준비하게 되었습니다 

277
00:20:54,711 --> 00:20:56,482
그래서 다양한 얘기들을 나눴는데요
 

278
00:20:56,507 --> 00:21:00,100
뭐 필요성은 많이들 이해해 주실 거라고 생각합니다
 

279
00:21:00,520 --> 00:21:05,645
하지만 생산성이 너무 떨어지는 건 아닐까 걱정을 하실 수도 있다고 생각합니다
 

280
00:21:07,090 --> 00:21:12,106
그런데 제 생각에는 결국에는 이것은
우리가 해결해야 되는 문제로 남을 것 같습니다 

281
00:21:12,130 --> 00:21:17,200
버그나 프로그램 결함은 결국에는 우리가 해결해야 되는 문제이기 때문에
 

282
00:21:17,800 --> 00:21:21,776
길게 봤을 때는 비용적으로 더 절약되지 않을까 생각합니다
 

283
00:21:22,450 --> 00:21:27,440
왜냐하면 기술부채는 그 이름에 맞춰서 증식하게 됩니다
 

284
00:21:27,465 --> 00:21:32,082
갚는데 비용이 계속 늘어나기 때문에 빨리 갚을수록 더 좋게 되겠지요
 

285
00:21:32,710 --> 00:21:38,266
그래서 왼쪽에 보이는 것처럼 모든 개발 단계
뭐 개발이나 코드 리뷰나 

286
00:21:38,290 --> 00:21:44,407
뭐 인테그레이션 단계 각각에 맞춰서 지속적으로
보안에 대한 신경을 쓰는 게 저는 좋다고 생각합니다 

287
00:21:45,100 --> 00:21:48,951
실제로도 미국 국방연구소의 따르면
 

288
00:21:49,185 --> 00:21:53,583
늦게 발견할수록 코드를 고치는데 드는 비용이
 

289
00:21:53,608 --> 00:21:57,989
무려 30배 이상의 비용이 소요가 된다고 연구한 바가 있습니다
 

290
00:21:58,690 --> 00:22:03,268
그래서 빨리 고칠수록 더 쉽게 빠르게 고칠 수 있겠죠
 

291
00:22:04,540 --> 00:22:08,954
그리고 다시 한 번 말씀드리고 싶은 건 소프트웨어 Ethics입니다
 

292
00:22:09,940 --> 00:22:16,424
우리가 작성하는 코드가 어떤 영향을 주는지에
대해서 고민해보는 게 필요하다고 생각합니다 

293
00:22:17,560 --> 00:22:23,506
화면에 보이는 'Ethics in Software'나 
'The Ethics of Intermet of Things' 라고 하는 발표들은 

294
00:22:23,530 --> 00:22:27,639
이러한 소프트웨어 윤리학에 대해서 많은 생각들을 하게 합니다
 

295
00:22:28,240 --> 00:22:33,316
제가 이번 파이콘에서 발표 주제를 선정하게 된 계기이기도 하니까
 

296
00:22:33,340 --> 00:22:37,074
혹시라도 관심이 있다면 살펴봐주시면 너무 좋을 것 같습니다
 

297
00:22:38,350 --> 00:22:42,521
그래서 저는 '수호'라고 하는 회사를 만들게 된 계기도 유사합니다
 

298
00:22:43,360 --> 00:22:46,756
지금까지 말씀드린 것처럼 다양한 기법들을 이용해서
 

299
00:22:46,780 --> 00:22:51,508
보다 안전한 소프트웨어를 만들 수 있는 세상을 꿈꾸고 있습니다
 

300
00:22:53,170 --> 00:22:58,263
그래서 저희는 현재는 블록체인 소프트웨어를 위한 분석기를 만들고 있고요
 

301
00:22:58,510 --> 00:23:04,728
Odin 이라고 하는 서비스는 웹에서도
odin.sooho.io 들어가셔서 확인해볼 수 있습니다 

302
00:23:05,752 --> 00:23:09,283
앞서 말씀드린 여러 가지 기법들을 모두 파이썬으로 구현해서
 

303
00:23:09,910 --> 00:23:14,609
오른쪽에 보이시는 것처럼 코어한 부분들 모두 파이썬을 이용해서
 

304
00:23:14,656 --> 00:23:17,788
각각의 저희가 발견했던 취약한 패턴들,
 

305
00:23:17,813 --> 00:23:21,015
검사해야 되는 지점들을 모두 구현해서
 

306
00:23:22,015 --> 00:23:26,898
웹이나 기타 마켓 플레이스 뭐 구축형 웹 등등
 

307
00:23:27,010 --> 00:23:29,697
모든 개발환경에 맞춰서 개발한 상황입니다
 

308
00:23:30,190 --> 00:23:35,330
그래서 혹시라도 블록체인에 관심 있으시다면
한번 실행해보시면 재미있을 것 같습니다 

309
00:23:35,710 --> 00:23:37,636
지금까지 많은 얘기를 나눴는데요
 

310
00:23:37,660 --> 00:23:42,355
뭐 제가 공유 들었던 내용들에 대해서 혹시라도 더궁금하시거나
 

311
00:23:42,410 --> 00:23:45,564
관심 있으시다면은 뭐 질문해주시고
 

312
00:23:45,589 --> 00:23:50,836
혹은 언제든지 괜찮으니 커피나 차, 물 
같이 나눌 수 있으면 좋을 것 같습니다 

313
00:23:51,195 --> 00:23:53,969
연락 기다리도록 하겠습니다. 감사합니다


